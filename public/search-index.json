[{"content":"Road Runner는 FTC 로봇 대회를 위해 설계된 모션 플래닝 라이브러리입니다. 주로 자율 주행 로봇의 움직임을 위해 사용되며, 복잡한 경로 생성 및 추적을 가능하게 하고 속도와 가속도를 정밀하게 제어할 수 있습니다. 이를 통해 로봇이 더 정밀하고 고급 경로 추적 기능을 가질 수 있습니다.\nRoad Runner는 Acme Robotics에 의해 개발되었으며, 특히 최근에는 FTC Roadrunner에 FTC Dashboard, Meep Meep 등 다양한 부가 기능을 추가한 FTC Roadrunner Quickstart가 개발되었습니다. 이 문서에서는 Roadrunner Quickstart를 기반으로 Road Runner 사용법을 다루고 있습니다.\n시작하기\n","date":"2023-09-07","id":0,"permalink":"/docs/1-about-roadrunner/road-runner%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC/","summary":"\u003cp\u003eRoad Runner는 \u003ca href=\"https://www.firstinspires.org/robotics/ftc\"\u003eFTC 로봇 대회\u003c/a\u003e를 위해 설계된 모션 플래닝 라이브러리입니다. 주로 자율 주행 로봇의 움직임을 위해 사용되며, 복잡한 경로 생성 및 추적을 가능하게 하고 속도와 가속도를 정밀하게 제어할 수 있습니다. 이를 통해 로봇이 더 정밀하고 고급 경로 추적 기능을 가질 수 있습니다.\u003c/p\u003e","tags":[],"title":"Road Runner에 대하여"},{"content":"1. Pure Pursuit와의 차이점 Road Runner와 Pure Pursuit는 자주 비교되지만, 본질적으로 매우 다른 도구입니다.\nPure Pursuit: 비홀로노믹(Non-Holonomic) 드라이브 트레인을 위한 경로 추적 알고리즘으로, \u0026ldquo;룩어헤드 포인트(Look-Ahead Point)\u0026ldquo;를 사용해 다차원 경로를 따릅니다. Road Runner: Ramsete, 가이드 벡터 필드 등 여러 경로 추적 알고리즘을 지원하며, 속도와 가속도를 제어하는 모션 프로파일링 기능을 포함합니다. 특히, Pure Pursuit는 가속도 제어가 없기 때문에 데드 휠 오도메트리 설치가 필수입니다. 또한, FTC 로봇 대부분이 홀로노믹(메카넘) 드라이브를 사용하기 때문에 Pure Pursuit는 잘 맞지 않는 경우가 많습니다.\n2. 데드 휠/오도메트리란 무엇인가요? 데드 휠과 오도메트리는 종종 같은 의미로 사용되지만, 사실 차이가 있습니다.\n오도메트리: 로봇의 위치를 계산하기 위해 센서를 사용하는 기술입니다. 데드 휠: 동력이 없는 옴니 휠로, 회전 인코더를 통해 이동 거리를 측정합니다. 이 데이터를 통해 로봇의 상대적 위치(x,y)와 방향을 계산할 수 있습니다. 데드 휠을 메카넘 휠에 비해 미끄러지는 정도가 작기에, 데드 휠을 사용할 경우 오차를 줄여 정확도를 크게 향상시킬 수 있습니다.\n데드 휠의 예시\r3. 두 바퀴와 세 바퀴 오도메트리의 차이점은 무엇인가요? 요약: 세 바퀴 구성은 루프 시간을 단축하여 드리프트를 줄이고 더 높은 정확도를 제공합니다.\n위에서 설명했듯이 표준 데드 휠(dead wheel) 구성은 여러 개의 무동력 옴니 휠(omni wheel)을 인코더와 연결하여 사용하는 방식입니다. 그러나 두 개 또는 세 개의 옴니 휠을 선택적으로 사용할 수 있습니다.\n두 바퀴 구성은 서로 수직으로 배치된 두 개의 데드 휠을 사용합니다.\n하나의 휠은 x 방향(앞쪽) 이동을 추적하고, 다른 하나는 y 방향(옆쪽) 이동을 추적합니다. 방향(heading)은 Rev Expansion/Control Hub IMU 또는 외부 센서를 통해 측정됩니다. 세 바퀴 구성은 두 개의 평행한 휠과 하나의 수직 휠을 사용합니다.\n두 평행 휠은 x 방향(앞쪽) 이동과 방향을 모두 추적합니다.\n헤딩은 두 평행 휠의 오프셋을 통해 계산됩니다. 수직 휠은 y 방향(옆쪽) 이동을 추적합니다. 왜 세 바퀴 구성을 선택해야 할까요? 추가 모듈 제작은 번거롭고, 비용이 약 30% 증가하기에 비효율적이라고 생각할 수 있지만, 현재로써는 세 바퀴 구성은 가장 정확한 옵션으로 평가받고 있습니다.\n이유:\nRev Expansion/Control Hub는 느린 I2C 구현을 사용하여 I2C 호출당 약 7ms의 지연 시간이 발생합니다.\nRev Expansion/Control Hub에 내장된 BNO055 IMU는 I2C를 통해 통신하므로, 헤딩을 계산할 때 이 7ms 지연이 추가됩니다. 데드 휠 데이터 읽기(대량 읽기 기준)에도 약 3ms가 소요되므로, 총 지연 시간은 약 10ms입니다.\n이 지연은 두 바퀴 구성에서 IMU를 통해 헤딩을 계산할 때 발생합니다. 반면, 세 바퀴 구성에서는 두 평행 휠을 통해 헤딩을 계산하므로 7ms I2C 호출이 필요하지 않습니다.\n세 개의 데드 휠 모두를 3ms 안에 읽을 수 있으므로(대량 읽기 기준, 모든 인코더가 동일한 Rev Hub에 연결된 경우), 루프 시간이 크게 단축됩니다. 이로 인해 정확도가 향상되고 드리프트가 현저히 줄어드는 결과를 얻을 수 있습니다. 향후 출시될 Control Hub는 Expansion Hub보다 3배 빠른 I/O 속도를 제공하므로, 두 구성 간의 차이가 줄어들 가능성이 있습니다.\n데드 휠을 어떻게 제작하나요? 데드 휠 모듈 제작에는 여러 세부 사항과 선택지가 존재합니다. 현재 기준으로 데드 휠 모듈 제작에 대한 자료는 많지 않습니다.\n모듈당 비용은 약 $30 이상이며, 세 바퀴 구성은 총 $100 이상의 비용이 들 수 있습니다.\n추가 정보를 원한다면 FTC Discord를 방문하세요.\n추천 오픈 소스 데드 휠 설계 자료:\nhttps://openodometry.weebly.com/\n4. 스플라인 경로란 무엇인가요? 스플라인 경로는 스플라인 곡선을 사용해 생성된 경로입니다.\n스플라인 곡선은 여러 점을 매끄럽게 연결하는 다항식 조각으로 이루어져 있습니다. 연속적인 경로를 따라 이동하면서 헤딩을 변경할 수 있어, 자율 주행 경로에 이상적입니다. Road Runner에서는 스플라인 경로를 자주 사용하며, 직선 경로를 단순히 연결하는 것보다 훨씬 부드러운 움직임을 제공합니다.\n5. 기본 단위를 변경할 수 있나요? Road Runner는 기본적으로 인치 단위를 사용합니다.\n공식 FAQ에 따르면, 기본 단위는 인치로 설정되어 있으며, 이를 변경하려면 Road Runner 인터페이스에 대한 래퍼를 직접 작성해야 합니다. 따라서 기본적으로 인치를 사용하는 것이 권장됩니다. 더 자세한 정보가 필요하다면 FTC Discord를 방문해 보세요! 😊 ","date":"2023-09-07","id":1,"permalink":"/docs/1-about-roadrunner/%EC%9E%90%EC%A3%BC-%EB%AC%BB%EB%8A%94-%EC%A7%88%EB%AC%B8-faq/","summary":"\u003ch2 id=\"1-pure-pursuit와의-차이점\"\u003e1. Pure Pursuit와의 차이점\u003c/h2\u003e\n\u003cp\u003eRoad Runner와 Pure Pursuit는 자주 비교되지만, 본질적으로 매우 다른 도구입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ePure Pursuit\u003c/strong\u003e: 비홀로노믹(Non-Holonomic) 드라이브 트레인을 위한 경로 추적 알고리즘으로, \u0026ldquo;룩어헤드 포인트(Look-Ahead Point)\u0026ldquo;를 사용해 다차원 경로를 따릅니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRoad Runner\u003c/strong\u003e: Ramsete, 가이드 벡터 필드 등 여러 경로 추적 알고리즘을 지원하며, 속도와 가속도를 제어하는 모션 프로파일링 기능을 포함합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e특히, Pure Pursuit는 가속도 제어가 없기 때문에 데드 휠 오도메트리 설치가 필수입니다. 또한, FTC 로봇 대부분이 홀로노믹(메카넘) 드라이브를 사용하기 때문에 Pure Pursuit는 잘 맞지 않는 경우가 많습니다.\u003c/p\u003e","tags":[],"title":"자주 묻는 질문 (FAQ)"},{"content":"\r주의\n계속하기 전에 아래 사항을 반드시 확인하세요!\n팁\n1. 이 튜토리얼은 Java 프로그래밍 언어와 FTC SDK에 익숙하다는 전제하에 작성되었습니다. 둘 다 시간이 지나고 실습을 통해 경험이 쌓이면 익숙해질 수 있습니다. 지금 당장은 자신이 부족하다고 느낄지 몰라도, 코드를 작성하면서 점점 더 나아질 거예요! 👊\n팁\n2. 이 개념들은 어렵고 복잡하게 느껴질 수 있습니다. 이 튜토리얼은 최대한 쉽게 설명하려고 노력했지만, 모든 사람에게 맞는 것은 아닐 수 있습니다. 도움이 필요하다면, FTC Discord에 많은 친절하고 똑똑한 사람들이 있으니 꼭 참여해보세요! Road Runner에 경험이 많은 사람들도 많습니다.\n팁\n3. 이 튜토리얼은 설치, 사용법, 팁과 트릭에 대해 다룹니다. 그러나 Road Runner의 내부 작동 방식에 대해 깊이 설명하지는 않습니다. PID 제어와 모션 프로파일링의 작동 방식을 깊이 이해하면 학습 과정이 훨씬 빨라질 것입니다. Road Runner의 공식 퀵스타트 문서를 확인해보는 것을 추천합니다. 여기에는 내부 작동 방식이 잘 설명되어 있습니다.\n주의\n튜닝 과정을 진행할 때 충분한 공간을 확보하는 것이 매우 중요합니다. 넉넉한 공간은 더 정확한 튜닝을 가능하게 합니다. 개인적으로 로봇이 주행할 수 있는 90인치 정도의 공간을 추천합니다. 최소한 필드 너비(72인치) 정도는 확보해야 합니다.\n이제 준비 완료! 다음 페이지로 이동해 시작해봅시다! 🚀 알아두어야 할 용어 많은 용어가 나오는데 잘 이해되지 않는다면 걱정하지 마세요. 이 페이지에서 주요 용어를 정리해 드립니다.\n혹시 이 페이지에 없는 반복적으로 등장하는 용어가 있다면, Discord (Noah#5396)로 연락하거나 GitHub Pull Request를 통해 추가 요청을 해주세요!\n로컬라이제이션 (Localization) 고급 FTC 팀들 사이에서 \u0026ldquo;로컬라이제이션\u0026quot;이라는 용어를 자주 듣게 될 것입니다. 로컬라이제이션이란 기본적으로 로봇이 현재 자신의 위치를 알고 있는 능력을 의미합니다. 자신의 위치를 모른 채 특정 지점으로 이동하는 것은 매우 어려운 일입니다(이는 폐쇄 루프 제어와 개방 루프 제어의 차이와 유사합니다). 로컬라이제이션은 일반적으로 오도메트리(odometry)를 통해 이루어지며, 때로는 VSLAM 같은 더 복잡한 방법(Intel Realsense T265 사용 등)을 사용할 수도 있습니다. 구동 엔코더나 외부 휠을 사용해 데이터를 수집하고, 이를 운동 방정식에 대입하여 로봇의 상대적 자세(x, y, 방향)를 계산합니다.\n모션 프로파일 (Motion Profile) 모션 프로파일은 특정 상태에 도달하기 위해 따라야 할 동작을 그래프로 나타낸 것입니다. Road Runner의 경우, 주로 로봇의 속도를 정의된 자세로 이동시키기 위한 그래프를 생성합니다(모션 프로파일은 엘리베이터와 같은 다른 구성 요소에도 생성될 수 있습니다). 간단히 말해, 모션 프로파일은 특정 지점으로 이동하기 위해 필요한 전체 움직임을 계획하는 것입니다. 최대 속도, 최대 가속도 등을 정의하여 이 그래프를 제어할 수 있습니다. 더 자세한 설명은 여기를 참조하세요. 또한, FRC 팀 254의 컨퍼런스 강연도 훌륭한 자료입니다.\n개방 루프 제어 vs 폐쇄 루프 제어 (Open vs Closed Loop Control) 이 둘의 차이는 피드백의 유무에 달려 있습니다. 피드백이 있으면 \u0026ldquo;루프를 닫을 수\u0026rdquo; 있습니다. 그렇다면 피드백이란 무엇일까요?\n예를 들어, 모터의 속도를 제어하려고 한다고 가정해봅시다. 개방 루프 제어는 원하는 값을 \u0026ldquo;추정\u0026quot;하는 방식입니다. 기존의 수학적 모델을 사용해 값을 계산한 뒤, 이를 적용해 원하는 결과를 기대합니다. 하지만 현실에서는 물리적 허용 오차, 전기적 노이즈 등의 이유로 정확한 결과를 얻기 어렵습니다.\n반면 폐쇄 루프 제어에서는 엔코더를 통해 실제 속도를 측정하고, 이를 기반으로 출력 전압을 조정합니다. 이 방식은 PID 컨트롤러를 통해 주로 구현됩니다.\nVector2d 2차원 벡터를 나타냅니다: X와 Y 좌표.\n// (x: 10, y: -5) 좌표에 벡터 생성 Vector2d myVector = new Vector2d(10, -5);\rPose2d 2차원 로봇 자세를 나타냅니다: X와 Y 좌표, 그리고 방향.\n로봇의 위치와 방향을 나타내며, 각도가 증가하면 반시계 방향으로 회전합니다(삼각함수에서 배운 단위 원과 동일). 각도는 반드시 라디안 단위로 표현해야 하므로 Math.toRadians() 함수를 사용해 도를 라디안으로 변환합니다.\n// (x: 10, y: -5) 좌표에서 90도 방향을 향하는 자세 생성 Pose2d myPose = new Pose2d(10, -5, Math.toRadians(90));\r","date":"2023-09-07","id":2,"permalink":"/docs/2-before-you-start/%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84%EC%97%90/","summary":"\u003cdiv class=\"callout callout-caution d-flex flex-row mt-4 mb-4 pt-4 pe-4 pb-2 ps-3\"\u003e\r\n  \u003csvg\n  xmlns=\"http://www.w3.org/2000/svg\"\n  width=\"24\"\n  height=\"24\"\n  viewBox=\"0 0 24 24\"\n  fill=\"none\"\n  stroke=\"currentColor\"\n  stroke-width=\"2\"\n  stroke-linecap=\"round\"\n  stroke-linejoin=\"round\"\n \n class=\"outline/alert-triangle svg-inline callout-icon me-2 mb-3\" id=\"svg-alert-triangle\" role=\"img\"\u003e\n  \u003cpath stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"/\u003e\n  \u003cpath d=\"M12 9v4\" /\u003e\n  \u003cpath d=\"M10.363 3.591l-8.106 13.534a1.914 1.914 0 0 0 1.636 2.871h16.214a1.914 1.914 0 0 0 1.636 -2.87l-8.106 -13.536a1.914 1.914 0 0 0 -3.274 0z\" /\u003e\n  \u003cpath d=\"M12 16h.01\" /\u003e\n\u003c/svg\u003e\r\n  \u003cdiv class=\"callout-content\"\u003e\r\n    \u003cdiv class=\"callout-title\"\u003e\r\n        \u003cp\u003e주의\u003c/p\u003e","tags":[],"title":"시작하기 전에"},{"content":"Road Runner 라이브러리를 설치하는 방법에는 두 가지가 있습니다.\n주의\nRoad Runner는 점차 레거시 소프트웨어로 전환되고 있어, 2023-24 시즌 이후에는 Quickstart가 최신 SDK 요구 사항과 호환되지 않을 수 있습니다. Driver Station에서 \u0026ldquo;로봇 컨트롤러가 오래되었습니다\u0026quot;라는 오류가 발생하면, FIRST 공식 SDK를 다운로드하고 방법 #2를 사용하세요.\n방법 #1은 더 간단한 옵션으로, Quickstart 저장소를 다운로드하는 것입니다. 이 저장소는 빈 FTC 시즌 프로젝트와 함께 Road Runner를 바로 실행할 수 있도록 필요한 종속성과 튜닝 관련 OpMode가 미리 설치되어 있습니다. 하지만 이미 기존 코드베이스가 있는 경우에는 이 방법이 적합하지 않을 수 있습니다.\n방법 #2는 Gradle을 사용해 Road Runner를 설치하고 Quickstart 저장소에서 필요한 파일을 복사해 기존 팀 프로젝트에 추가하는 방법입니다.\n설치 후, Rev Expansion Hub 또는 Control Hub 펌웨어를 업그레이드하는 것을 강력히 권장합니다. 자세한 방법은 아래에서 확인할 수 있습니다.\n방법 1: Quickstart 다운로드 Quickstart 저장소에 접속하세요. (이 저장소는 Iris_TheRainbow가 관리하며, 공식 Quickstart보다 최신 상태를 유지할 가능성이 높습니다.) 녹색 \u0026ldquo;Code\u0026rdquo; 버튼을 클릭한 뒤 \u0026ldquo;Download ZIP\u0026quot;을 선택하세요. 다운로드한 ZIP 파일을 원하는 디렉토리에 압축 해제하세요. Android Studio에서 해당 폴더를 열어주세요. 이제 Road Runner를 실행할 준비가 완료되었습니다! 방법 2: 기존 프로젝트에 RR 설치하기 ::: warning 이 설치 가이드는 SDK 9.1 기준으로 작성되었습니다. 이후 SDK 버전에서는 정확하지 않을 수 있습니다. :::\n프로젝트가 최신 FTC 표준 프로젝트 파일 구조(작성 시점 기준 SDK 9.1)와 동일하다고 가정합니다. 해당 프로젝트는 여기에서 확인할 수 있습니다.\n프로젝트 루트 디렉토리에서 build.dependencies.gradle 파일을 찾으세요.\nFtcRobotController ├── .github ├── FtcRobotController ├── TeamCode ├── doc ├── gradle/wrapper ├── libs ├── .gitignore ├── README.md ├── build.common.gradle ├── `build.dependencies.gradle` _(**이 파일**_) ├── build.gradle ├── gradle.properties ├── gradlew ├── gradlew.bat └── settings.gradle\rrepositories 블록 끝에 다음 코드를 추가하세요:\nmaven { url = \u0026#39;https://maven.brott.dev/\u0026#39; }\r그런 다음, dependencies 블록 끝에 아래 코드를 추가하세요:\nimplementation \u0026#39;com.acmerobotics.dashboard:dashboard:0.4.15\u0026#39;\r::: warning 이 가이드는 작성 시점(2024년 2월 17일) 기준 최신 상태입니다. 특히 2024-2025 FTC 시즌이 시작되면 이 웹사이트를 방문해 최신 버전을 확인하고 업데이트된 필드 다이어그램을 사용하세요. :::\nOpenRC를 사용하는 경우, 여기에서 대시보드 관련 별도 지침을 확인하세요.\nTeamCode/build.gradle 파일을 찾아 열어주세요. FtcRobotController ├── .github ├── FtcRobotController ├── TeamCode │ ├── src/main │ └── `build.gradle` _(**이 파일**_) ├── doc ├── gradle/wrapper ├── libs ├── .gitignore ├── README.md ├── build.common.gradle ├── build.dependencies.gradle ├── build.gradle ├── gradle.properties ├── gradlew ├── gradlew.bat └── settings.gradle\rTeamCode/build.gradle 파일에 아래 종속성을 추가하세요:\nimplementation \u0026#39;org.apache.commons:commons-math3:3.6.1\u0026#39; implementation \u0026#39;com.fasterxml.jackson.core:jackson-databind:2.12.7\u0026#39; implementation \u0026#39;com.acmerobotics.roadrunner:core:0.5.6\u0026#39;\rQuickstart 저장소를 다운로드하세요. Git을 사용하는 경우 아래 명령어를 실행하세요:\ngit clone --single-branch -b quickstart1 https://github.com/acmerobotics/road-runner-quickstart.git\rTeamCode 폴더에 있는 drive, util, trajectorysequence 폴더를 프로젝트의 적절한 위치(보통 TeamCode 폴더)로 이동하세요.\n펌웨어 업그레이드 Control Hub 또는 Expansion Hub 펌웨어를 최신 버전으로 업그레이드하는 것을 강력히 추천합니다. 펌웨어 버전 1.8.2는 다음과 같은 성능 개선 사항을 제공합니다:\nDC 모터 출력 선형성 향상 클로즈 루프 제어 개선 I2C 속도 향상 ESD 오류 복구를 위한 USB 복구 기능 Road Runner의 성능은 이러한 개선 사항의 직접적인 영향을 받습니다.\n펌웨어 업그레이드 방법은 REV 공식 문서에서 확인할 수 있습니다.\n이제 준비 완료! 설치가 끝났습니다. 이제 튜닝을 시작하세요! 🚀\n","date":"2023-09-07","id":3,"permalink":"/docs/3-installation/%EC%84%A4%EC%B9%98-%EB%B0%8F-%EC%A4%80%EB%B9%84/","summary":"\u003cp\u003eRoad Runner 라이브러리를 설치하는 방법에는 두 가지가 있습니다.\u003c/p\u003e\n\u003cdiv class=\"callout callout-caution d-flex flex-row mt-4 mb-4 pt-4 pe-4 pb-2 ps-3\"\u003e\r\n  \u003csvg\n  xmlns=\"http://www.w3.org/2000/svg\"\n  width=\"24\"\n  height=\"24\"\n  viewBox=\"0 0 24 24\"\n  fill=\"none\"\n  stroke=\"currentColor\"\n  stroke-width=\"2\"\n  stroke-linecap=\"round\"\n  stroke-linejoin=\"round\"\n \n class=\"outline/alert-triangle svg-inline callout-icon me-2 mb-3\" id=\"svg-alert-triangle\" role=\"img\"\u003e\n  \u003cpath stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"/\u003e\n  \u003cpath d=\"M12 9v4\" /\u003e\n  \u003cpath d=\"M10.363 3.591l-8.106 13.534a1.914 1.914 0 0 0 1.636 2.871h16.214a1.914 1.914 0 0 0 1.636 -2.87l-8.106 -13.536a1.914 1.914 0 0 0 -3.274 0z\" /\u003e\n  \u003cpath d=\"M12 16h.01\" /\u003e\n\u003c/svg\u003e\r\n  \u003cdiv class=\"callout-content\"\u003e\r\n    \u003cdiv class=\"callout-title\"\u003e\r\n        \u003cp\u003e주의\u003c/p\u003e","tags":[],"title":"설치 및 준비"},{"content":"시작하기 전에, 각 단계에서 무엇을 하는지 이해하는 것이 중요합니다.\n팁\n이 페이지는 Road Runner 공식 퀵스타트의 조율 가이드를 바탕으로 작성되었으며, 개인 경험을 바탕으로 한 추가적인 팁을 포함하고 있습니다. 보다 자세한 내용은 공식 가이드를 참고하세요.\nRoad Runner는 복잡한 수학적 계산을 통해 로봇의 동작을 제어하지만, 로봇이 매끄럽게 작동하려면 반드시 조율(Tuning) 과정이 필요합니다. 모터, 무게 등 로봇마다 다른 특성이 구동 방식에 영향을 미치기 때문에, 조율 가이드를 따라 각 로봇에 맞게 구동 체계를 조정해야 합니다.\n주의\n로봇에 무거운 부품을 추가하는 등 큰 변화가 있을 경우, 반드시 재튜닝이 필요합니다. 조율 과정은 이전보다 빠르게 진행될 수 있지만, 일관된 성능을 위해 권장됩니다.\n각 단계를 완료한 후에 다음 단계로 진행하세요.\n피드포워드(Feedforward)란 무엇인가? 피드 포워드 속도 제어는 전압을 속도로 변환하는 함수를 생성하는 개방 루프 시스템입니다. 이 과정에서 구동 중 실시간 피드백이 부족하다는 문제가 있지만, 병진 이동 PID가 이를 보완하여 에러를 수정합니다.\n주행 속도 PID (Drive Velocity PID)는 어디에 있나요? 주행 속도 PID는 더 이상 사용되지 않습니다. 그 이유는 여기에서 확인할 수 있습니다.\n드라이브 인코더 또는 오도메트리 사용 여부와 관계없이 피드포워드 방식을 사용하세요.\n드라이브 상수 설정 드라이브 상수(Drive Constants) 파일에는 로봇의 물리적 특성과 관련된 모든 정보가 포함됩니다. 예를 들어, 모터의 최대 RPM, 바퀴 반지름 등이 포함됩니다. 이 단계에서 발생하는 가장 심각한 오류는 보통 드라이브 상수에서 시작됩니다.\n예를 들어, 로봇이 지정된 거리의 절반만 이동한다면, 이는 드라이브 상수의 문제일 가능성이 높습니다.\n드라이브 상수 사용에 대한 자세한 내용은 드라이브 상수 설정 페이지에서 확인할 수 있습니다.\n데드 휠 설정 로봇에 데드 휠이 있다면, 드라이브 상수를 편집한 후 데드 휠을 설정해야 합니다. 데드 휠이 없다면 이 단계를 무시하세요.\n데드 휠에 대해 잘 모르겠다면 FAQ의 예제를 참고하세요.\n데드 휠 조율은 로컬라이제이션 테스트에서 수행됩니다. 데드 휠의 정확한 조율은 로봇의 정확한 로컬라이제이션 및 경로 추적을 위해 매우 중요합니다.\n로봇이 2개의 데드 휠을 사용하는지, 3개의 데드 휠을 사용하는지에 따라 설정이 달라집니다. 차이를 모르겠다면 FAQ를 참고하세요.\n자세한 내용은 데드 휠 설정 페이지에서 확인할 수 있습니다.\n로컬라이제이션 테스트 1 주의\n이 첫 번째 로컬라이제이션 테스트는 데드 휠 로컬라이제이션을 테스트 및 조율하기 위한 것입니다. 데드 휠를 사용하지 않기로 결정했다면 이 단계를 건너뛰세요.\n로컬라이제이션 테스트를 실행하고 로봇을 필드에서 이동시켜 로컬라이제이션과 관련된 문제를 찾으세요. 데드 휠 로컬라이제이션은 데드 휠을 설정한 후 조율해야 합니다.\n로컬라이제이션의 정확성은 경로 추적의 정확성에 큰 영향을 미칩니다.\n데드 휠을 사용하지 않는 경우, 이후 단계에서 로컬라이제이션 테스트를 수행합니다.\n자세한 내용은 데드 휠 조절 페이지에서 확인할 수 있습니다.\n주행 피드포워드 조율 피드포워드 방식을 선택했다면 피드포워드 상수를 조율해야 합니다.\n공식 Quickstart는 자동 튜너와 수동 튜너를 제공합니다. 하지만 일부 사용자는 자동 튜너가 최적의 결과를 제공하지 않는다고 느낄 수 있습니다.\n자동 조율 과정은 다음과 같습니다(공식 문서에서 발췌):\nkV와 kStatic을 찾기 위해 로봇은 전압을 천천히 증가시키는 정적 램프 테스트를 실행합니다. 이 과정에서 속도와 전압이 기록됩니다. 속도 대 전압 그래프에서 kV는 기울기, kStatic은 Y절편입니다.\n다음으로 kA를 찾기 위해 로봇은 정지 상태에서 급가속을 시도합니다. 이 과정에서 가속도, 속도, 전압이 기록됩니다. 가속도 대 전압 그래프에서 기울기는 kA입니다.\n자동 튜너는 kA 값을 매우 낮게 산출하는 경향이 있습니다. 따라서 수동 조율 방식을 추천합니다.\n자세한 내용은 주행 피드포워드 페이지에서 확인할 수 있습니다.\n주행 속도 PID 조율 [사용하지 않음!] 경고\n이 조율 방법을 따르지 마십시오. 피드 포워드 조율을 대신 사용하세요.\nDriveVelocityPIDTuner는 Rev Hub의 내장 모터 속도 제어기(RUN_USING_ENCODER 모드)를 조율하는 데 사용됩니다. PIDF 계수를 최적화하여 일관된 동작을 보장하는 것이 중요합니다.\nPIDF 계수는 로봇의 무게에 영향을 미치는 주요 변경 사항 이후에 반드시 조정해야 합니다.\n주행 속도 PID 조율 과정은 주행 속도 PID Tuning 페이지에 자세히 설명되어 있습니다. PIDF 값을 조정하여 원하는 동작을 얻을 수 있습니다.\n공식 Road Runner 문서에서는 \u0026ldquo;약간의 진동이 발생하더라도 위상 지연을 제거하는 것을 우선시하라\u0026quot;고 권장하지만, 개인적으로는 특히 정지 상태에서 진동을 최소화하는 것이 더 낫다고 생각합니다.\n위상 지연을 제거하면 고속에서 매우 불안정한 동작을 유발할 수 있습니다. 이는 Rev Hub의 모터 제어 방식 때문일 가능성이 높습니다.\n더 자세한 기술적 내용을 알고 싶다면 FTC Discord를 통해 문의하세요.\n제 개인적인 조언은 진동을 최소화하고 병진 이동 PID를 통해 위상 지연 문제를 해결하는 것입니다.\n직진 테스트 직진 테스트는 피드포워드/속도 PID 조율의 효과를 확인하는 데 사용됩니다. StraightTest OpMode를 여러 번 실행하여 로봇이 일정한 거리 내에서 안정적으로 이동하는지 확인하세요.\n로봇이 매번 정확히 같은 위치에 도달하지 않아도 됩니다. 이후 로컬라이제이션을 통해 폐쇄 루프 피드백이 활성화될 것입니다.\n데드 휠 없이 엔코더만 사용하는 경우, 이 단계에서 엔코더 로컬라이제이션을 튜닝하게 됩니다.\n자세한 내용은 직진 테스트 페이지에서 확인할 수 있습니다.\n경로 폭 조율 경로 폭(Track Width)는 한 바퀴에서 평행한 다른 바퀴까지의 거리입니다. 이는 물리적으로 측정할 수 있지만, 실제 경로 폭는 여러 요인으로 인해 물리적 측정값과 다를 수 있습니다.\n이를 보정하기 위해 TrackWidthTuner OpMode를 실행하여 경험적 경로 폭를 계산합니다.\nTrackWidthTuner는 원하는 경험적 경로 폭에 1인치 정도의 오차 범위 내에서 도달합니다. TurnTest OpMode를 실행하고 드라이브 상수에서 경로 폭를 수정하여 수동으로 조정해야 할 수도 있습니다.\n자세한 내용은 Track Width Tuning 페이지에서 확인할 수 있습니다.\n회전 테스트 회전 테스트를 실행하여 경로 폭가 올바른지 확인하세요.\n자세한 내용은 회전 테스트 조율 페이지에서 확인할 수 있습니다.\n로컬라이제이션 테스트 2 주의\n두 번째 로컬라이제이션 테스트는 엔코더를 사용하는 로컬라이제이션을 테스트하기 위한 것입니다. 엔코더를 사용하지 않기로 결정했다면 이 단계를 건너뛰세요.\n로컬라이제이션 테스트를 실행하고 로봇을 필드에서 이동시켜 엔코더를 사용하는 로컬라이제이션과 관련된 문제를 찾으세요.\n엔코더를 사용하는 로컬라이제이션은 이전 단계에서 조율되어야 합니다. 로컬라이제이션의 정확성은 경로 추적의 정확성에 큰 영향을 미칩니다.\n두 번째 로컬라이제이션 테스트는 엔코더를 사용하는 구동의 정확성을 테스트하는 데 사용됩니다.\n데드 휠을 사용하여 로컬라이제이션을 조율했다면 이 단계를 건너뛰세요.\n자세한 내용은 로컬라이제이션 테스트 페이지에서 확인할 수 있습니다.\n팔로워 PID 조율 이 단계에서는 회전 PID와 병진 이동 (x/y) PID 두 가지를 조율합니다.\n이 PID는 폐쇄 루프 피드백 제어를 활성화하여 정확한 경로 추적을 보장합니다.\nBackAndForth OpMode를 실행하여 회전 및 병진 이동 PID를 대략적으로 조율한 후, FollowerPIDTuner OpMode를 사용해 세부적으로 조정합니다.\n자세한 내용은 팔로워 PID 조율 페이지에서 확인할 수 있습니다.\n스플라인 테스트 모든 조율이 완료된 후, 로봇은 스플라인 경로를 정확하게 따라야 합니다.\n스플라인 테스트가 실패하면 문제를 식별하고 해당 단계로 돌아가 다시 조율하세요.\n어려움을 겪고 있다면 FTC Discord에서 도움을 요청하세요!\n자세한 내용은 스플라인 테스트 페이지에서 확인할 수 있습니다.\n","date":"2023-09-07","id":4,"permalink":"/docs/4-tuning/%EA%B0%9C%EC%9A%94/","summary":"\u003cp\u003e시작하기 전에, 각 단계에서 무엇을 하는지 이해하는 것이 중요합니다.\u003c/p\u003e\n\u003cdiv class=\"callout callout-tip d-flex flex-row mt-4 mb-4 pt-4 pe-4 pb-2 ps-3\"\u003e\r\n  \u003csvg\n  xmlns=\"http://www.w3.org/2000/svg\"\n  width=\"24\"\n  height=\"24\"\n  viewBox=\"0 0 24 24\"\n  fill=\"none\"\n  stroke=\"currentColor\"\n  stroke-width=\"2\"\n  stroke-linecap=\"round\"\n  stroke-linejoin=\"round\"\n \n class=\"outline/rocket svg-inline callout-icon me-2 mb-3\" id=\"svg-rocket\" role=\"img\"\u003e\n  \u003cpath stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"/\u003e\n  \u003cpath d=\"M4 13a8 8 0 0 1 7 7a6 6 0 0 0 3 -5a9 9 0 0 0 6 -8a3 3 0 0 0 -3 -3a9 9 0 0 0 -8 6a6 6 0 0 0 -5 3\" /\u003e\n  \u003cpath d=\"M7 14a6 6 0 0 0 -3 6a6 6 0 0 0 6 -3\" /\u003e\n  \u003cpath d=\"M15 9m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0\" /\u003e\n\u003c/svg\u003e\r\n  \u003cdiv class=\"callout-content\"\u003e\r\n    \u003cdiv class=\"callout-title\"\u003e\r\n        \u003cp\u003e팁\u003c/p\u003e","tags":[],"title":"개요"},{"content":"\r팁\n여기에서 편집할 드라이브 상수 파일입니다.\nDriveConstants.java\n아직 이 파일을 프로젝트에 복사하지 않았다면, 복사해서 사용하세요!\n구성기(Configurator)를 사용하면 상수를 빠르게 생성할 수 있습니다. (단 현재 문서에서는 아직 기능을 지원하지 않습니다.)\n기능을 이용하기 위해서는 아래 버튼을 클릭한 후 Configure Me! 버튼을 눌러주세요.\n구성기 사용하러 가기\n아래에서는 각 상수가 무엇을 의미하는지 하나씩 살펴보겠습니다.\n경고\n자동 구성을 사용하는 경우, IMU 정보를 직접 파일에 추가해야 합니다. IMU 정보는 이곳에서 확인하세요.\n현재 단계는 드라이브 상수 설정 단계입니다.\n회전당 틱 수 (TPR) \u0026amp; 최대 RPM /* DriveConstants.java 파일의 약 24~25번째 줄 */ public static final double TICKS_PER_REV = 1; public static final double MAX_RPM = 1;\rTICKS_PER_REV 이 값은 모터 엔코더가 한 바퀴 회전할 때 카운트하는 \u0026ldquo;틱\u0026quot;의 수를 나타냅니다. 모터의 사양은 제조업체의 사이트에서 확인할 수 있습니다.\n예를 들어, goBILDA의 5202/5203/5204 모터의 경우 여기에 있는 각 모터의 사양 페이지에서 \u0026ldquo;Specs\u0026rdquo; 섹션에 표시된 Encoder Resolution 값을 사용해야 합니다.\n다음은 goBILDA가 아닌 몇몇 모터의 사양 리스트입니다. 일부 제조업체는 이 정보를 명확하게 제공하지 않으므로 참고하시기 바랍니다. (goBILDA에 감사드립니다!)\n모터 회전당 틱 수 최대 RPM REV HD Hex 40:1 Spur 1120 150 REV HD Hex 20:1 Spur 560 300 REV HD Hex 20:1 Planetary* 537.6 312.5 NeveRest Classic 60 1680 105 NeveRest Classic 40 1120 160 NeveRest Orbital 20* 537.6 349 NeveRest Orbital 3.7 103.6 1780 TETRIX TorqueNADO 60:1 1440 100 TETRIX TorqueNADO 40:1 960 150 TETRIX TorqueNADO 20:1 480 480 MAX_RPM 이 값은 권장 전압(12V)에서 모터가 도달할 수 있는 최대 RPM(분당 회전 수)을 나타냅니다.\n* 이러한 모터는 20:1 비율로 표시되지만, 실제로는 19.2:1의 비율을 가지고 있습니다. 이는 플래니터리 기어 구조로 인해 20:1 스퍼 모터와 속도/틱 값이 다릅니다.\n엔코더 사용 및 모터 속도 PID 설정 /* DriveConstants.java 파일의 약 35~37번째 줄 */ public static final boolean RUN_USING_ENCODER = true; public static PIDFCoefficients MOTOR_VELO_PID = new PIDFCoefficients(0, 0, 0, getMotorVelocityF(MAX_RPM / 60 * TICKS_PER_REV));\rRUN_USING_ENCODER 이 값은 FTC SDK에 내장된 RunMode 중 하나인 RUN_USING_ENCODER를 사용할지 여부를 결정합니다. 이를 통해 모터를 \u0026ldquo;전력\u0026rdquo; (전압)이 아니라 속도로 제어할 수 있는 온보드 속도 PID를 활용할 수 있습니다. 이 값을 true로 설정하면 모든 모터가 속도 제어 모드로 자동 설정됩니다.\nRUN_USING_ENCODER는 구동 엔코더를 사용할 때만 사용할 수 있습니다. 구동 엔코더를 사용하지 않는 경우 이 값을 false로 설정하세요.\n주의\n피드포워드(Fedforward) 튜닝을 사용하는 것이 권장되므로, 구동 엔코더를 사용하더라도 이 값을 false로 설정해 두는 것이 좋습니다.\nMOTOR_VELO_PID 이 값은 사용할 PID 값을 저장합니다. SDK의 기본 PIDF 값은 부하 없이 자유롭게 회전하는 모터를 기준으로 조정되었으며, 이는 구동 트레인에는 적합하지 않습니다.\n따라서 Quickstart는 이 값을 기본값인 0으로 설정하며, 나중에 튜닝을 진행합니다.\n주의\n피드포워드 제어 방식이 권장되므로 이 값을 변경하지 마세요.\n바퀴 반지름 / 기어비 / 트랙 폭 /* DriveConstants.java 파일의 약 47~49번째 줄 */ public static double WHEEL_RADIUS = 2; // 인치 단위 public static double GEAR_RATIO = 1; // 출력(바퀴) 속도 / 입력(모터) 속도 public static double TRACK_WIDTH = 1; // 인치 단위\rWHEEL_RADIUS 구동 트레인의 바퀴 반지름을 나타냅니다. 이 값은 직경이 아니라 반지름이어야 합니다.\nGEAR_RATIO 출력(바퀴) 속도를 입력(모터) 속도로 나눈 값입니다.\n기어나 벨트 없이 직구동(direct drive)을 사용하는 경우, GEAR_RATIO는 1로 설정해야 합니다.\n기어비가 1보다 크면 바퀴가 모터보다 더 빠르게 회전함을 나타내고, 1보다 작으면 바퀴가 모터보다 더 느리게 회전함을 나타냅니다.\n예를 들어, 2019년 v1 goBILDA Strafer Kit에는 1:2 기어가 포함되어 있어 출력 속도가 절반으로 줄어듭니다. 이 경우 기어비는 1/2 또는 0.5입니다.\n주의\n기어비를 분수로 설정할 경우, 반드시 소수값을 사용하세요.\n// 이렇게 하면 안 됩니다 public static double GEAR_RATIO = 2 / 3; // 이렇게 하세요 public static double GEAR_RATIO = 2.0 / 3.0;\r첫 번째 경우는 정수 나누기(integer division)로 처리되어 값이 0이 된 다음 double 타입으로 변환됩니다.\nTRACK_WIDTH 한쪽 바퀴의 중심에서 평행한 다른 쪽 바퀴의 중심까지의 거리입니다.\n이 값은 대략적인 추정치만으로도 충분하며, 나중에 경험적으로 튜닝할 것입니다.\n2019/20 Skystone 시즌의 3658 Bosons 로봇\rkV/kA/kStatic /* DriveConstants.java 파일의 약 57~59번째 줄 */ public static double kV = 1.0 / rpmToVelocity(MAX_RPM); public static double kA = 0; public static double kStatic = 0;\r이 값들은 구동 모터의 피드포워드 게인을 나타냅니다.\n피드포워드 방식을 선택한 경우, 나중에 값을 튜닝할 수 있습니다. 현재는 기본값으로 두세요.\nkV 단위: 볼트 * 초 / 미터 이론적으로, kV는 12볼트를 모터의 이론적 자유 속도로 나눈 값입니다. kA 단위: 볼트 * 초² / 미터 kStatic 단위: 볼트 모터 모델에 대한 추가 정보는 Controls Engineering in FRC by Tyler Veness에서 확인할 수 있습니다.\n이 상수들의 효과는 나중에 시연을 통해 설명할 예정입니다.\n기본 제한값 설정(Base Constraints) /* DriveConstants.java 파일의 약 68~71번째 줄 */ public static double MAX_VEL = 30; public static double MAX_ACCEL = 30; public static double MAX_ANG_VEL = Math.toRadians(180); public static double MAX_ANG_ACCEL = Math.toRadians(180);\rMAX_VEL 로봇이 달성할 수 있는 최대 속도를 정의합니다.\n이 값은 로봇이 가속하여 도달할 수 있는 가장 빠른 속도를 나타냅니다. 기본값은 30인치/초입니다. 이론적인 최대 속도는 아래의 공식을 통해 계산할 수 있습니다:\n로봇의 최대 속도 제약은 모터 최대 속도의 80%를 초과하지 않도록 설정하는 것이 좋습니다. 배터리 전압 감소, 무게 등 여러 요인으로 인해 이론적인 최대 속도에 도달하기 어려울 수 있습니다.\n최대 속도를 더 높게 설정할 수도 있지만, 로봇이 해당 속도에 도달하지 못하면 경로 추적 성능이 저하될 수 있습니다.\nMaxVelocityTuner 오프모드를 사용하여 최대 속도를 실험적으로 정의할 수 있습니다. 그러나, MAX_VEL은 MaxVelocityTuner 출력값의 **90~95%**로 설정하는 것이 권장됩니다.\nMAX_ACCEL 로봇이 가속할 수 있는 최대 가속도를 정의합니다.\n이 값은 속도가 얼마나 빠르게 증가하는지를 나타냅니다. 기본값은 30인치/초²입니다.\n처음에는 이 값을 최대 속도(MAX_VEL)와 동일하게 설정하는 것이 권장되며, 이는 대략적인 기준입니다.\n실험적으로 값을 결정하려면 가속도를 점진적으로 높이면서 경로 추적 성능이 저하되는 시점을 찾으면 됩니다.\n이 작업은 PID 튜닝 후에 수행하는 것이 더 쉽습니다.\nMAX_ANG_VEL 로봇이 회전할 수 있는 최대 각속도를 정의합니다.\n이 값은 로봇이 가장 빠르게 회전할 수 있는 속도를 나타내며 기본값은 180°/초입니다.\n최대 각속도는 최대 접선 속도(MAX_VEL)를 트랙 폭(TRACK_WIDTH)으로 나누어 계산할 수 있습니다.\n그러나 실험적으로 값을 결정하거나 기본값을 사용하는 것이 좋습니다.\n이론적인 최대 각속도와 측정값은 잘 일치하지 않을 수 있습니다.\nMAX_ANG_ACCEL 로봇이 회전할 수 있는 최대 각가속도를 정의합니다.\n이 값은 로봇의 각속도가 얼마나 빠르게 증가할 수 있는지를 나타내며 기본값은 180°/초²입니다.\n실험적으로 값을 찾을 수 있지만, 이를 정확히 측정하는 것은 어려울 수 있으므로 기본값을 사용하는 것이 좋습니다.\nSampleMecanumDrive - 하드웨어 ID SampleMecanumDrive.java 파일을 엽니다.\n/* SampleMecanumDrive.java 파일의 약 102~105번째 줄 */ leftFront = hardwareMap.get(DcMotorEx.class, \u0026#34;leftFront\u0026#34;); leftRear = hardwareMap.get(DcMotorEx.class, \u0026#34;leftRear\u0026#34;); rightRear = hardwareMap.get(DcMotorEx.class, \u0026#34;rightRear\u0026#34;); rightFront = hardwareMap.get(DcMotorEx.class, \u0026#34;rightFront\u0026#34;);\r모터 ID가 Rev Hub 설정에서의 ID와 일치하는지 확인하세요.\nIMU 방향 설정 드라이브 엔코더 로컬라이제이션을 사용 중이라면, DriveConstants.java 파일에서 RevHubOrientationOnRobot을 찾아 설정하거나, 존재하지 않는다면 아래 코드와 같이 추가하세요.\n자세한 설정 방법은 FTC 문서를 참조하세요.\nControl Hub 방향 예제\r/* DriveConstants.java 파일의 약 76번째 줄 */ public static RevHubOrientationOnRobot.LogoFacingDirection LOGO_FACING_DIR = RevHubOrientationOnRobot.LogoFacingDirection.UP; public static RevHubOrientationOnRobot.UsbFacingDirection USB_FACING_DIR = RevHubOrientationOnRobot.UsbFacingDirection.FORWARD;\rIMU 속도 설정 드라이브 엔코더 로컬라이제이션이나 두 개의 데드 휠을 사용하는 경우, SampleMecanumDrive.java 파일의 맨 아래에서 getExternalHeadingVelocity 함수를 찾으세요.\n이 함수가 IMU가 로봇의 축을 따라 회전하는 축(예: z 축)에 대해 올바른 값을 반환하는지 확인하세요.\nREV Hub가 평평하게 장착된 경우 로봇은 z축을 따라 회전하며, 다른 방향으로 장착된 경우 x 또는 y 축을 따라 회전할 수 있습니다.\n/* SampleMecanumDrive.java 파일의 약 296~299번째 줄 */ @Override public Double getExternalHeadingVelocity() { return (double) imu.getRobotAngularVelocity(AngleUnit.RADIANS).zRotationRate; }\rControl Hub 축 다이어그램\r모터 방향 설정 SampleMecanumDrive.java 파일의 약 125~127번째 줄로 이동합니다. \u0026ldquo;// TODO: reverse any motors using DcMotor.setDirection()\u0026ldquo;라는 주석을 찾으세요.\n그 아래에 로봇의 한쪽 모터 방향을 반대로 설정하세요.\n테스트 중 로봇이 원을 그리며 움직이거나, 방향이 반대이거나, 경로를 제대로 따르지 않는다면 여기로 돌아와 문제를 수정하세요.\n/* SampleMecanumDrive.java 파일의 약 125~127번째 줄 */ // TODO: reverse any motors using DcMotor.setDirection() rightFront.setDirection(DcMotorSimple.Direction.REVERSE); // 필요 시 추가 rightRear.setDirection(DcMotorSimple.Direction.REVERSE); // 필요 시 추가\r모터 설정 문제를 해결하려면 Motor Direction Debugger opmode를 참조하세요.\n@Disabled 주석을 제거하고, opmode의 지침을 따르세요.\n또한, 아래의 goBILDA 메카넘 휠 방향 차트를 참고하여 문제를 진단하고 적절히 수정하세요.\ngoBILDA 메카넘 휠 방향 차트\r","date":"2023-09-07","id":5,"permalink":"/docs/4-tuning/%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B8%8C-%EC%83%81%EC%88%98-%EC%84%A4%EC%A0%95-drive-constant/","summary":"\u003cdiv class=\"callout callout-tip d-flex flex-row mt-4 mb-4 pt-4 pe-4 pb-2 ps-3\"\u003e\r\n  \u003csvg\n  xmlns=\"http://www.w3.org/2000/svg\"\n  width=\"24\"\n  height=\"24\"\n  viewBox=\"0 0 24 24\"\n  fill=\"none\"\n  stroke=\"currentColor\"\n  stroke-width=\"2\"\n  stroke-linecap=\"round\"\n  stroke-linejoin=\"round\"\n \n class=\"outline/rocket svg-inline callout-icon me-2 mb-3\" id=\"svg-rocket\" role=\"img\"\u003e\n  \u003cpath stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"/\u003e\n  \u003cpath d=\"M4 13a8 8 0 0 1 7 7a6 6 0 0 0 3 -5a9 9 0 0 0 6 -8a3 3 0 0 0 -3 -3a9 9 0 0 0 -8 6a6 6 0 0 0 -5 3\" /\u003e\n  \u003cpath d=\"M7 14a6 6 0 0 0 -3 6a6 6 0 0 0 6 -3\" /\u003e\n  \u003cpath d=\"M15 9m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0\" /\u003e\n\u003c/svg\u003e\r\n  \u003cdiv class=\"callout-content\"\u003e\r\n    \u003cdiv class=\"callout-title\"\u003e\r\n        \u003cp\u003e팁\u003c/p\u003e","tags":[],"title":"드라이브 상수 설정 (Drive Constant)"},{"content":"\r경고\n데드 휠을 사용하지 않는 경우, 이 섹션은 건너뛰세요.\n현재 단계는 드라이브 상수 설정 단계입니다.\n구성은 데드 휠이 2개인지 3개인지에 따라 달라집니다. 차이를 모르겠다면 FAQ를 참고하세요.\n두 개의 데드 휠을 사용하는 경우, Two-Wheel Odometry 섹션만 읽으세요. 세 개의 데드 휠을 사용하는 경우, Three-Wheel Odometry 섹션만 읽으세요. 오도메트리를 2개 사용하는 경우 (Two-Wheel Odometry) 두 휠 구성을 사용하는 경우, 방향(heading) 소스로 자이로스코프를 사용합니다. 기본적으로 REV Hub의 내장 BNO055 자이로스코프가 사용됩니다.\n다른 자이로스코프를 사용하려면, SampleMecanumDrive.java 파일에서 선언하고 getRawExternalHeading() 함수를 오버라이드하세요.\n이 파일을 다운로드한 후, TeamCode 폴더에 저장하세요. 파일 정리를 위해 StandardTrackingWheelLocalizer.java 파일 근처에 저장하는 것을 추천합니다.\n다운로드한 TwoWheelTrackingLocalizer.java 파일을 열어 수정하세요.\n회전당 틱 수 (TPR) / 바퀴 반지름 / 기어비 설정 /* TwoWheelTrackingLocalizer.java 파일의 37-39번째 줄 */ public static double TICKS_PER_REV = 0; public static double WHEEL_RADIUS = 2; // 인치 단위 public static double GEAR_RATIO = 1; // 출력(바퀴 속도) / 입력(엔코더 속도)\rTICKS_PER_REV: 엔코더가 한 바퀴 회전할 때 계산하는 \u0026ldquo;틱\u0026rdquo; 수입니다. 엔코더 사양은 제조사 웹사이트에서 확인하세요. Counts Per Revolution 또는 CPR 항목을 참고하세요. REV Through Bore Encoder의 경우 TICKS_PER_REV 값은 8192입니다. WHEEL_RADIUS: 데드 바퀴의 반지름입니다. 지름이 아닌 반지름 값을 입력하세요. GEAR_RATIO: 출력(바퀴 속도)과 입력(엔코더 속도)의 비율입니다. 엔코더에 기어비를 설정하지 않았다면 1로 설정하세요. 수직/수평 X/Y 설정 /* TwoWheelTrackingLocalizer.java 파일의 41-45번째 줄 */ public static double PARALLEL_X = 0; // 수평 X, X는 전후 방향 public static double PARALLEL_Y = 0; // 수평 Y, Y는 좌우 방향 public static double PERPENDICULAR_X = 0; // 수직 X, X는 전후 방향 public static double PERPENDICULAR_Y = 0; // 수직 Y, Y는 좌우 방향\r수직 및 수평 바퀴의 X/Y 좌표를 입력하세요. X축은 전후 방향, Y축은 좌우 방향입니다. 이는 로봇 공학 및 항공 분야에서 일반적인 표준입니다.\n17508 Rising Tau의 2019/20 Skystone 로봇\r엔코더 방향 설정 경우에 따라 Encoder.setDirection(Encoder.Direction.REVERSE)를 사용해 엔코더의 방향을 반전시켜야 합니다.\n예시:\n/* TwoWheelTrackingLocalizer.java 파일의 60-63줄 */ parallelEncoder = new Encoder(hardwareMap.get(DcMotorEx.class, \u0026#34;parallelEncoder\u0026#34;)); perpendicularEncoder = new Encoder(hardwareMap.get(DcMotorEx.class, \u0026#34;perpendicularEncoder\u0026#34;)); // TODO: Encoder.setDirection(Encoder.Direction.REVERSE)로 엔코더를 반대로 설정하세요. // 예시) 수직 엔코더의 방향을 반대로 설정해야 하는 경우: perpendicularEncoder.setDirection(Encoder.Direction.REVERSE);\r경고\nRev Through Bore 엔코더를 사용하는 경우 아래 내용을 반드시 참조하세요.\nRev Through Bore 엔코더 주의사항\nREV Through Bore 엔코더를 사용하는 경우, 속도가 32767 cps (counts per second)를 초과하면 정수 오버플로우가 발생할 수 있습니다. 이는 REV Hub 펌웨어가 속도 데이터를 16비트 정수로 전송하기 때문입니다. 이를 해결하려면 getRawVelocity() 대신 getCorrectedVelocity()를 사용하세요.\n/* TwoWheelTrackingLocalizer.java 파일의 86-95줄 */ public List\u0026lt;Double\u0026gt; getWheelVelocities() { //TODO : 인코더 속도가 초당 32767 카운트를 초과할 경우, Encoder.getRawVelocity()를 Encoder.getCorrectedVelocity()로 변경하여 보정 메서드를 활성화하세요. return Arrays.asList( encoderTicksToInches(parallelEncoder.getCorrectedVelocity()), encoderTicksToInches(perpendicularEncoder.getCorrectedVelocity()) ); }\r하드웨어 ID 확인 /* TwoWheelTrackingLocalizer.java 파일의 60-61줄 */ parallelEncoder = new Encoder(hardwareMap.get(DcMotorEx.class, \u0026#34;parallelEncoder\u0026#34;)); perpendicularEncoder = new Encoder(hardwareMap.get(DcMotorEx.class, \u0026#34;perpendicularEncoder\u0026#34;));\r여기서 사용한 ID가 REV Hub 설정의 ID와 일치하는지 확인하세요.\nIMU 설정 /* SampleMecanumDrive.java 파일의 134-137줄 */ imu = hardwareMap.get(BNO055IMU.class, \u0026#34;imu\u0026#34;); BNO055IMU.Parameters parameters = new BNO055IMU.Parameters(); parameters.angleUnit = BNO055IMU.AngleUnit.RADIANS; imu.initialize(parameters);\rIMU가 SampleMecanumDrive.java 클래스에서 초기화되어 있는지 확인하세요. Quickstart를 다운로드했으며 REV Hub IMU를 사용 중이라면 변경할 필요가 없습니다. 외부 자이로를 사용하는 경우, 이 섹션을 수정하세요.\nIMU 속도 축 설정 SampleMecanumDrive.java 파일 하단의 getExternalHeadingVelocity 함수에서 함수가 IMU가 회전하는 축을 구성에 맞게 반환하는지 확인하세요. 파일에 제공된 ASCII 다이어그램을 참조하여 어떤 축을 선택해야 하는지 확인할 수 있습니다. REV Hub가 평평하게 장착되어 있으면 로봇은 Z축을 중심으로 회전합니다. 모터 포트가 위 또는 아래를 향하고 있는 쪽에 있으면 로봇은 Y축을 중심으로 회전합니다. 서보 포트가 위 또는 아래를 향하고 있으면 로봇이 X축을 중심으로 회전합니다.\n/* SampleMecanumDrive.java 파일의 399-419줄 */ @Override public Double getExternalHeadingVelocity() { // TODO: 설정에 맞게 이 값을 변경해야 합니다 // | Z 축 // | // (모터 포트 측면) | / X 축 // ____|__/____ // Y 축 / * | / /| (IO 측면) // _________ /______|/ // I2C // /___________ // 디지털 // |____________|/ 아날로그 // // (서보 포트 측면) // // 양의 X 축은 USB 포트가 있는 방향을 가리킵니다. // // 축 회전 속도를 필요에 따라 조정하세요. // REV Hub/Control Hub가 평평한 표면에 놓여 있다고 가정하면 // 기본 설정은 Z 축을 기준으로 회전합니다. return (double) imu.getAngularVelocity().zRotationRate; }\rSampleMecanumDrive에서 로컬라이저(Localizer) 설정하기 로컬라이저 구성을 완료한 후, 다시 SampleMecanumDrive.java 파일로 돌아갑니다.\n약 168번째 줄을 확인하세요. \u0026ldquo;// TODO: if desired, use setLocalizer() to change the localization method\u0026ldquo;라는 주석을 찾을 수 있을 것입니다.\n이 주석 아래에 다음 줄을 추가하세요:\n/* 약 168번째 줄 - SampleMecanumDrive.java */ // TODO: if desired, use setLocalizer() to change the localization method // for instance, setLocalizer(new ThreeTrackingWheelLocalizer(...)); setLocalizer(new TwoWheelTrackingLocalizer(hardwareMap, this));\r이렇게 로컬라이저을 완료할 수 있습니다.\n오도메트리를 3개 사용하는 경우 (Three-Wheel Odometry) 세 바퀴 오도메트리 설정을 선택한 경우, 헤딩(heading)의 소스로 두 개의 평행 바퀴를 사용하게 됩니다.\nStandardTrackingWheelLocalizer.java 파일을 엽니다.\n회전당 틱 수 (TPR) / 바퀴 반지름 / 기어비 설정 /* StandardTrackingWheelLocalizer.java - 30~32번째 줄 */ public static double TICKS_PER_REV = 0; public static double WHEEL_RADIUS = 2; // 인치 단위 public static double GEAR_RATIO = 1; // 출력(바퀴) 속도 / 입력(엔코더) 속도\rTICKS_PER_REV: 인코더가 한 바퀴 회전 시 카운트하는 \u0026ldquo;틱(tick)\u0026ldquo;의 개수입니다. 인코더 사양은 제조사의 사이트에서 확인할 수 있습니다. Counts Per Revolution(CPR) 값을 찾으세요. 예를 들어, REV Through Bore Encoder의 경우 TICKS_PER_REV는 8192입니다. WHEEL_RADIUS: 데드 휠의 반지름입니다. 반드시 반지름(radius)을 사용하고 직경(diameter)을 사용하지 않도록 주의하세요. GEAR_RATIO: 출력(바퀴) 속도와 입력(엔코더) 속도의 비율입니다. 엔코더에 기어를 사용하지 않는 경우 1로 유지하세요. 측면 거리 (Lateral Distance)와 전방 오프셋 (Forward Offset) 설정 /* StandardTrackingWheelLocalizer.java - 34~35번째 줄 */ public static double LATERAL_DISTANCE = 10; // 인치 단위, 좌우 바퀴 간 거리 public static double FORWARD_OFFSET = 4; // 인치 단위, 중심 축에서 전면 바퀴까지의 오프셋 거리\rLATERAL_DISTANCE: 좌우 바퀴 간의 거리입니다. FORWARD_OFFSET: 회전 중심에서 중앙 휠까지의 거리입니다. 중앙 휠이 바퀴보다 앞에 있다면 양수, 뒤에 있다면 음수 값을 사용합니다. 17508 Rising Tau의 2019/20 Skystone 로봇\r엔코더 방향 설정 경우에 따라 Encoder.setDirection(Encoder.Direction.REVERSE)를 사용해 엔코더의 방향을 반전시켜야 합니다.\n예시:\n/* StandardTrackingWheelLocalizer.java - 46~63번째 줄 */ leftEncoder = new Encoder(hardwareMap.get(DcMotorEx.class, \u0026#34;leftEncoder\u0026#34;)); rightEncoder = new Encoder(hardwareMap.get(DcMotorEx.class, \u0026#34;rightEncoder\u0026#34;)); frontEncoder = new Encoder(hardwareMap.get(DcMotorEx.class, \u0026#34;frontEncoder\u0026#34;)); // TODO: 인코더 방향을 바꿀 때는 \u0026#34;Encoder.setDirection(Encoder.Direction.REVERSE)\u0026#34;를 사용. // 예시) 중앙 인코더를 반전시켜야 할 경우: frontEncoder.setDirection(Encoder.Direction.REVERSE);\r이 코드를 통해 엔코더의 방향을 올바르게 설정할 수 있습니다.\n경고\nRev Through Bore 엔코더를 사용하는 경우 아래 내용을 반드시 참조하세요.\nRev Through Bore 엔코더 주의사항\nREV Through Bore 엔코더를 사용하는 경우, 속도가 32767 cps (counts per second)를 초과하면 정수 오버플로우가 발생할 수 있습니다. 이는 REV Hub 펌웨어가 속도 데이터를 16비트 정수로 전송하기 때문입니다. 이를 해결하려면 getRawVelocity() 대신 getCorrectedVelocity()를 사용하세요.\n/* TwoWheelTrackingLocalizer.java 파일의 86-95줄 */ public List\u0026lt;Double\u0026gt; getWheelVelocities() { //TODO : 인코더 속도가 초당 32767 카운트를 초과할 경우, Encoder.getRawVelocity()를 Encoder.getCorrectedVelocity()로 변경하여 보정 메서드를 활성화하세요. return Arrays.asList( encoderTicksToInches(parallelEncoder.getCorrectedVelocity()), encoderTicksToInches(perpendicularEncoder.getCorrectedVelocity()) ); }\rSampleMecanumDrive에서 로컬라이저(Localizer) 설정하기 로컬라이저 구성을 완료했다면, SampleMecanumDrive.java 파일로 돌아갑니다.\n대략 131번째 줄에서 \u0026ldquo;// TODO: if desired, use setLocalizer() to change the localization method\u0026ldquo;라는 주석을 찾을 수 있을 겁니다.\n이 주석 아래에 다음 줄을 추가하세요:\n/* 약 131번째 줄 - SampleMecanumDrive.java */ // TODO: if desired, use setLocalizer() to change the localization method // for instance, setLocalizer(new ThreeTrackingWheelLocalizer(...)); setLocalizer(new StandardTrackingWheelLocalizer(hardwareMap));\r이렇게 로컬라이저 설정을 완료할 수 있습니다.\nIMU 제거 세 바퀴 오도메트리(Three-Wheel Odometry) 방식에서는 IMU가 필요하지 않습니다. 따라서 SampleMecanumDrive에서 IMU 초기화를 제거하는 것이 좋습니다. IMU 초기화는 운영 모드(opmode) 초기화 시간을 2~3초 늘릴 수 있으며, 불필요한 시간이 소요될 수 있습니다.\nSampleMecanumDrive.java 파일에서 다음 코드를 찾아 삭제하세요:\n/* 약 134~137번째 줄 - SampleMecanumDrive.java */ // TODO: adjust the names of the following hardware devices to match your configuration imu = hardwareMap.get(BNO055IMU.class, \u0026#34;imu\u0026#34;); BNO055IMU.Parameters parameters = new BNO055IMU.Parameters(); parameters.angleUnit = BNO055IMU.AngleUnit.RADIANS; imu.initialize(parameters);\r그리고 안전을 위해, 아래 메서드들의 반환값을 0으로 변경하세요:\n/* 약 393~396번째 줄 - SampleMecanumDrive.java */ @Override public double getRawExternalHeading() { return 0; } @Override public Double getExternalHeadingVelocity() { return 0.0; }\r조율 (Tuning) - 오도메트리 두 개를 사용하는 경우 (Two-Wheel Odometry) 데드 휠(Dead Wheel)을 사용한 오도메트리의 튜닝은 매우 중요한 과정입니다. 이 과정은 Road Runner뿐만 아니라 FTCLib 또는 직접 개발한 경로 추적 시스템에서도 중요한 역할을 합니다. 이것의 목표는 로컬라이제이션(Localization)의 정확도를 최대화하는 것입니다.\n바퀴 반지름 조정 팁\n이 과정이 모든 사용자에게 필수는 아니지만, 적용하면 약 1% 더 정확한 위치 추적이 가능합니다. 예를 들어, 100인치 이동 시 1% 오차는 1인치 차이를 줄이는 데 도움이 됩니다. FTC Skystone 시즌(2019-2020) 동안, 4~5개의 돌을 옮기는 자율 주행 루틴은 100인치 이상을 이동하며, 이런 차이가 큰 영향을 미칠 수 있었습니다.\n노트\n아래의 과정이 적용된 전체 코드는 예제 코드를 참고하세요.\nTwoWheelTrackingLocalizer.java 파일을 엽니다. 클래스 내부에 두 개의 변수를 추가하세요: /* 약 46~47번째 줄 - TwoWheelTrackingLocalizer.java */ public static double X_MULTIPLIER = 1; // X 방향 보정 계수 public static double Y_MULTIPLIER = 1; // Y 방향 보정 계수\r다음과 같이 getWheelPositions()와 getWheelVelocities() 함수에 보정 계수를 추가합니다: /* 약 77~97번째 줄 - TwoWheelTrackingLocalizer.java */ @NonNull @Override public List\u0026lt;Double\u0026gt; getWheelPositions() { return Arrays.asList( encoderTicksToInches(parallelEncoder.getCurrentPosition()) * X_MULTIPLIER, encoderTicksToInches(perpendicularEncoder.getCurrentPosition()) * Y_MULTIPLIER ); } @NonNull @Override public List\u0026lt;Double\u0026gt; getWheelVelocities() { // TODO: 인코더 속도가 초당 32767 카운트를 초과할 경우, Encoder.getRawVelocity()를 // Encoder.getCorrectedVelocity()로 변경하여 보정 메서드를 활성화하세요. return Arrays.asList( encoderTicksToInches(parallelEncoder.getRawVelocity()) * X_MULTIPLIER, encoderTicksToInches(perpendicularEncoder.getRawVelocity()) * Y_MULTIPLIER ); }\r참고: X_MULTIPLIER는 수평 엔코더에 작용하는 값입니다. 왜냐하면 x는 로컬 좌표계를 향해 있기 때문입니다 (로봇 공학/항공/등 상황에서 흔히 사용됩니다).\n물리적인 튜닝 과정을 진행합니다: 로봇이 이동할 수 있는 직선 구간을 준비합니다. 경기장 타일을 직선 형태로 배치하면 좋습니다. 로봇을 시작 지점에 두고 앞으로 직진하게 설정합니다. LocalizationTest opmode를 실행합니다. 단, 컨트롤러는 사용하면 안 됩니다. 손으로 로봇을 직선 구간을 따라 천천히 이동시킵니다. 가능한 똑바로 이동하도록 노력하세요. (로봇 옆에 테이프를 붙이고, 테이프와의 간격을 유지하면서 이동시키면 좋습니다.) 이동이 끝나면 멈춘 후, 실제 이동한 거리와 텔레메트리(Telemetry)에 기록된 이동 거리를 확인하세요. X 방향 보정 계수 계산: X_MULTIPLIER = 실제 이동 거리 / 텔레메트리 이동 거리\n예: 텔레메트리가 89인치를 표시하고 실제로 90인치를 이동했다면, X_MULTIPLIER는 1.01123596입니다. 동일한 과정을 통해 Y 방향(스트레이프) 보정 계수도 계산하고 설정합니다. 재확인 LocalizationTest opmode를 실행합니다. 로봇의 RC에서 192.168.49.1:8080/dash 또는 Control Hub에서 192.168.43.1:8080/dash로 접속합니다. 컨트롤러로 로봇을 이동시키면서 대시보드 상에서 로봇의 움직임이 실제 움직임과 일치하는지 확인합니다. X 좌표는 앞으로 이동 시 증가해야 하며, Y 좌표는 왼쪽으로 이동 시 증가해야 합니다. 문제가 발생하면 문제 해결(Troubleshooting) 섹션을 참고하세요.\n조율 (Tuning) - 오도메트리 세 개를 사용하는 경우 (Three-Wheel Odometry) 데드 휠의 조율은 매우 중요합니다. 이는 Road Runner뿐만 아니라 FTCLib 또는 직접 제작한 경로 추적 시스템에도 적용됩니다. 정확한 조율은 위치 및 거리 측정에서 발생하는 오류를 최소화하여 자율 주행 시 성능을 크게 향상시킬 수 있습니다.\n바퀴 반지름 조정 팁\n이 단계는 선택 사항이지만 로컬라이제이션 정확도를 약 1% 정도 향상시킬 수 있습니다. 1%가 별것 아닌 것처럼 보일 수 있지만, 100인치 이상의 주행 시 약 1인치 차이를 만들 수 있습니다. 예를 들어 FTC Skystone(2019-2020) 시즌에서 4~5개의 스톤을 운반하는 자율 주행은 100인치 이상 이동해야 했으며, 1인치의 추가 정확도가 큰 차이를 만들었을 수 있습니다.\n노트\n아래의 과정이 적용된 전체 코드는 예제 코드를 참고하세요.\nStandardTrackingWheelLocalizer.java 파일 열기\n해당 파일에서 아래 두 변수를 클래스에 선언합니다:\n/* StandardTrackingWheelLocalizer.java 파일의 약 37~38줄 */ public static double X_MULTIPLIER = 1; // X 방향 보정 계수 public static double Y_MULTIPLIER = 1; // Y 방향 보정 계수\r보정 계수를 getWheelPositions() 및 getWheelVelocities() 함수에 추가\n아래와 같이 코드를 수정합니다:\n/* StandardTrackingWheelLocalizer.java 파일 약 67~103줄 */ @NonNull @Override public List\u0026lt;Double\u0026gt; getWheelPositions() { return Arrays.asList( encoderTicksToInches(leftEncoder.getCurrentPosition()) * X_MULTIPLIER, encoderTicksToInches(rightEncoder.getCurrentPosition()) * X_MULTIPLIER, encoderTicksToInches(frontEncoder.getCurrentPosition()) * Y_MULTIPLIER ); } @NonNull @Override public List\u0026lt;Double\u0026gt; getWheelVelocities() { return Arrays.asList( encoderTicksToInches(leftEncoder.getCorrectedVelocity()) * X_MULTIPLIER, encoderTicksToInches(rightEncoder.getCorrectedVelocity()) * X_MULTIPLIER, encoderTicksToInches(frontEncoder.getCorrectedVelocity()) * Y_MULTIPLIER ); }\r참고: X 방향 보정 계수는 X 좌표가 로컬 좌표계에서 앞쪽으로 향하기 때문에 leftEncoder와rightEncoder에 적용됩니다.\n물리적인 튜닝 과정을 진행합니다:\n로봇이 이동할 수 있는 직선 구간을 준비합니다. 경기장 타일을 직선 형태로 배치하면 좋습니다. 로봇을 시작 지점에 두고 앞으로 직진하게 설정합니다. LocalizationTest opmode를 실행합니다. 단, 컨트롤러는 사용하면 안 됩니다. 손으로 로봇을 직선 구간을 따라 천천히 이동시킵니다. 가능한 똑바로 이동하도록 노력하세요. (로봇 옆에 테이프를 붙이고, 테이프와의 간격을 유지하면서 이동시키면 좋습니다.) 이동이 끝나면 멈춘 후, 실제 이동한 거리와 텔레메트리(Telemetry)에 기록된 이동 거리를 확인하세요. 보정 계수를 계산합니다. 보정 계수는 실제 이동 거리 / 텔레메트리 이동 거리로 계산됩니다.\n예를 들어 텔레메트리가 89인치를 표시하고 실제 측정값이 90인치라면, 보정 계수는 1.01123596이 됩니다.\n이 과정을 X방향(앞으로 이동)으로 3번 반복해 평균값을 구한 후 X_MULTIPLIER에 설정합니다.\nY방향(옆으로 이동)에서도 동일한 과정을 반복한 후, 계산된 Y 방향 계수를 Y_MULTIPLIER에 설정합니다.\n측면 거리 (Lateral Distance) 조율 측면 거리는 로컬라이제이션에서 방향 계산에 중요한 요소입니다. 이 값을 잘못 설정하면 방향 오차가 누적되어 로컬라이제이션 성능이 크게 저하됩니다.\nStandardTrackingWheelLocalizer.java 파일의 LATERAL_DISTANCE 값 확인을 확인합니다.\n해당 값을 실제 측정한 거리로 설정합니다. 이후 튜닝 과정에서 조율될 예정이니 정확하지 않더라도 괜찮습니다.\n로봇의 특정 지점(테이프 표시 등)을 기준으로 360° 회전 전후의 위치를 확인할 수 있도록 준비합니다.\nTrackingWheelLateralDistanceTuner OpMode를 실행합니다.\n대시보드를 사용하면 로봇의 상태를 시각적으로 확인할 수 있습니다. RC의 WiFi에 연결한 뒤, 브라우저에서 192.168.49.1:8080/dash (RC 전화 사용 시) 또는 192.168.43.1:8080/dash (Control Hub 사용 시)로 접속하세요.\nOpMode를 실행한 후 게임패드의 오른쪽 조이스틱을 사용해 로봇을 반시계 방향으로 회전시킵니다.\n로봇을 10회 반시계 방향으로 회전시키고 완료되면 게임패드의 Y 버튼을 눌러 튜닝을 종료합니다. 이후 시작 지점과 동일하게 정렬되었는지 확인합니다.\n출력된 LATERAL_DISTANCE 값을 StandardTrackingWheelLocalizer.java에 입력합니다.\n만약 값이 부정확하다면 직접 조정하면서 반복 테스트합니다.\n문제 해결 (Troubleshooting) 대시보드와 로봇 움직임 불일치 문제 해결: 대시보드에서 로봇이 실제와 반대로 옆으로 이동할 경우 수직 인코더의 방향을 반대로 설정하세요. 대시보드에서 로봇이 제자리에서 올바르게 회전하지 않을 경우 수직 휠의 위치가 잘못되어 회전 중심에 오프셋이 생긴 것입니다.\n수직 휠의 위치 조정은 복잡할 수 있으니, 약간의 오프셋은 그대로 두어도 괜찮습니다.\n이로 인해 로컬라이제이션 정확도는 영향을 받지 않으며, 단지 위치가 약간 이동하는 것뿐입니다. 대시보드에서 로봇이 직진하는 동안 회전할 경우 수평 엔코더 중 하나가 반대로 설정되어 있는 것입니다. 대시보드에서 로봇이 직진 및 스트레이프는 제대로 하지만, 회전 방향이 실제와 반대일 경우 좌측 및 우측 인코더가 서로 바뀌어 연결되어 있는 것입니다. 시간이 지남에 따라 로컬라이제이션 정확도가 떨어질 경우 로봇을 천천히 움직이며 테스트하세요. 가속을 최소화하려고 노력합니다. 느린 속도에서도 로컬라이제이션이 부정확하다면, 설정 값을 다시 확인하세요.\n헤딩(방향)이 정확한지 확인하고, 스트레이프 및 전진 움직임에서 측정된 거리와 실제 이동 거리가 일치하는지 확인하세요. 만약 느린 속도에서는 정확하지만, 빠른 속도에서 정확도가 떨어진다면 이는 하드웨어 문제일 가능성이 높습니다. 가장 흔한 원인은 데드 휠의 마찰력이 부족한 경우입니다. 데드 휠의 스프링 압력을 증가시켜 마찰력을 높이세요. ","date":"2023-09-07","id":6,"permalink":"/docs/4-tuning/%EB%8D%B0%EB%93%9C-%ED%9C%A0-%EC%84%A4%EC%A0%95-dead-wheels/","summary":"\u003cdiv class=\"callout callout-danger d-flex flex-row mt-4 mb-4 pt-4 pe-4 pb-2 ps-3\"\u003e\r\n  \u003csvg\n  xmlns=\"http://www.w3.org/2000/svg\"\n  width=\"24\"\n  height=\"24\"\n  viewBox=\"0 0 24 24\"\n  fill=\"none\"\n  stroke=\"currentColor\"\n  stroke-width=\"2\"\n  stroke-linecap=\"round\"\n  stroke-linejoin=\"round\"\n \n class=\"outline/alert-octagon svg-inline callout-icon me-2 mb-3\" id=\"svg-alert-octagon\" role=\"img\"\u003e\n  \u003cpath stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"/\u003e\n  \u003cpath d=\"M12.802 2.165l5.575 2.389c.48 .206 .863 .589 1.07 1.07l2.388 5.574c.22 .512 .22 1.092 0 1.604l-2.389 5.575c-.206 .48 -.589 .863 -1.07 1.07l-5.574 2.388c-.512 .22 -1.092 .22 -1.604 0l-5.575 -2.389a2.036 2.036 0 0 1 -1.07 -1.07l-2.388 -5.574a2.036 2.036 0 0 1 0 -1.604l2.389 -5.575c.206 -.48 .589 -.863 1.07 -1.07l5.574 -2.388a2.036 2.036 0 0 1 1.604 0z\" /\u003e\n  \u003cpath d=\"M12 8v4\" /\u003e\n  \u003cpath d=\"M12 16h.01\" /\u003e\n\u003c/svg\u003e\r\n  \u003cdiv class=\"callout-content\"\u003e\r\n    \u003cdiv class=\"callout-title\"\u003e\r\n        \u003cp\u003e경고\u003c/p\u003e","tags":[],"title":"데드 휠 설정 (Dead Wheels)"},{"content":"\r현재 단계는 주행 피드포워드 조율 단계입니다.\n피드포워드 컨트롤러를 정확히 튜닝하는 것은 경로를 따라 정확히 이동하기 위해 필수적입니다. 피드포워드 컨트롤러의 튜닝이 부정확하면 이후 과정에서 오류가 발생할 수 있습니다. Roadrunner Quickstart에는 자동 튜너와 수동 튜너가 포함되어 있지만, 많은 사용자가 자동 튜너가 최적의 결과를 제공하지 않는다고 느낍니다. 특히 자동 튜너는 kA 값을 제대로 계산하지 못할 가능성이 큽니다. 하지만 자동 튜너를 실행해 보고 얻은 수치를 사용하는 것은 개인의 자유이며, 수동으로 값을 얻고자 할지라도, 자동 튜너로 수치를 얻고, 이후 수동으로 값을 조정하는 것을 추천합니다.\n팁\nXbox 및 Logitech 게임패드에서 X 버튼을, PS4 듀얼쇼크에서 □ 버튼을 눌러 튜닝 프로세스를 일시 중지하고 운전자 제어 모드로 전환할 수 있습니다. Xbox 및 Logitech 게임패드에서 A 버튼을, PS4 듀얼쇼크에서 X 버튼을 눌러 다시 튜너에 제어권을 넘길 수 있습니다. 로봇이 경로를 벗어나면 운전자 제어 모드로 전환하여 로봇을 초기 위치로 되돌리십시오.\n조율 과정 (Tuning) 주의\n튜닝 과정에서 로봇이 천천히 경로에서 벗어나는 것은 정상입니다. 이 문제는 이후에 헤딩 및 병진 PID 튜닝 과정에서 해결될 것입니다.\nRC(Robot Controller)를 통해 ManualFeedforwardTuner OpMode를 실행합니다.\nRC의 Wi-Fi 네트워크에 연결합니다. 네트워크 비밀번호는 Program and Manage 메뉴에서 확인할 수 있습니다.\nRC로 핸드폰을 사용하는 경우 192.168.49.1:8080/dash, Control Hub의 경우 192.168.43.1:8080/dash로 이동합니다.\n페이지는 아래와 비슷하게 표시될 것입니다:\n예시 대시보드 화면\u0026lt;br\u0026gt;(그래프 내용은 무시하세요. 페이지 레이아웃 예시입니다)\rOpMode를 실행합니다. 프로그램을 시작하기 전에는 그래프가 나타나지 않습니다.\n프로그램 실행 후 그래프 버튼을 클릭하십시오. 그래프 대신 여러 체크박스가 나타날 경우, targetVelocity와 poseVelocity 체크박스를 선택하면 됩니다. 대시보드에서 오른쪽에 있는 DriveConstants 드롭다운을 찾습니다. 드롭다운을 열고, kA, kV, kStatic 변수를 찾으십시오. 곧 이 변수를 조정하게 될 것입니다.\n주의\n이 단계는 중요합니다. 속도 그래프에 안정기가 없는 경우 kV가 잘못된 것입니다. 이는 이후 정확도 문제로 이어질 수 있습니다. 안정기가 그래프에 나타나도록 거리를 늘리십시오.\nManualFeedforwardTuner 드롭다운에서 DISTANCE 변수가 충분히 커서 targetVelocity 라인이 안정기를 가질 수 있도록 설정하십시오. 그래프가 삼각형 모양처럼 보일 경우, DISTANCE 값을 늘리십시오. 팁\n거리가 충분하지 않은 경우, Drive Constants에서 `MAX_ACCEL` 값을 늘리거나 `MAX_VEL` 값을 줄일 수 있습니다. 단, 이는 궤적의 속도/가속도에 영향을 미칠 수 있으므로 주의하십시오.\rOpMode를 실행하면 로봇이 지정된 거리만큼 앞뒤로 이동할 것입니다. 목표는 poseVelocity 라인이 targetVelocity 라인과 일치하도록 하는 것입니다.\n추천 튜닝 과정:\nkV를 초기 값으로 1 / 최대 속도로 설정하십시오. poseVelocity 라인이 targetVelocity 안정기 그래프의 상단에 닿아야 합니다. 그렇지 않으면 kV를 늘리십시오.\nkA를 증가시켜 poseVelocity 라인의 기울기가 targetVelocity와 일치하도록 조정하십시오.\n아래의 참고 자료를 확인하여 각 게인의 역할을 시각적으로 이해하십시오.\n튜닝 팁\r참고 자료는 FRC 팀 1712의 Adaptive Pure Pursuit 논문에서 발췌되었습니다.\n이제 끝입니다! 적절히 튜닝된 피드포워드 컨트롤러의 예시는 아래를 참조하십시오.\n대시보드에서 조정한 값은 반드시 DriveConstants.java 파일의 해당 변수에 복사해야 합니다. 대시보드에서의 조정은 임시적이며, OpMode를 다시 시작하면 초기화됩니다.\n튜닝 시뮬레이터를 사용하여 각 수치가 동작에 미치는 영향을 확인하십시오.\n주의: 그래프가 완벽할 필요는 없습니다. \u0026ldquo;충분히 괜찮은\u0026rdquo; 상태로 두십시오. 그래프를 완벽하게 만드는 데 무한한 시간을 소비할 수 있습니다. 또한, Rev Hub의 내부 모터 컨트롤러 특성상 감속 시 약간의 범프가 발생하며, 이를 제거하는 것은 불가능합니다.\n튜닝된 피드포워드 컨트롤러의 예시 (팀 14320의 Deetz 제공):\n튜닝된 피드포워드 컨트롤러\r감속 시의 비대칭성이 보일 수 있습니다. 기본 모터 컨트롤 모델로는 완벽한 속도 제어를 달성할 수 없습니다. 감속 시 속도가 잘 추적되지 않는 것은 Rev Hub 모터 컨트롤러의 특성 때문일 가능성이 높습니다. 자세한 내용이나 이 문제에 대한 해결책이 있는 경우 FTC Discord에서 공유해 주세요.\n팁\nREV Hub의 출력 전압은 배터리 레벨이 떨어지면서 감소합니다. 따라서 피드포워드가 여러 경기에서 일관성을 보장하지 못할 수 있습니다. Road Runner에는 명시적인 포즈 속도 폐쇄 루프 제어가 없습니다. 이를 보완하려면 병진 PID 컨트롤러의 kD 항을 추가하세요. 자세한 내용은 팔로워 PID 페이지에서 확인할 수 있습니다.\n주의\nREV Hub의 모터 컨트롤러는 감속을 제대로 처리하지 못합니다. 이로 인해 감속 단계에서 피드포워드를 정확히 튜닝하는 것이 불가능합니다. 이는 매번 10% 정도의 오버슈트를 초래할 수 있으며, 이는 충분히 예상된 결과입니다. 따라서 이 문제를 무시하고 다음 단계로 진행하십시오. 이 문제는 팔로워 PID 조율 과정에서 해결될 것입니다.\n문제 해결 (Troubleshooting) MaxVelocityTuner가 역방향으로 움직이는 경우:\n바퀴 방향이 올바른지 확인하십시오. goBILDA 메카넘 차트를 참고하세요. poseVelocity가 반대로 움직이거나 targetVelocity를 따르지 않는 경우:\n로컬라이제이션에 문제가 있을 수 있습니다. LocalizationTest를 실행해 실제 위치와 일치하는지 확인하십시오. StraightTest 또는 ManualFeedforwardTuning OpMode가 계속 과도하게 움직이고 DriveConstants.java 값을 조정해도 변하지 않는 경우:\nDriveConstants.java에서 MAX_VEL 값을 낮춰 보십시오. 기타 모터 방향 문제:\n모터 방향 반전을 참고하십시오. 모터 구성을 디버깅하는 데 어려움을 겪고 있다면 모터 방향 디버거를 참조하세요. 모터 방향 디버거를 사용하면 모터를 하나씩 돌릴 수 있습니다. 41번 줄에서 @Disabled lin을 제거하고 opmode 주석의 지침을 따르십시오. 이를 사용하여 모터 구성 문제를 진단하고 적절하게 수정하세요. 피드포워드 조율 시뮬레이터 아래 링크로 들어가면 피드포워드 조율(Feedforward Tuning)을 시뮬레이션을 통해 연습해 볼 수 있습니다. 빠른 시일 내에 이 기능을 웹사이트의 기본 기능으로 추가하고자 합니다.\n시뮬레이션 바로가기\n","date":"2023-09-07","id":7,"permalink":"/docs/4-tuning/%EC%A3%BC%ED%96%89-%ED%94%BC%EB%93%9C%ED%8F%AC%EC%9B%8C%EB%93%9C-%EC%A1%B0%EC%9C%A8-driving-feedforward-tuner/","summary":"\u003cimg alt=\"diagram\" class=\"diagram diagram-kroki diagram-kroki-plantuml\" id=\"h-rh-cb-kroki-0\" src=\"/_10235469678620711340.svg\"\u003e\u003cp\u003e현재 단계는 \u003cstrong\u003e주행 피드포워드 조율\u003c/strong\u003e 단계입니다.\u003c/p\u003e\n\u003cp\u003e피드포워드 컨트롤러를 정확히 튜닝하는 것은 경로를 따라 정확히 이동하기 위해 필수적입니다.\n피드포워드 컨트롤러의 튜닝이 부정확하면 이후 과정에서 오류가 발생할 수 있습니다.\nRoadrunner Quickstart에는 자동 튜너와 수동 튜너가 포함되어 있지만,\n많은 사용자가 자동 튜너가 최적의 결과를 제공하지 않는다고 느낍니다.\n특히 자동 튜너는 \u003ccode\u003ekA\u003c/code\u003e 값을 제대로 계산하지 못할 가능성이 큽니다.\n하지만 자동 튜너를 실행해 보고 얻은 수치를 사용하는 것은 개인의 자유이며,\n수동으로 값을 얻고자 할지라도, 자동 튜너로 수치를 얻고, 이후 수동으로 값을 조정하는 것을 추천합니다.\u003c/p\u003e","tags":[],"title":"주행 피드포워드 조율 (Driving Feedforward Tuner)"},{"content":"\r경고\n이 페이지는 특별한 목적이 있는 경우를 제외하고는 사용하지 않는 것이 좋습니다. 주행 속도 PID 조율 (Drive Velocity PID Tuning)은 로봇에서 사용하지 않는 것을 권장합니다. 대신 Feedforward 제어를 사용하세요.\n주행 속도 PID 조율 (Drive Velocity PID Tuning)를 사용하지 않는 이유 주행 속도 PID 조율은 SDK의 내부 PID 컨트롤러를 사용하므로, 튜닝 과정이 매우 까다롭습니다. 이 방법으로도 좋은 결과를 얻을 수 있지만, Feedforward를 사용하는 것이 훨씬 더 간단하며 동일한 정확도를 얻을 수 있습니다. DriveVelocityControl은 특히 방향 및 팔로워 PID를 통합할 때 수정할 수 없는 진동을 유발할 수 있으며, 문제가 없더라도 튜닝에 더 많은 시간이 걸리는 경우가 많습니다.\nDriveVelocityPID 튜닝 경고\n이 섹션은 엔코더를 사용하지 않도록 선택한 경우 생략해야 합니다.\n현재 단계는 주행 피드포워드 조율 단계입니다.\n속도 PID 튜닝은 Road Runner에서 가장 까다로운 작업 중 하나일 수 있습니다. 이는 정확한 경로 추적을 위해 필요합니다. 하지만 PID 컨트롤러의 작동 원리에 대한 직관과 수행 방법을 이해하면 이러한 좌절감을 완화하고 과정을 더 원활하게 진행할 수 있습니다.\n팁\nXbox 및 Logitech 게임패드에서는 X 버튼을, PS4 DualShock에서는 □ 버튼을 눌러 튜닝 과정을 일시 중지하고 드라이버 제어로 전환할 수 있습니다. Xbox 및 Logitech 게임패드에서는 A 버튼을, PS4 DualShock에서는 X 버튼을 눌러 튜너에게 제어권을 다시 넘길 수 있습니다. 로봇이 경로를 벗어나면 드라이버 제어로 전환하여 로봇을 초기 위치로 되돌리세요. 조율 과정 (Tuning) 조율을 시작하기 전 RC 폰을 시작하고 Dashboard를 엽니다. RC 폰의 Wi-Fi 네트워크에 연결합니다. 네트워크 비밀번호는 Program and Manage 메뉴에서 확인할 수 있습니다. Dashboard 접속 RC 폰을 사용하는 경우, 브라우저에서 192.168.49.1:8080/dash로 이동하세요. Control Hub를 사용하는 경우, 192.168.43.1:8080/dash로 이동하세요. MaxVelocityTuner 실행 Velocity PID 튜닝을 시작하기 전에 MaxVelocityTuner를 실행해 경험적 kF 값과 최대 속도를 측정합니다. MaxVelocityTuner는 지정된 RUNTIME 동안 최대 속도로 실행됩니다. 기본값은 2초입니다. 충분한 공간이 확보되었는지 확인하세요. RUNTIME은 코드나 Dashboard에서 조정할 수 있습니다. MaxVelocityTuner 결과 확인 실행 후 \u0026ldquo;Max Velocity\u0026rdquo; 값과 \u0026ldquo;Voltage Compensated kF\u0026rdquo; 값이 출력됩니다. \u0026ldquo;Max Velocity\u0026quot;는 로봇이 최대 부하와 배터리 수준에서 이동할 수 있는 최대 속도입니다. 이 값을 DriveConstants의 MAX_VEL로 설정하세요. 약간의 여유를 두기 위해 90-95% 값을 추천합니다. \u0026ldquo;Voltage Compensated kF\u0026rdquo; 값을 기록하세요. 만약 로봇이 원을 그리며 회전한다면, 드라이브 트레인의 모터 방향 설정이 잘못되었습니다. 여기를 참조하세요. Dashboard 설정 Dashboard 오른쪽의 DriveConstants 드롭다운에서 MOTOR_VELO_PID를 열고 f 필드에 \u0026ldquo;Voltage Compensated kF\u0026rdquo; 값을 입력합니다. DriveVelocityPIDTuner 실행 로봇이 지정된 거리(기본값: 72인치)를 반복적으로 직선 이동합니다. 충분한 공간(최소 72인치 + 1피트)을 확보하세요. 공간이 부족하다면 Dashboard 또는 파일에서 DISTANCE 값을 조정하세요. 로봇이 직선에서 벗어나더라도 걱정하지 마세요. 나중에 헤딩 PID가 이를 보정합니다. 예제 대시보드 (그래프 내용은 무시하세요. 이는 페이지 레이아웃의 예시일 뿐입니다.)\r그래프 설정 프로그램 실행 후 Dashboard에서 그래프 버튼을 클릭하세요. 그래프가 표시되지 않고 체크박스가 나타나면 targetVelocity와 velocity0 체크박스를 활성화하세요. DISTANCE 조정 그래프의 targetVelocity 선이 평평한 구간(Plateau)을 가지도록 DISTANCE 값을 조정하세요. PIDF 값 튜닝 velocity0 그래프가 targetVelocity 선과 일치하도록 PIDF 값을 조정합니다. 튜닝 절차\n모든 PID 값을 0으로 설정하고, f는 MaxVelocityTuner에서 얻은 값으로 설정합니다.\nvelocity0이 targetVelocity의 꼭대기에 도달하도록 kF 값을 조정합니다.\np 값을 서서히 증가시켜 그래프의 경사(slope)가 targetVelocity와 일치하도록 합니다.\nd 값을 소량 조정하여 진동을 줄입니다.\ni 값은 사용하지 않는 것이 좋습니다. 필요하다면 f 값을 증가시키세요.\n튜닝 후 Dashboard에서 설정한 값을 DriveConstants.java 파일에 복사하세요. Dashboard 설정은 임시로 저장되므로, 이를 잊지 마세요.\n추가 팁\n진동을 최소화하는 것을 우선시하세요. 완벽한 튜닝은 불가능하므로, 일정 수준의 편차를 허용하세요. 튜닝 시뮬레이터를 활용해 각 PIDF 값이 동작에 미치는 영향을 확인하세요. 팁\nVelocity PID 컨트롤러에서는 kD가 반드시 필요한 것은 아니지만, FTC 로봇에서는 피드포워드와 모터 컨트롤러 특성 때문에 유용할 수 있습니다.\ni 값을 사용하는 대신 f 값을 조정하는 것이 더 효과적입니다.\n문제 해결 (Troubleshooting) MaxVelocityTuner가 뒤로 움직이는 경우\n휠의 방향이 올바르게 설정되었는지 확인하세요. 디버깅 시 goBILDA 메카넘 차트를 참고하세요. 속도 선 중 하나가 targetVelocity와 반대로 움직이는 경우\n모터의 극성이 잘못되었습니다. 인코더가 모터의 실제 회전 방향과 다르게 읽고 있습니다. 모터의 빨간색과 검은색 케이블을 교체하세요. 또는 SampleMecanumDrive에서 인코더 값을 -1로 곱하세요. StraightTest 또는 DriveVelocityPID가 계속 과도하게 움직이고 DriveConstants.java 변수 조정이 효과가 없는 경우\nDriveConstants.java에서 MAX_VEL 값을 낮춰보세요. 문제를 확인하기 위해 처음에는 아주 낮은 값으로 설정하세요. 기타 모터 방향 문제\n모터 방향 설정을 참조하세요. 모터 설정 디버깅에 어려움이 있다면 Motor Direction Debugger opmode를 사용하세요. 파일에서 41번째 줄의 @Disabled를 제거한 후, opmode 주석에 따라 실행하세요. 각 모터를 하나씩 실행하여 문제를 진단하고 적절히 수정하세요. PID 튜닝 시뮬레이터 현재 이 웹사이트에서는 시뮬레이터를 직접적으로 지원하지 않습니다. 대신, 아래 버튼을 클릭하여 시뮬레이터를 이용해볼 수 있습니다.\n시뮬레이션 바로가기\n튜닝 예제\n게인 값을 조정하며 그래프가 어떻게 변하는지 확인하세요. 이 그래프는 실제 로봇 튜닝 시와 매우 유사하므로 사전에 이해를 돕는 데 유용합니다. 새 게인 값을 입력한 후 Enter 키를 눌러 적용하세요. 팁\n이 시뮬레이터는 매우 기본적인 수준의 \u0026ldquo;시뮬레이터\u0026quot;입니다.\nRev Hub 모터 컨트롤러를 정확히 시뮬레이션하지는 않으며, 단순한 DC 모터 모델을 기반으로 동작합니다. 실제 튜닝과 다를 수 있지만 기본적인 동작 원리를 이해하는 데 유용합니다. 시뮬레이터의 kF 값은 매우 효과적이지만, 실제 로봇에서는 Rev Hub 모터 컨트롤러 특성 때문에 효과가 덜할 수 있습니다. 버그가 있을 수 있으니, 문제가 발생하면 \u0026ldquo;Reset\u0026rdquo; 버튼을 사용하세요. PID 컨트롤러 학습 자료 추천 영상\nPID 컨트롤러의 직관적인 이해를 돕는 몇 가지 좋은 영상입니다.\n첫 번째 영상은 초반 3-4분을 건너뛰고, 각 게인의 동작을 설명하는 후반부를 참고하세요. 두 번째와 세 번째 영상도 게인의 동작을 설명합니다. PID Control Explained Understanding PID Control PID Tuning Basics 추가 읽기 자료\nIntro to Control: Part One - PID 임시 비디오 편집된 영상이 준비되기 전 임시로 제공되는 비디오입니다. 화질은 좋지 않지만 도움이 될 수 있습니다.\n","date":"2023-09-07","id":8,"permalink":"/docs/4-tuning/%EC%A3%BC%ED%96%89-%EC%86%8D%EB%8F%84-pid-%EC%A1%B0%EC%9C%A8-driving-velocity-pid-tuner/","summary":"\u003cdiv class=\"callout callout-danger d-flex flex-row mt-4 mb-4 pt-4 pe-4 pb-2 ps-3\"\u003e\r\n  \u003csvg\n  xmlns=\"http://www.w3.org/2000/svg\"\n  width=\"24\"\n  height=\"24\"\n  viewBox=\"0 0 24 24\"\n  fill=\"none\"\n  stroke=\"currentColor\"\n  stroke-width=\"2\"\n  stroke-linecap=\"round\"\n  stroke-linejoin=\"round\"\n \n class=\"outline/alert-octagon svg-inline callout-icon me-2 mb-3\" id=\"svg-alert-octagon\" role=\"img\"\u003e\n  \u003cpath stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"/\u003e\n  \u003cpath d=\"M12.802 2.165l5.575 2.389c.48 .206 .863 .589 1.07 1.07l2.388 5.574c.22 .512 .22 1.092 0 1.604l-2.389 5.575c-.206 .48 -.589 .863 -1.07 1.07l-5.574 2.388c-.512 .22 -1.092 .22 -1.604 0l-5.575 -2.389a2.036 2.036 0 0 1 -1.07 -1.07l-2.388 -5.574a2.036 2.036 0 0 1 0 -1.604l2.389 -5.575c.206 -.48 .589 -.863 1.07 -1.07l5.574 -2.388a2.036 2.036 0 0 1 1.604 0z\" /\u003e\n  \u003cpath d=\"M12 8v4\" /\u003e\n  \u003cpath d=\"M12 16h.01\" /\u003e\n\u003c/svg\u003e\r\n  \u003cdiv class=\"callout-content\"\u003e\r\n    \u003cdiv class=\"callout-title\"\u003e\r\n        \u003cp\u003e경고\u003c/p\u003e","tags":[],"title":"주행 속도 PID 조율 (Driving Velocity PID Tuner)"},{"content":"\r현재 단계는 직진 테스트 단계입니다.\n주의\n구동 인코더 로컬라이제이션(데드 휠 미사용)을 사용하는 경우, 아래 구동 인코더 로컬라이제이션 단계를 따라야 합니다. 이 섹션은 구동 인코더 로컬라이제이션 조정에 필수적입니다.\n속도 컨트롤러를 조정한 후, 모든 것이 제대로 작동하는지 확인하기 위해 간단한 직진 테스트를 실행해야 합니다.\n기본 직진 테스트 RC를 사용해 StraightTest OpMode를 실행합니다. 로봇이 이동한 거리를 측정합니다. 기본 설정에서 로봇은 60인치를 이동해야 합니다. 이 거리는 Dashboard 또는 OpMode 코드에서 변경할 수 있습니다. Dashboard에서 변경하려면, 오른쪽 변수 설정 사이드바에서 StraightTest 드롭다운을 찾고 DISTANCE 값을 수정합니다. OpMode에서 직접 변경하려면, StraightTest.java 파일에서 17번째 줄의 DISTANCE 값을 수정합니다. StraightTest 작업 모드를 23회 실행하여, 로봇이 지정된 거리 내에서 13% 정도의 일관성을 유지하는지 확인합니다. 로봇이 완전히 균일하게 움직이지 않을 수 있습니다. 이는 나중에 방향 및 폐쇄 루프 피드백이 활성화되면서 수정됩니다. 오차가 큰 경우 앞선 단계에서의 속도 조절기가 좀 더 정확하게 조율되어야 합니다. 로봇이 약간 치우쳐질 수 있습니다. 이는 후에 PID 조정 단계에서 수정될 것이기에 무시해도 됩니다. 경고\n피드포워드 조율을 수행한 경우 주의사항:\n로봇이 지정된 거리를 약 10~15% 초과할 가능성이 높습니다. 이 문제는 특히 조율이 빠르게 진행 되었을수록 더 심할 수 있습니다. 이는 REV Hub 모터 컨트롤러의 감속 제어 문제로 인해 발생합니다. 이 단계에서는 이 문제를 무시할 수 있습니다. 이후 추종 PID 조정 단계에서 kD와 kP 값을 조정하여 이 문제를 해결할 수 있습니다. (하지만 PID가 이를 완전히 수정하지 못한다면 kV값을 다시 조정해야할 수 있습니다.)\n모든 것이 정상적으로 작동하면 다음 단계로 진행하십시오. 가로 이동 계수 조정 - 데드 휠을 사용하는 경우 주의\n구동 인코더 로컬라이제이션(데드 휠 미사용)을 사용하는 경우 이 섹션을 건너뛰십시오.\n팁\n이는 필수적인 단계는 아닙니다 (데드 휠을 사용하는 경우). 하지만 메카넘 구동의 운동학적 특성상, 메카넘 구동은 가로 이동(strafing) 시 낮은 토크를 나타냅니다. 따라서 피드포워드 값에 약간의 보정이 필요할 수 있습니다. 이 단계를 건너뛴 경우라도, 변환 PID가 이러한 불일치를 대부분 보완하므로 문제를 알아차리지 못할 가능성이 높습니다. 하지만 가로 이동 중 목표 거리보다 짧게 이동(undershooting)하는 현상이 발생하면 **가로 이동 계수(Lateral Multiplier)**를 적용하는 것이 좋습니다.\n가로 이동의 비효율성은 이 문서를 참고하세요.\nRC를 사용해 StrafeTest OpMode를 실행합니다. OpMode를 실행하면 로봇이 오른쪽으로 지정된 거리만큼 이동합니다. (코드를 수정하여 왼쪽 이동으로 변경 가능) 기본 설정에서 로봇은 60인치를 이동해야 합니다. 그러나 실제 이동 거리는 이보다 짧을 수 있기에, 실제 이동 거리도 측정합니다. 목표 거리(기본값 60인치)를 실제 이동 거리로 나눕니다. 이 값을 SampleMecanumDrive.java 파일(57번째 줄)의 LATERAL_MULTIPLIER 변수에 설정합니다. StrafeTest 작업 모드를 다시 실행하여 수정된 값이 적용되었는지 확인합니다. 구동 인코더 로컬라이제이션 구동 인코더 로컬라이제이션(데드 휠 미사용)을 사용하는 경우, StraightTest와 StrafeTest 단계에서 로컬라이제이션을 조정해야 합니다.\n직진 테스트 StraightTest OpMode를 실행합니다. 실행이 완료되면 x와 y 이동 거리가 출력됩니다. 로봇이 한쪽으로 치우칠 수 있습니다. 이는 나중에 PID 조정이 활성화되면서 수정됩니다. 실제 이동 거리를 측정하고, 텔레메트리(Telemetry)에 표시된 finalX 값과 비교합니다. 두 값이 일치하지 않으면, DriveConstants.java 파일의 GEAR_RATIO를 실제 거리 / 출력된 x 값으로 곱하여 수정합니다. 이 과정을 여러 번 반복하여 정밀도를 높일 수 있습니다. 가능한 세밀하게 조절하는 것이 좋습니다. 가로 이동 테스트 StrafeTest 작업 모드를 실행합니다. 실행이 완료되면 x와 y 이동 거리가 출력됩니다. 로봇이 전후로 치우칠 수 있습니다. 이는 나중에 PID 조정이 활성화되면서 수정됩니다. 실제 이동 거리를 측정하고, 텔레메트리(Telemetry)에 표시된 finalY 값과 비교합니다. 두 값이 일치하지 않으면, SampleMecanumDrive.java 파일의 LATERAL_MULTIPLIER를 출력된 y 값 / 실제 거리로 설정합니다. 이 과정을 여러 번 반복하여 정밀도를 높일 수 있습니다. 가능한 세밀하게 조절하는 것이 좋습니다. 문제 해결 (Troubleshooting) 로봇이 직진 테스트에서 후진하거나 회전하는 경우: 모터 방향을 반대로 설정하십시오. 지침을 참조하세요.\n직진 테스트가 일관적이지만 지정된 거리에 도달하지 못하는 경우: DriveConstants.java 파일의 설정을 확인하세요.\nTICKS_PER_REV: 인코더의 사양을 확인 MAX_RPM: 모터의 최대 RPM 확인 WHEEL_RADIUS: 바퀴 반지름이 정확한지 확인 GEAR_RATIO: 출력:입력 비율 확인 로봇이 잘못된 방향으로 이동하는 경우: goBILDA 메카넘 차트 위와 동일하게 모터 방향을 확인하고 수정하세요. 이 외에도 아래 내용을 참고할 수 있습니다.\n모터 방향 반전을 참고하십시오. 모터 구성을 디버깅하는 데 어려움을 겪고 있다면 모터 방향 디버거를 참조하세요. 모터 방향 디버거를 사용하면 모터를 하나씩 돌릴 수 있습니다. 41번 줄에서 @Disabled lin을 제거하고 opmode 주석의 지침을 따르십시오. 이를 사용하여 모터 구성 문제를 진단하고 적절하게 수정하세요. 10% 초과 문제: REV Hub의 모터 컨트롤러는 감속을 제대로 처리하지 못합니다. 이로 인해 감속 단계에서 피드포워드를 정확히 튜닝하는 것이 불가능합니다. 이는 매번 10% 정도의 오버슈트를 초래할 수 있으며, 이는 충분히 예상된 결과입니다. 따라서 이 문제를 무시하고 다음 단계로 진행하십시오. 이 문제는 팔로워 PID 조율 과정에서 해결될 것입니다.\n팁\nkV 값을 줄여 오버슈트를 감소시키는 경우: 이는 로봇이 지정된 모션 프로파일을 정확히 따르는 능력에 부정적인 영향을 미칠 수 있습니다. 그러나 경로 전체를 따르는 정확성보다 최종 지점의 정확도가 더 중요하다는 점에서 이러한 부정확성을 어느 정도 용인할 수 있습니다. 우리는 폐루프 피드백(closed-loop feedback)이 경로를 따르는 과정에서 발생할 수 있는 문제를 해결할 것으로 기대하고 있습니다. kV 값을 줄여 오버슈트를 보완하면 특히 코스팅(coasting) 단계에서 모션 프로파일 정확도가 저하될 수 있습니다. 그러나 이 문제가 주로 빠른 기어비를 사용하는 시스템에서 나타나며, 이러한 경우 실제로 코스팅 단계에 많은 시간을 소비하지 않는 경우가 많습니다. 따라서 가속 및 감속 단계가 더 중요하게 여겨지므로, kV 값을 줄이는 것이 적절한 선택이 될 수 있습니다.\n","date":"2023-09-07","id":9,"permalink":"/docs/4-tuning/%EC%A7%81%EC%A7%84-%ED%85%8C%EC%8A%A4%ED%8A%B8-straight-test/","summary":"\u003cimg alt=\"diagram\" class=\"diagram diagram-kroki diagram-kroki-plantuml\" id=\"h-rh-cb-kroki-0\" src=\"/_4379547960681791084.svg\"\u003e\u003cp\u003e현재 단계는 \u003cstrong\u003e직진 테스트\u003c/strong\u003e 단계입니다.\u003c/p\u003e\n\u003cdiv class=\"callout callout-caution d-flex flex-row mt-4 mb-4 pt-4 pe-4 pb-2 ps-3\"\u003e\r\n  \u003csvg\n  xmlns=\"http://www.w3.org/2000/svg\"\n  width=\"24\"\n  height=\"24\"\n  viewBox=\"0 0 24 24\"\n  fill=\"none\"\n  stroke=\"currentColor\"\n  stroke-width=\"2\"\n  stroke-linecap=\"round\"\n  stroke-linejoin=\"round\"\n \n class=\"outline/alert-triangle svg-inline callout-icon me-2 mb-3\" id=\"svg-alert-triangle\" role=\"img\"\u003e\n  \u003cpath stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"/\u003e\n  \u003cpath d=\"M12 9v4\" /\u003e\n  \u003cpath d=\"M10.363 3.591l-8.106 13.534a1.914 1.914 0 0 0 1.636 2.871h16.214a1.914 1.914 0 0 0 1.636 -2.87l-8.106 -13.536a1.914 1.914 0 0 0 -3.274 0z\" /\u003e\n  \u003cpath d=\"M12 16h.01\" /\u003e\n\u003c/svg\u003e\r\n  \u003cdiv class=\"callout-content\"\u003e\r\n    \u003cdiv class=\"callout-title\"\u003e\r\n        \u003cp\u003e주의\u003c/p\u003e","tags":[],"title":"직진 테스트 (Straight Test)"},{"content":"\r현재 단계는 경로 폭 조율 단계입니다.\n주의\n트랙 너비를 조정하기 전에 로컬라이저의 방향 측정이 정확해야 합니다. 3-오도메트리 로컬라이저를 사용하는 경우, 측면 거리(lateral distance)를 먼저 조정하세요. 다른 경우에는 IMU를 통해 헤딩을 직접 얻어야 합니다.\n노트\n\u0026ldquo;경로 폭\u0026quot;라는 용어는 문맥에 따라 혼란을 줄 수 있으므로, 이를 명확히 설명합니다.\n경로 폭이란 두 개의 평행한 바퀴의 중심 간 거리입니다. 하지만, 이 용어는 상황에 따라 두 가지로 사용됩니다.\nDriveConstants.java에서의 경로 폭는 드라이브 트레인의 경로 폭를 의미합니다. 3-휠 로컬라이저에서의 트랙 너비는 두 평행한 바퀴의 중심 간 거리로, 이는 LATERAL_DISTANCE와 동일합니다. 현재는 로컬라이저를 다루지 않으므로, 이 페이지에서 언급되는 모든 \u0026ldquo;트랙 너비\u0026quot;는 드라이브 트레인의 트랙 너비를 의미합니다.\n2019/20 Skystone Bot (3658 Bosons)\r조율 과정 (Tuning Process) 최대 각속도 측정\n경로 폭 튜너를 실행하기 전에 로봇이 유지할 수 있는 최대 각속도를 측정해야 합니다. 각속도가 너무 높으면 튜너가 제대로 작동하지 않습니다.\nMaxAngularVelocityTuner OpMode를 실행합니다. 이 튜너는 로봇을 최대 속도로 몇 초 동안 회전시킵니다. 완료 후 \u0026ldquo;Max Angular Velocity\u0026rdquo; 값이 출력됩니다. 이 값을 DriveConstants.java의 MAX_ANG_VEL 필드에 설정하세요. 경로 폭 튜너 실행\nTrackWidthTuner OpMode를 실행합니다. OpMode를 실행하면 로봇이 180도를 5회 회전할 것입니다. 조정 중 로봇을 건드리면 안 됩니다. 실행 후, RC의 텔레메트리(Telemetry)에 \u0026ldquo;effective track width\u0026quot;가 출력됩니다. 트랙 너비 값 설정\n출력된 값이 실제 물리적 트랙 너비와 유사하다면(약간의 차이는 괜찮음), 이 값을 DriveConstants.java의 TRACK_WIDTH에 설정합니다. FTC 대시보드가 열려 있다면, 오른쪽 변수 구성 사이드바에서 트랙 너비를 직접 변경하며 테스트할 수 있습니다. (초기 추정치를 설정한 후 테스트하세요.) 로봇은 한 번 튜닝 할 때 마다 180도에 가까운 회전을 수행해야 합니다. 문제가 발생한다면 수동 조율을 해야합니다. (180도를 돌지 않거나, 경로 폭이 합리적이지 않은 경우) 수동 튜닝\n튜닝 결과가 만족스럽지 않거나 효과적인 트랙 너비 값이 합리적이지 않은 경우, 수동으로 트랙 너비를 조정합니다. 180도로 회전하도록 경로 폭를 조절하면 됩니다. 로봇이 180도보다 적게 회전하면 경로 폭를 늘리고, 180도보다 많이 회전하면 줄입니다. 노트\n튜닝 결과는 완벽할 필요가 없습니다. 약 ±2~3도 이내의 정확도면 충분합니다. 현재 단계는 폐루프 피드백이 없는 피드포워드 모션 프로파일을 사용합니다. 이후 팔로워 PID 튜닝 단계에서 헤딩 PID를 활성화하면 원하는 각도로 정확히 회전할 수 있습니다. 문제 해결 (Troubleshooting) 튜너 작동 불량 DriveConstants.java의 MAX_ANG_VEL 값을 줄여보세요. ","date":"2023-09-07","id":10,"permalink":"/docs/4-tuning/%EA%B2%BD%EB%A1%9C-%ED%8F%AD-%EC%A1%B0%EC%9C%A8-track-width-tuner/","summary":"\u003cimg alt=\"diagram\" class=\"diagram diagram-kroki diagram-kroki-plantuml\" id=\"h-rh-cb-kroki-0\" src=\"/_13807940720874502112.svg\"\u003e\u003cp\u003e현재 단계는 \u003cstrong\u003e경로 폭 조율\u003c/strong\u003e 단계입니다.\u003c/p\u003e\n\u003cdiv class=\"callout callout-caution d-flex flex-row mt-4 mb-4 pt-4 pe-4 pb-2 ps-3\"\u003e\r\n  \u003csvg\n  xmlns=\"http://www.w3.org/2000/svg\"\n  width=\"24\"\n  height=\"24\"\n  viewBox=\"0 0 24 24\"\n  fill=\"none\"\n  stroke=\"currentColor\"\n  stroke-width=\"2\"\n  stroke-linecap=\"round\"\n  stroke-linejoin=\"round\"\n \n class=\"outline/alert-triangle svg-inline callout-icon me-2 mb-3\" id=\"svg-alert-triangle\" role=\"img\"\u003e\n  \u003cpath stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"/\u003e\n  \u003cpath d=\"M12 9v4\" /\u003e\n  \u003cpath d=\"M10.363 3.591l-8.106 13.534a1.914 1.914 0 0 0 1.636 2.871h16.214a1.914 1.914 0 0 0 1.636 -2.87l-8.106 -13.536a1.914 1.914 0 0 0 -3.274 0z\" /\u003e\n  \u003cpath d=\"M12 16h.01\" /\u003e\n\u003c/svg\u003e\r\n  \u003cdiv class=\"callout-content\"\u003e\r\n    \u003cdiv class=\"callout-title\"\u003e\r\n        \u003cp\u003e주의\u003c/p\u003e","tags":[],"title":"경로 폭 조율 (Track Width Tuner)"},{"content":"\r현재 단계는 회전 테스트 단계입니다.\n회전 테스트 튜닝 회전 테스트는 경로 폭(Track Width)이 크게 잘못되지 않았는지 확인하는 단계입니다.\nRC를 통해 TurnTest OpMode를 실행합니다. 기본 설정에서 TurnTest는 로봇을 90도 회전시키도록 되어 있습니다. 로봇이 정확히 90도 회전하지 않을 수도 있습니다. 이는 약간의 피드포워드(Feedforward) 차이로 인한 것일 수 있습니다. 만약 정확히 회전하지 않는다면 Android Studio에서 TurnTest.java OpMode 파일로 이동하여 ANGLE 변수를 180도로 변경합니다. OpMode를 다시 실행합니다. 경로 폭을 올바르게 튜닝했다면 로봇이 정확히 180도 회전해야 합니다. 그렇지 않다면 경로 폭을 다시 튜닝하세요. 90도 회전 시 발생하는 오류는 걱정하지 마세요. 이 문제는 나중에 헤딩 PID(Heading PID)를 튜닝할 때 수정됩니다. 주의: TurnTest는 기본적으로 반시계 방향으로 90도 회전해야 합니다. 만약 기본 설정에서 로봇이 시계 방향으로 회전한다면, SampleMecanumDrive.java 파일에서 왼쪽과 오른쪽 구동 모터의 방향 설정이 뒤바뀌었는지 확인하세요. ","date":"2023-09-07","id":11,"permalink":"/docs/4-tuning/%ED%9A%8C%EC%A0%84-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%A1%B0%EC%9C%A8-turn-test-tuning/","summary":"\u003cimg alt=\"diagram\" class=\"diagram diagram-kroki diagram-kroki-plantuml\" id=\"h-rh-cb-kroki-0\" src=\"/_6321135533114844868.svg\"\u003e\u003cp\u003e현재 단계는 \u003cstrong\u003e회전 테스트\u003c/strong\u003e 단계입니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"회전-테스트-튜닝\"\u003e회전 테스트 튜닝\u003c/h3\u003e\n\u003cp\u003e회전 테스트는 경로 폭(Track Width)이 크게 잘못되지 않았는지 확인하는 단계입니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eRC를 통해 \u003ccode\u003eTurnTest\u003c/code\u003e OpMode를 실행합니다.\u003c/li\u003e\n\u003cli\u003e기본 설정에서 \u003ccode\u003eTurnTest\u003c/code\u003e는 로봇을 \u003cstrong\u003e90도 회전\u003c/strong\u003e시키도록 되어 있습니다.\u003c/li\u003e\n\u003cli\u003e로봇이 정확히 90도 회전하지 않을 수도 있습니다. 이는 약간의 피드포워드(Feedforward) 차이로 인한 것일 수 있습니다.\u003c/li\u003e\n\u003cli\u003e만약 정확히 회전하지 않는다면 Android Studio에서 \u003ccode\u003eTurnTest.java\u003c/code\u003e OpMode 파일로 이동하여 \u003ccode\u003eANGLE\u003c/code\u003e 변수를 \u003cstrong\u003e180도\u003c/strong\u003e로 변경합니다.\u003c/li\u003e\n\u003cli\u003eOpMode를 다시 실행합니다. 경로 폭을 올바르게 튜닝했다면 로봇이 정확히 \u003cstrong\u003e180도 회전\u003c/strong\u003e해야 합니다.\u003c/li\u003e\n\u003cli\u003e그렇지 않다면 경로 폭을 다시 튜닝하세요. 90도 회전 시 발생하는 오류는 걱정하지 마세요. 이 문제는 나중에 헤딩 PID(Heading PID)를 튜닝할 때 수정됩니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e주의:\u003c/strong\u003e \u003ccode\u003eTurnTest\u003c/code\u003e는 기본적으로 \u003cstrong\u003e반시계 방향으로 90도 회전\u003c/strong\u003e해야 합니다. 만약 기본 설정에서 로봇이 시계 방향으로 회전한다면, \u003ccode\u003eSampleMecanumDrive.java\u003c/code\u003e 파일에서 \u003cstrong\u003e왼쪽과 오른쪽 구동 모터의 방향 설정이 뒤바뀌었는지\u003c/strong\u003e 확인하세요.\u003c/li\u003e\n\u003c/ol\u003e","tags":[],"title":"회전 테스트 조율 (Turn Test Tuning)"},{"content":"\r현재 단계는 로컬라이제이션 (2번째) 테스트 단계입니다.\n경고\n데드 휠을 사용하는 경우 이 페이지를 무시하세요.\n로컬라이제이션 테스트 이 단계에서는 드라이브 인코더를 사용한 로컬라이제이션이 정확한지 확인합니다. 이 과정에서 발생하는 오류는 DriveConstants 파일의 문제 때문일 가능성이 높습니다.\nRC를 통해 LocalizationTest 오프모드를 실행합니다. RC에 연결된 스마트폰의 경우 192.168.49.1:8080/dash로, 컨트롤 허브(Control Hub)를 사용하는 경우 192.168.43.1:8080/dash로 접속합니다. 대시보드 오른쪽 상단에서 Field 보기를 선택했는지 확인합니다. 로봇을 이리저리 움직여 봅니다. 대시보드 맵에 로봇의 움직임이 그려져야 합니다. 대시보드 상에서 표시된 로봇의 방향이 실제 로봇의 방향과 일치하는지 확인합니다. 방향이 정확히 일치한다면 다음 단계로 진행합니다.\n그렇지 않다면 이전 단계로 돌아가 오류를 수정해야 합니다. ","date":"2023-09-07","id":12,"permalink":"/docs/4-tuning/%EB%A1%9C%EC%BB%AC%EB%9D%BC%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98-%ED%85%8C%EC%8A%A4%ED%8A%B8-localization-test/","summary":"\u003cimg alt=\"diagram\" class=\"diagram diagram-kroki diagram-kroki-plantuml\" id=\"h-rh-cb-kroki-0\" src=\"/_5519686397613862283.svg\"\u003e\u003cp\u003e현재 단계는 \u003cstrong\u003e로컬라이제이션 (2번째) 테스트\u003c/strong\u003e 단계입니다.\u003c/p\u003e\n\u003cdiv class=\"callout callout-danger d-flex flex-row mt-4 mb-4 pt-4 pe-4 pb-2 ps-3\"\u003e\r\n  \u003csvg\n  xmlns=\"http://www.w3.org/2000/svg\"\n  width=\"24\"\n  height=\"24\"\n  viewBox=\"0 0 24 24\"\n  fill=\"none\"\n  stroke=\"currentColor\"\n  stroke-width=\"2\"\n  stroke-linecap=\"round\"\n  stroke-linejoin=\"round\"\n \n class=\"outline/alert-octagon svg-inline callout-icon me-2 mb-3\" id=\"svg-alert-octagon\" role=\"img\"\u003e\n  \u003cpath stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"/\u003e\n  \u003cpath d=\"M12.802 2.165l5.575 2.389c.48 .206 .863 .589 1.07 1.07l2.388 5.574c.22 .512 .22 1.092 0 1.604l-2.389 5.575c-.206 .48 -.589 .863 -1.07 1.07l-5.574 2.388c-.512 .22 -1.092 .22 -1.604 0l-5.575 -2.389a2.036 2.036 0 0 1 -1.07 -1.07l-2.388 -5.574a2.036 2.036 0 0 1 0 -1.604l2.389 -5.575c.206 -.48 .589 -.863 1.07 -1.07l5.574 -2.388a2.036 2.036 0 0 1 1.604 0z\" /\u003e\n  \u003cpath d=\"M12 8v4\" /\u003e\n  \u003cpath d=\"M12 16h.01\" /\u003e\n\u003c/svg\u003e\r\n  \u003cdiv class=\"callout-content\"\u003e\r\n    \u003cdiv class=\"callout-title\"\u003e\r\n        \u003cp\u003e경고\u003c/p\u003e","tags":[],"title":"로컬라이제이션 테스트 (Localization Test)"},{"content":"\r현재 단계는 팔로워 PID 조율 단계입니다.\n이 단계는 마지막 튜닝 단계로, 폐쇄 루프 피드백 컨트롤러를 조정하는 과정입니다. 이를 통해 경로 추적 성능이 크게 향상될 것입니다.\n이 과정을 위해 사용할 수 있는 두 가지 OpMode가 있습니다:\nBackAndForth FollowerPIDTuner 먼저 BackAndForth 모드를 실행하여 대략적인 PID 게인을 설정한 뒤, FollowerPIDTuner를 사용해 세부적인 튜닝을 진행하는 것을 추천합니다.\nBackAndForth 모드는 로봇이 직선으로 앞뒤로 이동하며, 여기에서 병진 이동(Translation) 및 회전(Heading) PID의 주요 오류를 쉽게 확인할 수 있습니다.\nFollowerPIDTuner는 로봇이 큰 사각형 경로를 따라 이동하도록 설정합니다. 이때 각 코너에서 반시계 방향으로 회전합니다. 방향 조정이 부정확하면 전체 경로가 어긋나며, 로봇을 계속 초기화해야 하므로 과정이 다소 번거로울 수 있습니다. 따라서 초기 튜닝은 BackAndForth 모드에서 진행하고, 이후 세부 조정은 FollowerPIDTuner를 활용하는 것이 좋습니다.\n조율 과정 (Tuning Process) BackAndForth OpMode를 RC(Remote Control)에서 실행한다.\nRC의 Wi-Fi 네트워크에 연결합니다. 네트워크 비밀번호는 Program and Manage 메뉴에서 확인할 수 있습니다.\n브라우저에서 다음 주소로 이동합니다.\nRC 핸드폰 사용 시: 192.168.49.1:8080/dash Control Hub 사용 시: 192.168.43.1:8080/dash 화면 우측 상단에서 Field 뷰를 선택했는지 확인합니다.\n두 개의 선과 원이 화면에 그려지는 것을 확인합니다.\n초록색 : 목표 위치 파란색 : 로봇의 실제 위치 우측 사이드바에서 SampleMecanumDrive를 찾고 드롭다운을 여십시오. HEADING_PID와 TRANSLATION_PID 두 가지 옵션이 표시됩니다. 두 옵션 모두 SampleMecanumDrive 파일에 위치합니다.\n먼저 HEADING_PID를 먼저 엽니다.\nkP 값을 점진적으로 증가시키며 로봇이 정확한 헤딩을 유지하도록 조정하세요. 경험적으로 kP 값은 약 8 정도였지만, 환경에 따라 달라질 수 있습니다. 일반적으로 kD와 kI는 조정할 필요가 없습니다. TRANSLATION_PID를 엽니다.\n마찬가지로 kP 값을 점진적으로 증가시키며 로봇이 경로를 잘 따라가도록 조정하세요. 이 값도 약 8 정도였지만, 환경에 따라 달라질 수 있습니다. kD와 kI는 일반적으로 조정할 필요가 없습니다. 튜닝이 완료되면, 값을 SampleMecanumDrive.java 파일의 PID 객체에 복사하십시오. 대시보드에서 변경한 값이 코드에도 반영되도록 해야 합니다.\nFollowerPIDTuner를 사용해 동일한 과정을 반복하며 추가적인 정밀 튜닝을 진행하세요. 이는 더욱 정확한 결과를 얻기 위해 권장됩니다.\n튜닝이 완료되었으면 SplineTest를 실행해 경로 추적 정확도를 확인하세요.\n노트\n일반적으로 kI와 kD는 필요하지 않다고 했지만, 이는 기본 가이드라인일 뿐입니다. kD는 피드포워드(Feedforward)를 사용하는 경우 배터리 전압 변화에도 포즈 속도를 일정하게 유지하는 데 도움을 줄 수 있습니다. 이 경우 kD 값을 1 정도로 설정해보세요. 단, 주행 속도 PID를 사용하는 경우 kD를 설정하면 두 PID가 서로 충돌할 수 있으므로 사용하지 마세요. 비공식 영상 이 영상은 임시 영상입니다. 추후 업데이트될 예정입니다.\n","date":"2023-09-07","id":13,"permalink":"/docs/4-tuning/%ED%8C%94%EB%A1%9C%EC%9B%8C-pid-%EC%A1%B0%EC%9C%A8-follower-pid-tuner/","summary":"\u003cimg alt=\"diagram\" class=\"diagram diagram-kroki diagram-kroki-plantuml\" id=\"h-rh-cb-kroki-0\" src=\"/_10924514805406677008.svg\"\u003e\u003cp\u003e현재 단계는 \u003cstrong\u003e팔로워 PID 조율\u003c/strong\u003e 단계입니다.\u003c/p\u003e\n\u003cp\u003e이 단계는 마지막 튜닝 단계로, 폐쇄 루프 피드백 컨트롤러를 조정하는 과정입니다.\n이를 통해 경로 추적 성능이 크게 향상될 것입니다.\u003c/p\u003e","tags":[],"title":"팔로워 PID 조율 (Follower PID Tuner)"},{"content":"\r현재 단계는 스플라인 테스트 단계입니다.\n스플라인 테스트 병진 이동과 회전 PID가 조정되었으면, Spline Test를 실행하여 모든 것이 제대로 작동하는지 확인하세요. 대시보드를 열어 로봇이 올바르게 경로를 따라가는지 확인하세요. 로봇은 S자 형태의 경로를 따라가야 하며, 대시보드에서도 해당 경로가 올바르게 표시되어야 합니다. 만약 경로를 따르는 동안 약간의 **진동(oscillation)**이 발생한다면, 속도 PID(velocity PID) 또는 **병진 이동/회전 PID(translational/heading PID)**의 P 값이 너무 높을 가능성이 있습니다. 이 문제를 해결하려면 해당 PID 값을 다시 낮춰보며 조정하세요. 문제가 발생하면 원인을 진단하기 위해 다시 돌아가 문제를 분석하세요. **FTC Discord**에서 도움을 받을 수도 있습니다. 축하합니다! 모든 과정이 끝났습니다. 🎉 문제 진단 팁 대시보드를 열어 경로를 따라가는 동안 확인하세요.\nX, Y, Heading 에러를 관찰하며, 에러가 로컬라이저(Localizer) 때문인지 아니면 기본 경로 추적기(Base Path Follower) 때문인지 확인하세요. 병진 이동 / 회전 (Translational/Heading) PID를 끄기\n병진 이동 / 회전 PID의 계수를 0으로 설정하세요. 병진 이동 / 회전 PID를 껐을 때 경로 추적이 정상적으로 이루어진다면, 문제는 로컬라이저에 있습니다. LocalizationTest를 실행하고 로컬라이저(대부분 StandardTrackingWheelLocalizer)를 수정하세요. 병진 이동 / 회전 PID를 껐는데도 문제가 계속된다면, 문제는 구동 모터 방향이나 구동 상수(drive constants)에 있을 가능성이 높습니다. 모든 것을 차례로 끄면서 문제를 역추적하세요.\n처음부터 하나씩 각 구성 요소를 확인하며 점진적으로 문제를 해결하면 더 빠르게 원인을 파악할 수 있습니다. 포즈 히스토리 제한 해제\n대시보드의 필드에서 파란 선(포즈 히스토리, Pose History)이 사라지는 것을 방지하려면, SampleMecanumDrive에서 POSE_HISTORY_LIMIT 값을 -1로 설정하세요. 이는 디버깅에 유용할 수 있습니다. 속도와 가속도 제한 낮추기\nDriveConstants.java에서 속도(Velocity)와 가속도(Acceleration) 제한을 낮추세요. 실제 로봇이 달성할 수 있는 속도/가속도보다 높은 값을 설정하면, 로봇이 따라갈 수 없는 모션 프로파일이 생성되어 경로 추적이 실패할 수 있습니다. 심각한 문제가 있다면 최대 속도와 가속도를 절반으로 줄이고, 각속도/각가속도 값을 약 60도/초 정도로 낮춰보세요. 튜닝 OpMode 숨기기 Road Runner Quickstart에는 여러 튜닝 OpMode가 포함되어 있습니다.\n사용자 정의 OpMode를 추가하면 RC의 OpMode 목록이 혼잡해질 수 있습니다.\n튜닝 과정이 끝났다면, OpMode 클래스 선언 위에 @Disabled 주석을 추가해 숨길 수 있습니다.\n@Config @Disabled @Autonomous(group = \u0026#34;drive\u0026#34;) public class DriveVelocityPIDTuner extends LinearOpMode { public static double DISTANCE = 72; // in\r위와 같은 방식으로 간단히 비활성화하세요.\n","date":"2023-09-07","id":14,"permalink":"/docs/4-tuning/%EC%8A%A4%ED%94%8C%EB%9D%BC%EC%9D%B8-%ED%85%8C%EC%8A%A4%ED%8A%B8-spline-test/","summary":"\u003cimg alt=\"diagram\" class=\"diagram diagram-kroki diagram-kroki-plantuml\" id=\"h-rh-cb-kroki-0\" src=\"/_5143612574631989375.svg\"\u003e\u003cp\u003e현재 단계는 \u003cstrong\u003e스플라인 테스트\u003c/strong\u003e 단계입니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"스플라인-테스트\"\u003e스플라인 테스트\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e병진 이동과 회전 PID가 조정되었으면, Spline Test를 실행하여 모든 것이 제대로 작동하는지 확인하세요.\u003c/li\u003e\n\u003cli\u003e대시보드를 열어 로봇이 올바르게 경로를 따라가는지 확인하세요. 로봇은 S자 형태의 경로를 따라가야 하며, 대시보드에서도 해당 경로가 올바르게 표시되어야 합니다.\u003c/li\u003e\n\u003cli\u003e만약 경로를 따르는 동안 약간의 **진동(oscillation)**이 발생한다면, \u003cstrong\u003e속도 PID(velocity PID)\u003c/strong\u003e 또는 **병진 이동/회전 PID(translational/heading PID)**의 P 값이 너무 높을 가능성이 있습니다. 이 문제를 해결하려면 해당 PID 값을 다시 낮춰보며 조정하세요.\u003c/li\u003e\n\u003cli\u003e문제가 발생하면 원인을 진단하기 위해 다시 돌아가 문제를 분석하세요. **\u003ca href=\"https://discord.gg/first-tech-challenge\"\u003eFTC Discord\u003c/a\u003e**에서 도움을 받을 수도 있습니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003csmall\u003e 축하합니다! 모든 과정이 끝났습니다. 🎉 \u003c/small\u003e\u003c/p\u003e","tags":[],"title":"스플라인 테스트 (Spline Test)"},{"content":"Trajectory와 Path의 차이점 Road Runner는 경로를 구성하기 위한 Path와 Trajectory 두 가지 데이터 구조를 제공합니다.\nPaths : 사용자가 정의한 웨이포인트를 기반으로 생성된 전체 경로를 단순히 저장합니다. 이 경로는 직선일 수도 있고, 부드러운 스플라인(splines)일 수도 있습니다. Trajectories : Path에 모션 프로파일링을 추가한 구조입니다. 즉, Trajectories는 로봇이 경로를 따라가면서 속도, 가속도, 각가속도 등을 제어할 수 있도록 합니다. 현재 Road Runner는 홀로노믹 드라이브(holonomic drive)를 위한 경로 추적(path following)을 기본 제공하지 않습니다. 대신, 탱크 드라이브(tank drive)를 위한 Ramsete 경로 추적을 포함하고 있습니다.\n홀로노믹 드라이브를 지원하기 위해 벡터 필드 기반의 경로 추적 기능이 추가될 예정입니다. 자세한 내용은 FTC Discord를 참고하세요.\nRoad Runner는 PIDVA 기반의 Trajectory Followers를 홀로노믹 드라이브와 탱크 드라이브 모두에 대해 제공합니다. 이는 기본적으로 Quickstart에서 사용됩니다.\nVector와 Pose Vector와 Pose는 Road Runner에서 자주 사용되는 두 가지 주요 클래스입니다.\nVector2d 2D 벡터를 나타내며, X와 Y 좌표를 포함합니다.\n// 좌표 (10, -5)에 벡터 생성 Vector2d myVector = new Vector2d(10, -5);\rPose2d 2D 로봇 자세(Pose)를 나타내며, X, Y 좌표와 방향(Heading)을 포함합니다. 일반적으로 로봇의 위치와 방향을 나타냅니다. 방향은 삼각함수의 단위 원(Unit Circle)처럼 반시계 방향으로 증가합니다. 따라서 turn 함수는 반시계 방향으로 회전합니다. 각도는 라디안 단위로 표현되며, Math.toRadians()를 사용해 도(Degree)를 라디안으로 변환합니다.\n// 좌표 (10, -5)에서 90도 방향을 향하는 포즈 생성 Pose2d myPose = new Pose2d(10, -5, Math.toRadians(90));\r경로 (Trajectory) 생성하기 아래 내용부터는 Road Runner Quickstart를 사용한다고 가정하도록 하겠습니다. Quickstart를 사용하지 않더라도 기본적인 원리는 동일하며, SampleMecanumDrive.java와 같은 헬퍼 함수는 무시하면 됩니다.\n아래는 Trajectory를 생성하는 기본 예제입니다:\npublic class MyOpmode extends LinearOpMode { @Override public void runOpMode() { SampleMecanumDrive drive = new SampleMecanumDrive(hardwareMap); Trajectory myTrajectory = drive.trajectoryBuilder(new Pose2d()) .strafeRight(10) .forward(5) .build(); waitForStart(); if (isStopRequested()) return; drive.followTrajectory(myTrajectory); } }\r주요 단계 분석 1. 드라이브 객체 생성 SampleMecanumDrive drive = new SampleMecanumDrive(hardwareMap);\rSampleMecanumDrive 객체를 선언하고, OpMode의 hardwareMap을 전달합니다.\n2. Trajectory 빌드 Trajectory myTrajectory = drive.trajectoryBuilder(new Pose2d()) .strafeRight(10) .forward(5) .build();\rtrajectoryBuilder() 호출: drive 객체에서 호출되며, 기본 제약 조건(Constraints)을 전달합니다. 시작 포즈 설정: new Pose2d()는 (0, 0, 0)의 기본값을 가집니다.\n예를 들어, 시작 위치를 (5, -4)로 설정하고 90도 방향을 향하도록 하려면 new Pose2d(5, -4, Math.toRadians(90))로 설정합니다. 메서드 체이닝: .strafeRight(10)은 10인치 오른쪽으로 이동, .forward(5)는 5인치 앞으로 이동을 의미합니다. build() 호출: TrajectoryBuilder 객체를 Trajectory 객체로 변환합니다. 3. Trajectory 실행 waitForStart(); if (isStopRequested()) return; drive.followTrajectory(myTrajectory);\rdrive.followTrajectory(myTrajectory)는 생성된 경로(Trajectory)를 로봇이 따라가도록 명령합니다.\n불연속한 경로 오류 (Path Continuity Exception) 다음과 같은 Trajectory를 실행하려고 할 때:\ndrive.trajectoryBuilder(new Pose2d()) .strafeRight(10) .forward(5) .build();\r프로그램이 충돌하며 PathContinuityException 오류가 발생할 수 있습니다. 이는 경로가 **연속적(continuous)**이지 않기 때문입니다.\n불연속성 문제 모션 프로파일링 시스템에서는 경로가 연속적이어야 합니다. 불연속적인 경로는 물리적으로 실현 불가능하며, 순간적인 속도나 가속도의 급격한 변화가 필요하기 때문입니다.\n문제 예시\n아래 경로에서 로봇이 핑크색 선을 따라 이동하다가 오른쪽으로 순간적으로 방향을 바꾸는 것은 불가능합니다. 로봇은 여전히 위쪽으로의 관성(momentum)을 가지고 있기 때문에, 실제로는 호(arc)를 그리며 움직이게 됩니다.\nPathContinuityException 예시\r해결 방법 1. 경로를 두 개의 Trajectory로 나누기 Trajectory traj1 = drive.trajectoryBuilder(new Pose2d()) .strafeRight(10) .build(); Trajectory traj2 = drive.trajectoryBuilder(traj1.end()) .forward(5) .build(); drive.followTrajectory(traj1); drive.followTrajectory(traj2);\r이 방법은 간단하지만, 각 Trajectory가 끝날 때 로봇이 멈추고 다시 시작해야 하므로 매끄럽지 않을 수 있습니다.\n2. 스플라인(Spline)을 사용해 연속성 유지하기 Trajectory traj = drive.trajectoryBuilder(new Pose2d()) .splineTo(new Vector2d(x1, y1), heading) .splineTo(new Vector2d(x2, y2), heading) .build();\r스플라인은 경로를 매끄럽게 이어주는 방법으로, 로봇이 자연스럽게 움직일 수 있도록 합니다. 스플라인 경로는 시뮬레이션 도구를 사용해 결과를 확인하는 것이 좋습니다.\n스플라인을 사용한 연속적인 경로\rPose Estimate 설정 경고\n자신만의 Opmode를 실행하기 전에 반드시 이 작업을 수행하세요!\nOpMode에서 Trajectory를 실행하기 전에, 로컬라이저(Localizer)의 위치가 모션 프로파일(Motion Profile)의 시작 위치와 일치해야 합니다.\n기본적으로 로컬라이저의 위치는 x: 0, y: 0으로 설정됩니다. 하지만 사용자 정의 시작 Pose를 모션 프로파일에 정의한 경우, 로컬라이저의 위치가 일치하지 않아 이상한 움직임이 발생할 수 있습니다. 로봇이 예상치 못한 방향으로 움직이거나, 위치 PID 및 헤딩 PID가 이를 보정하려 시도하면서 비정상적인 동작을 보일 수 있습니다.\n따라서 첫 번째 모션 프로파일의 시작 위치에 맞춰 drive.setPoseEstimate(new Pose2d())를 OpMode에 추가해야 합니다.\n예시:\npublic void runOpMode() { SampleMecanumDrive drive = new SampleMecanumDrive(hardwareMap); // 로봇을 x: 10, y: -8, heading: 90도에서 시작하려고 합니다. Pose2d startPose = new Pose2d(10, -8, Math.toRadians(90)); drive.setPoseEstimate(startPose); Trajectory traj1 = drive.trajectoryBuilder(startPose) .splineTo(new Vector2d(20, 9), Math.toRadians(45)) .build(); Trajectory traj2 = drive.trajectoryBuilder(traj1.end()) .splineTo(new Vector2d(20, 9), Math.toRadians(45)) .build(); drive.followTrajectory(traj1); drive.followTrajectory(traj2); }\rdrive.setPoseEstimate()는 첫 번째 Trajectory를 실행하기 전에 한 번만 호출하면 됩니다.\n여러 Trajectory 실행하기 로봇이 연속적인 경로를 따르도록 설정했더라도, 두 번째 Trajectory를 실행해야 할 경우가 있습니다. Trajectory는 연속적인 움직임을 나타내며, 로봇이 멈추거나 방향을 전환할 때 종료됩니다.\n여러 Trajectory를 실행하는 방법:\nTrajectory traj1 = drive.trajectoryBuilder(new Pose2d()) .strafeRight(10) .build(); Trajectory traj2 = drive.trajectoryBuilder(traj1.end()) .splineTo(new Vector2d(5, 6), 0) .splineTo(new Vector2d(9, -10), 0) .build(); Trajectory traj3 = drive.trajectoryBuilder(traj2.end()) .splineTo(new Vector2d(5, 6), 0) .splineTo(new Vector2d(9, -10), 0) .build(); drive.followTrajectory(traj1); robot.dropServo(); drive.followTrajectory(traj2); drive.followTrajectory(traj3);\r중요 사항:\nTrajectory가 연속적으로 호출될 경우, 다음 Trajectory의 시작 Pose는 이전 Trajectory의 end() 값이어야 합니다. followTrajectory()를 호출하기 전에 모든 Trajectory를 미리 생성하세요. Trajectory 생성에는 약간의 시간이 소요되므로, 실시간으로 생성하면 경로 간에 약간의 지연이 발생할 수 있습니다. robot.dropServo()와 같은 함수는 Trajectory 실행 후 호출됩니다. 각 drive.followTrajectory() 함수는 동기적으로 실행되므로, 현재 Trajectory가 완료되기 전까지 다음 라인으로 진행되지 않습니다. Trajectory와 Turn의 차이점 SampleMecanumDrive.java 클래스는 turn() 함수를 지원하지만, 이 함수는 Road Runner의 핵심 기능이 아닙니다. 단순히 회전을 위한 모션 프로파일이며, Trajectory 내에서 호출할 수 없습니다.\ndrive.followTrajectory(traj1); drive.turn(Math.toRadians(90)); drive.followTrajectory(traj2); drive.turn(Math.toRadians(-270));\r후진하기 로봇을 후진시키고 싶다면, TrajectoryBuilder에서 간단히 설정할 수 있습니다.\nTrajectory trajectory = drive.trajectoryBuilder(new Pose2d(), true) .splineTo(new Vector2d(36, 36), Math.toRadians(0)) .build();\r위의 true는 로봇이 경로를 후진으로 따르도록 설정합니다.\nTurn 후 Trajectory 실행 drive.turn() 호출 후 Trajectory를 실행할 경우, 이전 Trajectory의 end() 값이 현재 Pose와 일치하지 않을 수 있습니다. 이를 해결하려면, 적절한 회전을 Trajectory 시작 Pose에 추가해야 합니다.\nTrajectory traj1 = drive.trajectoryBuilder(startPose, false) .forward(10) .build(); // 90도 회전을 traj1.end() Pose에 추가 Trajectory traj2 = drive.trajectoryBuilder(traj1.end().plus(new Pose2d(0, 0, Math.toRadians(90))), false) .strafeLeft(10); .build(); drive.followTrajectory(traj1); drive.turn(Math.toRadians(90)); drive.followTrajectory(traj2);\rTrajectory 속도 줄이기 Trajectory의 특정 구간에서 속도를 줄이고 싶다면 다음과 같이 설정합니다:\n.splineTo( new Vector2d(30, 30), Math.toRadians(90), SampleMecanumDrive.getVelocityConstraint(slowerVelocity, DriveConstants.MAX_ANG_VEL, DriveConstants.TRACK_WIDTH), SampleMecanumDrive.getAccelerationConstraint(DriveConstants.MAX_ACCEL) )\r좌표 시스템 FTC 좌표 시스템은 필드의 중심을 (0, 0)으로 설정합니다.\nX축: Red Alliance Station과 평행하며, 오른쪽으로 증가합니다. Y축: Red Alliance Station과 수직이며, 필드 안쪽으로 증가합니다. 아래 이미지는 2019/20 Skystone 필드의 좌표 시스템을 보여줍니다.\n2019/20 Skystone 필드 좌표 시스템\r이 좌표 시스템의 명세는 여기에서 확인할 수 있습니다.\n","date":"2023-09-07","id":15,"permalink":"/docs/5-trajectory/%EA%B0%9C%EC%9A%94/","summary":"\u003ch2 id=\"trajectory와-path의-차이점\"\u003eTrajectory와 Path의 차이점\u003c/h2\u003e\n\u003cp\u003eRoad Runner는 경로를 구성하기 위한 \u003cstrong\u003ePath\u003c/strong\u003e와 \u003cstrong\u003eTrajectory\u003c/strong\u003e 두 가지 데이터 구조를 제공합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ePaths\u003c/strong\u003e : 사용자가 정의한 웨이포인트를 기반으로 생성된 전체 경로를 단순히 저장합니다. 이 경로는 직선일 수도 있고, 부드러운 스플라인(splines)일 수도 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTrajectories\u003c/strong\u003e : Path에 \u003cstrong\u003e모션 프로파일링\u003c/strong\u003e을 추가한 구조입니다. 즉, Trajectories는 로봇이 경로를 따라가면서 속도, 가속도, 각가속도 등을 제어할 수 있도록 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e현재 Road Runner는 홀로노믹 드라이브(holonomic drive)를 위한 경로 추적(path following)을 기본 제공하지 않습니다.\n대신, 탱크 드라이브(tank drive)를 위한 Ramsete 경로 추적을 포함하고 있습니다.\u003cbr\u003e\n홀로노믹 드라이브를 지원하기 위해 벡터 필드 기반의 경로 추적 기능이 추가될 예정입니다.\n자세한 내용은 \u003ca href=\"https://discord.gg/first-tech-challenge\"\u003eFTC Discord\u003c/a\u003e를 참고하세요.\u003c/p\u003e","tags":[],"title":"개요"},{"content":"TrajectoryBuilder 함수 목록은 Road Runner에서 로봇 경로를 정의하고 커스터마이징하기 위한 다양한 메소드를 제공합니다. 아래는 주요 함수와 사용 사례의 요약입니다:\n기본 직선 이동 forward(distance: Double)\n로봇을 지정된 거리(인치)만큼 앞으로 이동시킵니다. 예시: new TrajectoryBuilder(new Pose2d()) .forward(40) .build();\rback(distance: Double)\n로봇을 지정된 거리(인치)만큼 뒤로 이동시킵니다. 예시: new TrajectoryBuilder(new Pose2d()) .back(40) .build();\r측면 이동 strafeLeft(distance: Double)\n로봇을 지정된 거리(인치)만큼 왼쪽으로 이동시킵니다. 예시: new TrajectoryBuilder(new Pose2d()) .strafeLeft(40) .build();\rstrafeRight(distance: Double)\n로봇을 지정된 거리(인치)만큼 오른쪽으로 이동시킵니다. 예시: new TrajectoryBuilder(new Pose2d()) .strafeRight(40) .build();\r지정된 좌표로 이동 strafeTo(endPosition: Vector2d)\n로봇이 지정된 좌표로 이동합니다. 이동 중 시작 시의 헤딩(방향)을 유지합니다. 예시: new TrajectoryBuilder(new Pose2d()) .strafeTo(new Vector2d(40, 40)) .build();\rlineTo(endPosition: Vector2d)\nstrafeTo와 동일하게 작동하며, 지정된 좌표로 이동하면서 시작 헤딩을 유지합니다. 예시: new TrajectoryBuilder(new Pose2d()) .lineTo(new Vector2d(40, 40)) .build();\rlineToConstantHeading(endPosition: Vector2d)\nstrafeTo 및 lineTo와 기능적으로 동일합니다. 지정된 좌표로 이동하며 시작 헤딩을 유지합니다. 예시: new TrajectoryBuilder(new Pose2d()) .lineToConstantHeading(new Vector2d(40, 40)) .build();\r방향(Heading)을 변경하며 이동 lineToLinearHeading(endPose: Pose2d)\n로봇이 지정된 좌표로 이동하며 시작 헤딩에서 끝 헤딩으로 선형적으로 변환합니다. 예시: new TrajectoryBuilder(new Pose2d()) .lineToLinearHeading(new Pose2d(40, 40, Math.toRadians(90))) .build();\rlineToSplineHeading(endPose: Pose2d)\n로봇이 지정된 좌표로 이동하며 시작 헤딩에서 끝 헤딩으로 곡선적으로 변환합니다. 예시: new TrajectoryBuilder(new Pose2d()) .lineToSplineHeading(new Pose2d(40, 40, Math.toRadians(90))) .build();\r스플라인 경로를 따라 이동 splineTo(endPosition: Vector2d, endTangent: Double)\n로봇이 스플라인 경로를 따라 지정된 좌표로 이동하며 끝 방향을 지정합니다. 예시: new TrajectoryBuilder(new Pose2d()) .splineTo(new Vector2d(40, 40), Math.toRadians(0)) .build();\rsplineToConstantHeading(endPosition: Vector2d, endTangent: Double)\n로봇이 스플라인 경로를 따라 이동하며 시작 헤딩을 유지합니다. 끝 방향은 스플라인 경로의 형태에 영향을 줍니다. 예시: new TrajectoryBuilder(new Pose2d()) .splineToConstantHeading(new Vector2d(40, 40), Math.toRadians(0)) .build();\rsplineToLinearHeading(endPose: Pose2d, endTangent: Double)\n로봇이 스플라인 경로를 따라 이동하며 헤딩은 선형적으로, 경로는 스플라인 형태로 변환됩니다. 예시: new TrajectoryBuilder(new Pose2d()) .splineToLinearHeading(new Pose2d(40, 40, Math.toRadians(90)), Math.toRadians(0)) .build();\rsplineToSplineHeading(endPose: Pose2d, endTangent: Double)\n로봇이 스플라인 경로를 따라 이동하며 헤딩과 경로 모두 곡선적으로 변환됩니다. 예시: new TrajectoryBuilder(new Pose2d()) .splineToSplineHeading(new Pose2d(40, 40, Math.toRadians(90)), Math.toRadians(0)) .build();\r위 함수들은 로봇의 경로를 정밀하게 제어할 수 있도록 설계되었습니다. 필요에 따라 직선, 곡선, 방향 전환 등을 조합하여 다양한 경로를 생성할 수 있습니다.\n","date":"2023-09-07","id":16,"permalink":"/docs/5-trajectory/trajectorybuilder-%ED%95%A8%EC%88%98-%EB%AA%A9%EB%A1%9D/","summary":"\u003cp\u003e\u003cstrong\u003eTrajectoryBuilder\u003c/strong\u003e 함수 목록은 Road Runner에서 로봇 경로를 정의하고\n커스터마이징하기 위한 다양한 메소드를 제공합니다.\n아래는 주요 함수와 사용 사례의 요약입니다:\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"기본-직선-이동\"\u003e\u003cstrong\u003e기본 직선 이동\u003c/strong\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eforward(distance: Double)\u003c/strong\u003e\u003c/p\u003e","tags":[],"title":"TrajectoryBuilder 함수 목록"},{"content":"Trajectory를 다룰 줄 알게 되었다면, 이제 로봇 대회에서 승리하기 위해 한 단계 더 나아가야 합니다. 물론 정확한 자율 주행만으로도 높은 점수에 가까워질 수 있지만, 단순히 로봇이 주행하는 것만으로는 충분하지 않습니다. 모터를 켜고, 서보를 작동시키고, 다양한 요소와 상호작용해야 합니다. 그렇다면 이는 어떻게 구현할 수 있을까요?\nRoad Runner는 **마커(Marker)**라는 편리한 기능을 제공합니다. 이를 통해 경로를 따라 동작을 실행할 수 있습니다.\n기본 마커 예제 Java\rKotlin\rdrive.trajectoryBuilder(new Pose2d()) .splineTo(new Vector2d(36, 36), Math.toRadians(0)) .addDisplacementMarker(() -\u0026gt; { // 여기에 동작을 실행하세요! // 서보를 내리거나 모터를 시작하는 등 }) .splineTo(new Vector2d(72, 0), Math.toRadians(0)) .build();\rdrive.trajectoryBuilder(Pose2d()) .splineTo(Vector2d(36.0, 36.0), Math.toRadians(0.0)) .addDisplacementMarker { // 여기에 동작을 실행하세요! // 서보를 내리거나 모터를 시작하는 등 } .splineTo(Vector2d(72.0, 0.0), Math.toRadians(0.0)) .build()\r마커의 종류 마커에는 세 가지 주요 유형이 있습니다:\nTemporal Markers (시간 기반 마커) Spatial Markers (공간 기반 마커) Displacement Markers (변위 기반 마커) 시간 기반 마커 (Temporal Markers) Java\rKotlin\rdrive.trajectoryBuilder(new Pose2d()) .splineTo(new Vector2d(36, 36), Math.toRadians(0)) .addTemporalMarker(2, () -\u0026gt; { // 이 마커는 Trajectory 시작 후 2초 뒤에 실행됩니다. // 여기에 동작을 실행하세요! }) .splineTo(new Vector2d(72, 0), Math.toRadians(0)) .build();\rdrive.trajectoryBuilder(Pose2d()) .splineTo(Vector2d(36.0, 36.0), Math.toRadians(0.0)) .addTemporalMarker(2.0) { // 이 마커는 Trajectory 시작 후 2초 뒤에 실행됩니다. // 여기에 동작을 실행하세요! } .splineTo(Vector2d(72.0, 0.0), Math.toRadians(0.0)) .build()\rTemporal Marker는 경로를 따라 시간을 기준으로 동작을 실행합니다.\n중요: Temporal Marker는 \u0026ldquo;전역(Global)\u0026ldquo;으로 평가됩니다. 즉, 마커가 경로 전체를 빌드한 후 평가되기 때문에 addTemporalMarker 호출 순서는 중요하지 않습니다.\njava\rKotlin\r// 아래 두 트라젝토리는 실행 결과가 동일합니다. // 마커 호출 순서와 관계없이 2초 뒤에 실행됩니다. drive.trajectoryBuilder(new Pose2d()) .splineTo(new Vector2d(36, 36), Math.toRadians(0)) .addTemporalMarker(2, () -\u0026gt; {}) .splineTo(new Vector2d(72, 0), Math.toRadians(0)) .build(); drive.trajectoryBuilder(new Pose2d()) .splineTo(new Vector2d(36, 36), Math.toRadians(0)) .splineTo(new Vector2d(72, 0), Math.toRadians(0)) .addTemporalMarker(2, () -\u0026gt; {}) .build();\r// 아래 두 트라젝토리는 실행 결과가 동일합니다. // 마커 호출 순서와 관계없이 2초 뒤에 실행됩니다. drive.trajectoryBuilder(Pose2d()) .splineTo(Vector2d(36.0, 36.0), Math.toRadians(0.0)) .addTemporalMarker(2.0) { } .splineTo(Vector2d(72.0, 0.0), Math.toRadians(0.0)) .build() drive.trajectoryBuilder(Pose2d()) .splineTo(Vector2d(36.0, 36.0), Math.toRadians(0.0)) .splineTo(Vector2d(72.0, 0.0), Math.toRadians(0.0)) .addTemporalMarker(2.0) { } .build()\r변위 기반 마커 (Displacement Markers) 변위 기반 마커는 두 가지 방식으로 사용할 수 있습니다.\n1. 인라인 변위 마커 (Inline Displacement Marker) Java\rkotlin\rdrive.trajectoryBuilder(new Pose2d()) .splineTo(new Vector2d(36, 36), Math.toRadians(0)) .addDisplacementMarker(() -\u0026gt; { // 이 마커는 첫 번째 splineTo() 이후 실행됩니다. // 여기에 동작을 실행하세요! }) .splineTo(new Vector2d(72, 0), Math.toRadians(0)) .build();\rdrive.trajectoryBuilder(Pose2d()) .splineTo(Vector2d(36.0, 36.0), Math.toRadians(0.0)) .addDisplacementMarker { // 이 마커는 첫 번째 splineTo() 이후 실행됩니다. // 여기에 동작을 실행하세요! } .splineTo(Vector2d(72.0, 0.0), Math.toRadians(0.0)) .build()\r특징:\n인라인 마커는 순서가 중요합니다. 이전 명령이 완료된 후 바로 실행됩니다. 특정 트라젝토리 세그먼트 이후 빠르게 동작을 실행하려면 유용합니다. 2. 전역 변위 마커 (Global Displacement Marker) Java\rkotlin\rdrive.trajectoryBuilder(new Pose2d()) .splineTo(new Vector2d(36, 36), Math.toRadians(0)) .addDisplacementMarker(20, () -\u0026gt; { // 이 마커는 경로에서 20인치 이동한 후 실행됩니다. // 여기에 동작을 실행하세요! }) .splineTo(new Vector2d(72, 0), Math.toRadians(0)) .build();\rdrive.trajectoryBuilder(Pose2d()) .splineTo(Vector2d(36.0, 36.0), Math.toRadians(0.0)) .addDisplacementMarker(20.0) { // 이 마커는 경로에서 20인치 이동한 후 실행됩니다. // 여기에 동작을 실행하세요! } .splineTo(Vector2d(72.0, 0.0), Math.toRadians(0.0)) .build()\r특징:\n변위를 기준으로 동작을 실행합니다. Temporal Marker와 마찬가지로 \u0026ldquo;전역(Global)\u0026ldquo;으로 평가됩니다. 호출 순서와 관계없이 지정된 변위 이후 실행됩니다. java\rkotlin\r// 아래 두 트라젝토리는 실행 결과가 동일합니다. // 마커 호출 순서와 관계없이 20인치 이동 후 실행됩니다. drive.trajectoryBuilder(new Pose2d()) .splineTo(new Vector2d(36, 36), Math.toRadians(0)) .addDisplacementMarker(20, () -\u0026gt; {}) .splineTo(new Vector2d(72, 0), Math.toRadians(0)) .build(); drive.trajectoryBuilder(new Pose2d()) .splineTo(new Vector2d(36, 36), Math.toRadians(0)) .splineTo(new Vector2d(72, 0), Math.toRadians(0)) .addDisplacementMarker(20, () -\u0026gt; {}) .build();\r// 아래 두 트라젝토리는 실행 결과가 동일합니다. // 마커 호출 순서와 관계없이 20인치 이동 후 실행됩니다. drive.trajectoryBuilder(Pose2d()) .splineTo(Vector2d(36.0, 36.0), Math.toRadians(0.0)) .addDisplacementMarker(20.0) { } .splineTo(Vector2d(72.0, 0.0), Math.toRadians(0.0)) .build() drive.trajectoryBuilder(Pose2d()) .splineTo(Vector2d(36.0, 36.0), Math.toRadians(0.0)) .splineTo(Vector2d(72.0, 0.0), Math.toRadians(0.0)) .addDisplacementMarker(20.0) { } .build()\r공간 마커 (Spatial Marker) Java\rKotlin\rdrive.trajectoryBuilder(new Pose2d()) .splineTo(new Vector2d(36, 36), Math.toRadians(0)) .addSpatialMarker(new Vector2d(20, 20), () -\u0026gt; { // 이 마커는 (20, 20) 좌표에 가장 가까운 지점에서 실행됩니다. // 여기에 동작을 추가하세요! }) .splineTo(new Vector2d(72, 0), Math.toRadians(0)) .build(); drive.trajectoryBuilder(Pose2d()) .splineTo(Vector2d(36.0, 36.0), Math.toRadians(0.0)) .addSpatialMarker(Vector2d(20.0, 20.0)) { // 이 마커는 (20, 20) 좌표에 가장 가까운 지점에서 실행됩니다. // 여기에 동작을 추가하세요! } .splineTo(Vector2d(72.0, 0.0), Math.toRadians(0.0)) .build() 공간 마커는 지정된 좌표를 기준으로 동작을 실행할 수 있도록 합니다. 하지만 Road Runner는 사용자가 지정한 좌표를 경로에 투영(projection)하기 때문에 동작이 실행되는 위치가 약간 예측 불가능할 수 있습니다. 즉, 경로 상에서 지정된 좌표에 가장 가까운 지점에서 실행됩니다. 개인적으로는 공간 마커가 명확하지 않기 때문에 사용하는 것을 권장하지 않습니다.\n경로에 투영된 공간 마커\r유의해야 할 사항 모든 마커는 시간 기반 마커 변위 마커(displacement marker)와 공간 마커(spatial marker)는 경로가 빌드될 때 내부적으로 시간 기반 마커로 변환됩니다. 이는 Road Runner가 이러한 마커를 타이머를 기반으로 실행한다는 것을 의미합니다. 경로 추적(path following)이 정확하다면 이러한 방식은 꽤 신뢰할 만합니다. 그러나 경로 추적이 부정확하다면 마커 호출이 지연될 수 있습니다.\n따라서 현재로서는 시간 기반이 아닌 경로 기반 마커는 존재하지 않습니다.\n마커에서 sleep()을 사용하지 마세요! 기본 Linear OpMode에서 sleep()을 사용해 동작 간 대기 시간을 설정했을 수 있습니다. 예를 들어, 서보를 떨어뜨리는데 0.5초가 걸리고, 다음 동작을 0.5초 후에 호출하고 싶다고 가정해 봅시다. 또는 모터를 1초 동안 켜고 이후 꺼야 할 경우, 다음과 같이 작성할 수 있습니다:\nJava\rKotlin\r// 이런 방식은 사용하지 마세요! drive.trajectoryBuilder(new Pose2d()) .splineTo(new Vector2d(36, 36), Math.toRadians(0)) .splineTo(new Vector2d(72, 0), Math.toRadians(0)) .addDisplacementMarker(10, () -\u0026gt; { // 모터를 켜고 80% 출력으로 설정 motor1.setPower(0.8); // 1500ms 대기 sleep(1500); // 모터 끄기 motor1.setPower(0); }) .build(); // 이런 방식은 사용하지 마세요! drive.trajectoryBuilder(Pose2d()) .splineTo(Vector2d(36.0, 36.0), Math.toRadians(0.0)) .splineTo(Vector2d(72.0, 0.0), Math.toRadians(0.0)) .addDisplacementMarker(10.0) { // 모터를 켜고 80% 출력으로 설정 motor1.power = 0.8 // 1500ms 대기 sleep(1500.0) // 모터 끄기 motor1.power = 0.0 } .build() 이러한 방식은 좋지 않습니다. sleep() 함수는 전체 스레드를 멈추게 합니다. 즉, 코드가 1.5초 동안 \u0026ldquo;정지\u0026quot;됩니다. 이 동안 로봇은 속도나 드라이브 트레인을 백그라운드에서 조정할 수 없으며 모션 프로파일이 무너질 수 있습니다.\n대신, 두 개의 시간 기반 마커를 체이닝하거나 여러 변위 마커를 세밀하게 조정하는 방식을 권장합니다.\nJava\rKotlin\rdrive.trajectoryBuilder(new Pose2d()) .splineTo(new Vector2d(36, 36), Math.toRadians(0)) .splineTo(new Vector2d(72, 0), Math.toRadians(0)) .addTemporalMarker(1, () -\u0026gt; { // 경로 시작 1초 후 실행 // 모터를 켜고 80% 출력으로 설정 motor1.setPower(0.8); }) .addTemporalMarker(2.5, () -\u0026gt; { // 경로 시작 2.5초 후 실행 (이전 마커에서 1.5초 후) // 모터 끄기 motor1.setPower(0); }) .build(); drive.trajectoryBuilder(Pose2d()) .splineTo(Vector2d(36.0, 36.0), Math.toRadians(0.0)) .splineTo(Vector2d(72.0, 0.0), Math.toRadians(0.0)) .addTemporalMarker(1.0) { // 경로 시작 1초 후 실행 // 모터를 켜고 80% 출력으로 설정 motor1.power = 0.8 } .addTemporalMarker(2.5) { // 경로 시작 2.5초 후 실행 (이전 마커에서 1.5초 후) // 모터 끄기 motor1.power = 0 } .build() 고급 설정 시간 기반 마커 : 람다 매개변수 Java\rKotlin\raddTemporalMarker(pathTime -\u0026gt; pathTime * 0.3, () -\u0026gt; { // 경로의 30% 지점에서 실행됩니다. }) addTemporalMarker({ pathTime -\u0026gt; pathTime * 0.3 }) { // 경로의 30% 지점에서 실행됩니다. } 첫 번째 매개변수는 경로의 전체 시간을 제공하는 콜백 함수입니다. 이를 통해 경로에 대한 명확한 제어를 할 수 있습니다. 원하는 값을 반환할 수 있으며, 나머지 시간 기반 마커는 이 함수에 기반을 둡니다. 이 기능을 사용하는 것은 권장되지 않지만, 필요할 경우 사용할 수 있도록 제공됩니다.\n변위 기반 마커 : 비율(Scale)과 오프셋(Offset) addDisplacementMarker(scale: Double, offset: Double, callback: MarkerCallback) 변위 기반 마커는 비율(Scale)과 오프셋(Offset)을 사용할 수 있습니다.\n비율(Scale): 0에서 1까지의 값을 사용하며, 이는 경로 전체 변위의 비율을 나타냅니다. 오프셋(Offset): 미세한 타이밍 조정을 위해 사용할 임의의 숫자입니다. Java\rKotlin\r.addDisplacementMarker(0.5, 2.1, () -\u0026gt; { // 이 예제는 경로의 50% 지점에서 실행되며, 추가로 2.1 인치 이동 후 실행됩니다. // 오프셋은 0으로 둘 수 있지만, 타이밍을 미세하게 조정하는 데 유용합니다. }) .addDisplacementMarker(0.5, 2.1) { // 이 예제는 경로의 50% 지점에서 실행되며, 추가로 2.1 인치 이동 후 실행됩니다. // 오프셋은 0으로 둘 수 있지만, 타이밍을 미세하게 조정하는 데 유용합니다. } 변위 기반 마커 : 람다 매개변수 Java\rKotlin\r.addDisplacementMarker(pathLength -\u0026gt; pathLength * 0.3, () -\u0026gt; { // 경로의 30% 지점에서 실행됩니다. }) .addDisplacementMarker({ pathLength -\u0026gt; pathLength * 0.3 }) { // 경로의 30% 지점에서 실행됩니다. } 첫 번째 매개변수는 경로의 전체 길이를 제공하는 콜백 함수입니다. 이를 통해 경로에 대한 명확한 제어를 할 수 있습니다. 원하는 값을 반환할 수 있으며, 나머지 변위 기반 마커는 이 함수에 기반을 둡니다. 이 기능을 사용하는 것은 권장되지 않지만, 필요할 경우 사용할 수 있도록 제공됩니다.\n","date":"2023-09-07","id":17,"permalink":"/docs/5-trajectory/%EB%A7%88%EC%BB%A4-maker-%EA%B0%80%EC%9D%B4%EB%93%9C/","summary":"\u003cp\u003eTrajectory를 다룰 줄 알게 되었다면, 이제 로봇 대회에서 승리하기 위해 한 단계 더 나아가야 합니다.\n물론 정확한 자율 주행만으로도 높은 점수에 가까워질 수 있지만,\n단순히 로봇이 주행하는 것만으로는 충분하지 않습니다.\n모터를 켜고, 서보를 작동시키고, 다양한 요소와 상호작용해야 합니다. 그렇다면 이는 어떻게 구현할 수 있을까요?\u003c/p\u003e","tags":[],"title":"마커 (Maker) 가이드"},{"content":"2021년 5월 6일 기준, Road Runner quickstart에는 \u0026ldquo;trajectory sequences\u0026quot;라는 유틸리티가 포함되어 있습니다.\n경로 서열(Trajectory Sequences)는 여러 경로를 하나로 이어붙이며, 자동으로 경로 연속성 예외를 처리합니다. 또한, 회전(Turn) 및 대기(Wait)를 \u0026ldquo;1급(First-class)\u0026rdquo; 동작으로 전환합니다(최소한 Quickstart 내에서는). 이를 통해 여러 개의 서로 다른 Trajectory로 나누지 않고 하나의 경로 서열로 전체 자율 주행 경로를 실행할 수 있습니다.\n이제 마커(marker)는 경로(Trajectory), 대기(Wait), 회전(Turn) 동작 어디에나 삽입될 수 있습니다. 이를 통해 비동기(Async)나 동시(Concurrent) 코드를 작성하지 않고도 대기와 회전 동작 중에 작업을 실행할 수 있습니다. 하지만 이는 간단한 작업에만 권장됩니다. 더 복잡한 작업은 여전히 동시 유한 상태 기계(Concurrent Finite State Machines)와 같은 방법으로 처리해야 합니다.\n보너스로, 경로 서열은 더 고급 대시보드 필드 드로잉 기능도 제공합니다!\n다음은 경로 서열의 개선 사항을 보여주는 단순한 예제입니다.\n경로 서열 사용 전 public class WorldChampionshipAuto extends LinearOpMode { @Override public void runOpMode() throws InterruptedException { SampleMecanumDrive drive = new SampleMecanumDrive(hardwareMap); Pose2d startPose = new Pose2d(0, 0, 0); ElapsedTime timer = new ElapsedTime(); drive.setPoseEstimate(startPose); Trajectory traj1 = drive.trajectoryBuilder(startPose) .splineTo(new Vector2d(10, 10), 0) .build(); Trajectory traj2 = drive.trajectoryBuilder(startPose) .splineTo(new Vector2d(25, -15), 0) .build(); Trajectory traj3 = drive.trajectoryBuilder(startPose) .forward(10) .build(); // strafeRight(10)은 PathContinuityException을 발생시키므로 traj3에 포함할 수 없음 Trajectory traj4 = drive.trajectoryBuilder(startPose) .strafeRight(5) .build(); Trajectory traj5 = drive.trajectoryBuilder(startPose) .strafeRight(5) .build(); Trajectory traj6 = drive.trajectoryBuilder(startPose) .splineToLinearHeading(new Pose2d(-10, -10, Math.toRadians(45)), 0) .build(); waitForStart(); if (isStopRequested()) return; drive.followTrajectory(traj1); drive.turn(Math.toRadians(90)); drive.followTrajectory(traj2); timer.reset(); while(timer.seconds() \u0026lt; 3) drive.update(); drive.turn(Math.toRadians(45)); drive.followTrajectory(traj3); drive.followTrajectory(traj4); drive.turn(Math.toRadians(90)); drive.followTrajectory(traj5); timer.reset(); while(timer.seconds() \u0026lt; 1) drive.update(); drive.followTrajectory(traj6); } }\r경로 서열 사용 후 public class WorldChampionshipAuto extends LinearOpMode { @Override public void runOpMode() throws InterruptedException { SampleMecanumDrive drive = new SampleMecanumDrive(hardwareMap); Pose2d startPose = new Pose2d(0, 0, 0); drive.setPoseEstimate(startPose); TrajectorySequence trajSeq = drive.trajectorySequenceBuilder(startPose) .splineTo(new Vector2d(10, 10), 0) .turn(Math.toRadians(90)) .splineTo(new Vector2d(25, -15), 0) .waitSeconds(3) .turn(Math.toRadians(45)) .forward(10) .strafeRight(5) .turn(Math.toRadians(90)) .strafeLeft(5) .waitSeconds(1) .splineToLinearHeading(new Pose2d(-10, -10, Math.toRadians(45)), 0) .build(); waitForStart(); if (!isStopRequested()) drive.followTrajectorySequence(trajSeq); } }\r개요 경로 서열의 내부 작동 방식은 간단합니다. TrajectorySequenceBuilder는 연속적으로 Trajectory를 생성하며 PathContinuityException을 처리합니다. 새로운 세그먼트를 생성하고 가장 최근의 세그먼트에서 시작하여 빌드합니다.\n하지만 이것이 연속성 예외 문제를 해결해 주지는 않습니다. 경로가 연속적이지 않으면 여전히 감속합니다. 이를 염두에 두고 작업해야 합니다. 빠르게 복습이 필요하다면 이곳을 확인하세요.\n기본적인 Trajectory 연결은 단순히 Trajectory를 체이닝(chaining)하기 위한 문법적 편의(Syntactic Sugar)일 뿐입니다. 아래와 같은 간단한 큐(Queue)로 이를 구현할 수 있습니다:\nQueue\u0026lt;Trajectory\u0026gt; trajectoryQueue; trajectoryQueue.add(trajectory1); trajectoryQueue.add(trajectory2); trajectoryQueue.add(trajectory3); trajectoryQueue.add(trajectory4); while(!trajectoryQueue.isEmpty()) { drive.followTrajectory(trajectoryQueue.poll()); }\r이렇게 자체 경로 서열을 만들었습니다. 하지만 이것에는 무엇이 부족할까요? 자동 연결, 대기, 회전, 그리고 이러한 동작 안에 포함된 마커 같은 모든 멋진 기능이 빠져 있습니다. 이를 확인해 봅시다.\nTrajectorySequence에 익숙해졌다면 MeepMeep을 확인하여 경로를 생성하고 시각화해 보세요!\nTrajectoryBuilder의 모든 기능 TrajectorySequenceBuilder는 TrajectoryBuilder API의 모든 기능을 지원합니다. 더 많은 세부 사항과 시각적 예시를 원하신다면 TrajectoryBuilder 함수 목록을 참조하세요.\n.turn(radians) TrajectorySequenceBuilder는 일반적인 Road Runner의 회전 기능을 사용합니다. 이 구현은 TrajectorySequenceRunner 파일의 140-164번째 줄에 있습니다. 이는 이전에 SampleMecanumDrive에 있던 구현과 동일합니다. 이 회전 기능은 비교적 단순한 방식으로 구현되었으며, 필요하다면 타임아웃 또는 정적 피드포워드(Static Feedforward)와 같은 추가 로직으로 보완할 수 있습니다. 이러한 개선 사항은 표준화되지 않았으며, 기본 Quickstart에 병합되지 않았습니다. 더 나은 구현을 갖고 있다면 Quickstart에 Pull Request를 제안할 수 있습니다. 모든 로직이 Quickstart 측에서 처리되므로 사용자가 필요에 따라 수정할 수 있습니다.\n회전 예시 코드:\nTrajectorySequence ts = drive.trajectorySequenceBuilder(startPose) .turn(Math.toRadians(45)) // 반시계 방향으로 45도 회전 .build(); drive.followTrajectorySequence(ts);\r.waitSeconds(seconds) TrajectorySequenceBuilder는 간단한 대기 구간을 추가하는 기능을 제공합니다. 이를 통해 트라젝토리 사이에 작업을 실행할 수 있습니다. 이 대기 구간에도 마커를 삽입할 수 있습니다.\nTrajectorySequence ts = drive.trajectorySequenceBuilder(startPose) .waitSeconds(3) // 3초 동안 대기 .build();\r주의\nwaitSeconds()를 사용해야 하며, Java 객체의 기본 wait() 메서드를 혼동하지 않도록 주의하세요. wait()는 현재 스레드가 다른 스레드에 의해 notify() 또는 notifyAll()이 호출될 때까지 대기합니다. 자세한 내용은 Oracle JavaDoc을 참조하세요. IntelliSense에서 wait()가 표시되더라도, 반드시 waitSeconds()를 사용해야 합니다.\nSequenceBuilder 고유의 마커 기능 TrajectorySequenceBuilder는 기존의 Trajectory에 사용되는 표준 마커들을 모두 지원합니다. 자세한 내용은 여기를 참조하세요. 추가로, TrajectorySequenceBuilder는 몇 가지 고유 마커를 제공합니다. 이를 통해 마커가 더 강력하고 유연하게 작동합니다.\n.addTemporalMarker(MarkerCallback) addTemporalMarker(MarkerCallback)는 TrajectoryBuilder에서는 존재하지 않습니다. 기본 Trajectory에서는 이 기능이 .addDisplacementMarker(MarkerCallback)와 동일한 역할을 하기 때문입니다. 하지만 TrajectorySequence에서는 이동 거리와 지속 시간이 다르기 때문에 addTemporalMarker(MarkerCallback)가 더 선호됩니다. 이동 거리는 회전 및 대기 구간 동안 증가하지 않지만, 지속 시간은 증가하기 때문입니다. 이 차이를 이해하지 못하면 혼란을 초래할 수 있습니다. 내부 동작 방식에 대한 시각적 설명은 이 비디오를 참고하세요.\n.UNSTABLE_addTemporalMarkerOffset(offset, MarkerCallback) 이 함수는 현재 시간에 offset을 추가하여 마커를 설정합니다. .addTemporalMarker(double, MarkerCallback)와의 차이점은, 해당 함수가 Trajectory 전체의 시간 기준으로 작동하는 반면, .UNSTABLE_addTemporalMarkerOffset(offset, MarkerCallback)는 호출된 지점부터의 상대적인 시간 기준으로 작동한다는 점입니다.\n// 예제 1 drive.trajectorySequenceBuilder(startPose) .splineTo(new Vector2d(10, 10), 0) .addTemporalMarker(3, () -\u0026gt; {}) .strafeRight(15) .turn(Math.toRadians(90)) .build(); // 예제 2 drive.trajectorySequenceBuilder(startPose) .splineTo(new Vector2d(10, 10), 0) .UNSTABLE_addTemporalMarkerOffset(3, () -\u0026gt; {}) .strafeRight(15) .turn(Math.toRadians(90)) .build();\r예제 1: 마커는 Trajectory 전체에서 3초 후 실행됩니다. 예제 2: 마커는 splineTo() 실행 이후 3초 후에 실행됩니다. 주의\n이 메서드는 UNSTABLE로 표시되며, 향후 릴리스에서 변경될 수 있습니다.\n.UNSTABLE_addDisplacementMarkerOffset(offset, MarkerCallback) 이 함수는 현재 이동 거리에 offset을 추가하여 마커를 설정합니다. .addDisplacementMarker(double, MarkerCallback)와의 차이점은, 해당 함수가 Trajectory 전체의 이동 거리 기준으로 작동하는 반면, .UNSTABLE_addDisplacementMarkerOffset(offset, MarkerCallback)는 호출된 지점부터의 상대적인 이동 거리 기준으로 작동한다는 점입니다.\n// 예제 1 drive.trajectorySequenceBuilder(startPose) .splineTo(new Vector2d(10, 10), 0) .addDisplacementMarker(3, () -\u0026gt; {}) .strafeRight(15) .turn(Math.toRadians(90)) .build(); // 예제 2 drive.trajectorySequenceBuilder(startPose) .splineTo(new Vector2d(10, 10), 0) .UNSTABLE_addDisplacementMarkerOffset(3, () -\u0026gt; {}) .strafeRight(15) .turn(Math.toRadians(90)) .build();\r예제 1: 마커는 Trajectory 전체에서 3인치 이동 후 실행됩니다. 예제 2: 마커는 splineTo() 실행 이후 3인치 이동 후 실행됩니다. 주의\n이 메서드는 UNSTABLE로 표시되며, 향후 릴리스에서 변경될 수 있습니다.\n알겠습니다! 아래는 요청하신 내용을 한국어로 정확히 번역한 것입니다:\n마커 사용 예시 상대적인 오프셋을 구현할 수 있는 기능은 전체 자동화 로직을 경로 서열 안에 통합할 수 있게 해주는 강력한 기능입니다. 기존 Trajectory에서는 메커니즘 로직이 Trajectory와 완전히 분리되어 있었으며, Trajectory를 따르는 동안 별도로 처리해야 했습니다. 또는 더 복잡한 동작을 위해 상태 머신(State Machine) 같은 동시 실행 스케줄링을 사용하는 것이 일반적이었습니다. 복잡한 동작에는 여전히 상태 머신 사용이 선호되지만, Trajectory Sequence는 이를 훨씬 쉽게 호출할 수 있도록 해줍니다. 기본적인 코드 예시를 살펴보겠습니다.\n간단한 예제: 앞으로 이동 → 서보 내리기 → 대기 → 서보 올리기 → 옆으로 이동 다음은 이 동작을 구현하는 코드입니다:\nTrajectorySequence trajSeq = drive.trajectorySequenceBuilder(startPose) .forward(10) .addTemporalMarker(() -\u0026gt; servo.setPosition(0)) // 서보 내리기 .waitSeconds(3) .addTemporalMarker(() -\u0026gt; servo.setPosition(1)) // 서보 올리기 .strafeRight(5) .build();\r이 코드만 보면 기존의 Trajectory로도 충분히 구현할 수 있었으며, 조금 더 복잡하지만 크게 어렵지는 않았습니다. 하지만 경로 서열을 사용하면 코드가 훨씬 간결하고 읽기 쉬워졌습니다.\n더 복잡한 예제: 동작의 타이밍 조정 이번에는 같은 동작을 수행하지만, 서보를 내리는 동작이 Trajectory가 끝나기 전에 시작되도록 하고, 서보를 올리는 동작이 대기 시간이 끝나기 조금 전에 시작되도록 만들어 보겠습니다. 이를 통해 서보가 이미 위치를 잡은 상태에서 다음 이동을 시작할 수 있습니다.\nTrajectorySequence trajSeq = drive.trajectorySequenceBuilder(startPose) .forward(10) .UNSTABLE_addTemporalMarkerOffset(-0.5, () -\u0026gt; servo.setPosition(0)) // Trajectory 끝나기 0.5초 전에 서보 내리기 .waitSeconds(3) .UNSTABLE_addTemporalMarkerOffset(-0.3, () -\u0026gt; servo.setPosition(1)) // 대기 시간이 끝나기 0.3초 전에 서보 올리기 .strafeRight(5) .build();\r위 코드에서 첫 번째 마커는 forward() Trajectory의 끝에서 0.5초 전에 실행됩니다. 두 번째 마커는 waitSeconds()가 끝나기 0.3초 전에 실행됩니다. 이와 같은 타이밍 조정을 통해 동작을 더 매끄럽게 만들 수 있습니다.\n서보를 여러 번 작동시키기 이번에는 앞으로 이동 → 대기 → 오른쪽으로 이동하는 동작 중, 대기 시간 동안 서보를 두 번 작동(총 4번의 서보 동작: 내리기, 올리기, 내리기, 올리기)시키는 코드를 작성해 보겠습니다.\nTrajectorySequence trajSeq = drive.trajectorySequenceBuilder(startPose) .forward(10) .UNSTABLE_addTemporalMarkerOffset(0, () -\u0026gt; servo.setPosition(0)) // 서보 내리기 .UNSTABLE_addTemporalMarkerOffset(0.5, () -\u0026gt; servo.setPosition(1)) // 서보 올리기 .UNSTABLE_addTemporalMarkerOffset(1, () -\u0026gt; servo.setPosition(0)) // 서보 내리기 .UNSTABLE_addTemporalMarkerOffset(1.5, () -\u0026gt; servo.setPosition(1)) // 서보 올리기 .waitSeconds(2) // 마커는 waitSeconds() 전에 선언해야 함 .strafeRight(5) .build();\r첫 번째 마커는 waitSeconds()가 시작되자마자 실행됩니다. 두 번째 마커는 대기 시간 0.5초 후에 실행됩니다. 세 번째 마커는 대기 시간 1초 후에 실행됩니다. 네 번째 마커는 대기 시간 1.5초 후에 실행됩니다. 중요: 마커는 waitSeconds() 전에 선언해야 합니다. waitSeconds() 후에 마커를 선언하면, 마커는 strafeRight() 동안 실행됩니다. 또는 음수 오프셋을 사용해 동일한 결과를 얻을 수도 있습니다. 다음 코드는 위와 동일한 동작을 수행합니다:\ndouble waitTime = 2; TrajectorySequence trajSeq = drive.trajectorySequenceBuilder(startPose) .forward(10) .waitSeconds(waitTime) // 이제 마커가 waitSeconds() 뒤에 배치됨 .UNSTABLE_addTemporalMarkerOffset(-waitTime, () -\u0026gt; servo.setPosition(0)) // 서보 내리기 .UNSTABLE_addTemporalMarkerOffset(-waitTime + 0.5, () -\u0026gt; servo.setPosition(1)) // 서보 올리기 .UNSTABLE_addTemporalMarkerOffset(-waitTime + 1, () -\u0026gt; servo.setPosition(0)) // 서보 내리기 .UNSTABLE_addTemporalMarkerOffset(-waitTime + 1.5, () -\u0026gt; servo.setPosition(1)) // 서보 올리기 .strafeRight(5) .build();\r이 방식에서는 마커를 waitSeconds() 뒤에 배치하지만, 음수 오프셋을 사용해 대기 시간 초반으로 상대적인 타이밍을 설정합니다.\n주의\n복잡한 순차 코드는 여전히 상태 머신(State Machine) 또는 기타 동시 실행 코드에서 처리하는 것이 권장됩니다.\n기타 유용한 메서드 .setTangent(double) 지정된 헤딩 접선에서 Trajectory를 시작하도록 설정합니다. 이는 TrajectoryBuilder() 생성자에서 커스텀 접선을 지정하는 것과 동일합니다.\n.setReversed(boolean) Trajectory를 후진 상태에서 실행하도록 설정합니다. true로 설정하면 로봇이 뒤로 이동합니다.\n.setConstraints(TrajectoryVelocityConstraint, TrajectoryAccelerationConstraint) 일시적으로 속도 및 가속도 제약 조건을 재정의하여 Trajectory의 특정 구간을 빠르거나 느리게 설정할 수 있습니다.\n.resetConstraints() setConstraints()로 설정된 임시 제약 조건을 초기화합니다. 기본 제약 조건이 다시 사용됩니다.\n.setVelConstraint(TrajectoryVelocityConstraint) 일시적으로 속도 제약 조건만 설정합니다.\n.resetVelConstraint() 임시 속도 제약 조건을 초기화합니다.\n.setAccelConstraint(TrajectoryAccelerationConstraint) 일시적으로 가속도 제약 조건만 설정합니다.\n.resetAccelConstraint() 임시 가속도 제약 조건을 초기화합니다.\n.setTurnConstraint(maxAngVel, maxAngAccel) 회전에 사용할 최대 각속도 및 각가속도를 설정합니다.\n.resetTurnConstraint() 임시 회전 제약 조건을 초기화합니다.\n.addTrajectory(Trajectory) 새 Trajectory를 경로 서열에 추가합니다.\n","date":"2023-09-07","id":18,"permalink":"/docs/5-trajectory/%EA%B2%BD%EB%A1%9C-%EC%84%9C%EC%97%B4-%EC%A0%95%ED%95%98%EA%B8%B0-trajectory-sequence/","summary":"\u003cp\u003e2021년 5월 6일 기준,\n\u003ca href=\"https://github.com/acmerobotics/road-runner-quickstart/tree/quickstart1\"\u003eRoad Runner quickstart\u003c/a\u003e에는\n\u0026ldquo;trajectory sequences\u0026quot;라는 유틸리티가 포함되어 있습니다.\u003c/p\u003e\n\u003cp\u003e경로 서열(Trajectory Sequences)는 여러 경로를 하나로 이어붙이며,\n자동으로 \u003ca href=\"/trajectories.html#path-continuity-exception\"\u003e경로 연속성 예외\u003c/a\u003e를 처리합니다.\n또한, 회전(Turn) 및 대기(Wait)를 \u0026ldquo;1급(First-class)\u0026rdquo; 동작으로 전환합니다(최소한 Quickstart 내에서는).\n이를 통해 여러 개의 서로 다른 Trajectory로 나누지 않고 하나의 경로 서열로 전체 자율 주행 경로를 실행할 수 있습니다.\u003c/p\u003e","tags":[],"title":"경로 서열 정하기 (Trajectory Sequence)"},{"content":"고급 코드 샘플은 advanced-examples 브랜치에서 확인할 수 있습니다.\nhttps://github.com/NoahBres/road-runner-quickstart/tree/advanced-examples\nTeleOp에서 Road Runner 사용하기 TeleOp에서 Road Runner를 사용하는 데는 여러 이유가 있습니다.\n예를 들어, 복잡한 자동화를 구현하고 싶을 수도 있습니다.\n개인적으로는 텔레오프 자동화보다는 드라이브 연습에 투자하는 것이 훨씬 더 효율적이라고 생각합니다.\n하지만, 원한다면 자유롭게 사용해 보세요.\nTeleOp에서 Road Runner를 사용하는 주요 이유는 로컬라이제이션(localization) 기능을 재사용해 텔레오프 중 로봇의 위치를 실시간으로 추적하는 것입니다.\n이 기능은 예를 들어 2020-21 Ultimate Goal 게임에서 링 슈터 속도를 자동 조정하는 데 활용할 수 있습니다.\n텔레오프 자동화와 관련하여 제가 추천하지 않는 것은 로봇이 자동으로 특정 위치로 이동해 작업을 수행하는 방식입니다. 숙련된 드라이버가 연습을 통해 더 빠르고 정확하게 수행할 수 있습니다.\n하지만 특정 물리적 메커니즘(예: 인테이킹, 리프트)을 자동화하는 것은 매우 추천합니다.\n로컬라이저(Localizer)만 사용하는 방법 로컬라이저를 사용해 로봇의 위치를 읽기만 하면 되는 경우, 불필요한 코드를 호출하지 않도록 로컬라이저만 초기화하는 것을 추천합니다.\n로컬라이저 사용 코드 예제 다음은 텔레오프 OpMode에서 로컬라이저를 사용하는 코드입니다:\npublic class MyTeleopOpmode extends LinearOpMode { public void runOpMode() { // 초기화 코드 삽입 // StandardTrackingWheelLocalizer 사용 StandardTrackingWheelLocalizer myLocalizer = new StandardTrackingWheelLocalizer(hardwareMap); // 초기 위치 설정 (x: 10, y: 10, 방향: 90도) myLocalizer.setPoseEstimate(new Pose2d(10, 10, Math.toRadians(90))); waitForStart(); while (opModeIsActive()) { // 반복 루프에서 항상 update() 호출 myLocalizer.update(); // 현재 위치 가져오기 Pose2d myPose = myLocalizer.getPoseEstimate(); telemetry.addData(\u0026#34;x\u0026#34;, myPose.getX()); telemetry.addData(\u0026#34;y\u0026#34;, myPose.getY()); telemetry.addData(\u0026#34;heading\u0026#34;, myPose.getHeading()); // TeleOp 코드 삽입 } } }\r완전한 샘플 코드 전체 샘플 코드는 여기에서 확인할 수 있습니다.\n이 샘플에는 아래에서 설명할 정적 필드를 활용한 데이터 유지(persistence) 기능도 포함되어 있습니다.\nSampleMecanumDrive 사용하기 SampleMecanumDrive의 기능을 활용하고 싶다면, 다음과 같은 방식으로 TeleOp에 추가할 수 있습니다.\nSampleMecanumDrive 사용 코드 예제 public class MyTeleopOpmode extends LinearOpMode { public void runOpMode() { // 초기화 코드 삽입 // SampleMecanumDrive 사용 SampleMecanumDrive drive = new SampleMecanumDrive(hardwareMap); // 초기 위치 설정 (x: 10, y: 10, 방향: 90도) drive.setPoseEstimate(new Pose2d(10, 10, Math.toRadians(90))); waitForStart(); while (opModeIsActive()) { // 반복 루프에서 항상 update() 호출 drive.update(); // 현재 위치 가져오기 Pose2d myPose = drive.getPoseEstimate(); telemetry.addData(\u0026#34;x\u0026#34;, myPose.getX()); telemetry.addData(\u0026#34;y\u0026#34;, myPose.getY()); telemetry.addData(\u0026#34;heading\u0026#34;, myPose.getHeading()); // 텔레오프 코드 삽입 } } }\r완전한 샘플 코드 전체 샘플 코드는 여기에서 확인할 수 있습니다.\n이 샘플은 정적 필드 데이터 유지 기능을 포함하며, SampleMecanumDrive를 활용해 게임패드를 통한 로봇 제어를 추가한 코드입니다.\nOpMode 간 위치 데이터 전송 이유 텔레오프에서 로컬라이저를 활용하려면 초기 위치를 정확히 설정해야 합니다.\n초기 위치를 설정하지 않으면 프로그램은 기본적으로 x: 0, y: 0, heading: 0으로 간주합니다.\n따라서, 자동 모드에서 끝난 위치를 텔레오프에 전달해야 합니다.\n이 작업은 **Java의 정적 필드(static field)**를 사용해 해결할 수 있습니다.\nPoseStorage 클래스 생성 먼저, 위치 데이터를 저장할 PoseStorage 클래스를 생성합니다.\n아래 코드처럼 **정적 필드(static field)**를 활용합니다.\npublic class PoseStorage { // static 키워드를 사용하여 데이터 공유 public static Pose2d currentPose = new Pose2d(); }\r자동 모드에서 위치 저장 자동 모드의 마지막에 PoseStorage.currentPose에 현재 위치를 저장합니다.\nPoseStorage.currentPose = drive.getPoseEstimate();\r텔레오프에서 위치 읽기 텔레오프 시작 시 저장된 위치를 읽어 초기 위치를 설정합니다.\nmyLocalizer.setPoseEstimate(PoseStorage.currentPose);\r전체 샘플 코드 다음 링크에서 전체 샘플을 확인할 수 있습니다:\nTeleOpJustLocalizer.java AutoTransferPose.java PoseStorage.java 주의 사항 앱 종료 시 데이터 손실\n앱이 갑자기 종료되면 데이터가 손실됩니다.\n이를 방지하려면 데이터베이스 또는 파일에 위치 데이터를 저장할 수 있습니다.\n하지만 일반적으로 이 정도로 복잡한 처리는 필요하지 않습니다.\n실시간 업데이트 필요\n현재 코드에서는 Autonomous Period가 끝날 때 한 번만 데이터를 저장합니다.\n만약 로봇이 외부 힘으로 밀리거나 프로그램이 충돌하면 위치 정보가 정확하지 않을 수 있습니다.\n이를 방지하려면 업데이트 루프에서 정기적으로 데이터를 저장하도록 구현해야 합니다.\n비동기 처리 활용\n정기적인 데이터 저장은 비동기 처리를 통해 구현할 수 있습니다.\n자세한 내용은 Finite State Machine Following 샘플을 참고하세요.\n필드 중심 주행(Field Centric Drive) 표준 드라이브 코드 위에 필드 중심 주행을 구현하는 것은 매우 간단합니다. 원하는 벡터를 가져와 로봇의 현재 방향(Heading)에 따라 회전시키기만 하면 됩니다.\n아래는 간단한 예제입니다:\n// 로봇의 현재 위치 읽기 Pose2d poseEstimate = drive.getPoseEstimate(); // 게임패드 x/y 입력으로 벡터 생성 // 그런 다음, 해당 벡터를 현재 헤딩의 역방향으로 회전 Vector2d input = new Vector2d( -gamepad1.left_stick_y, -gamepad1.left_stick_x ).rotated(-poseEstimate.getHeading()); // 회전된 입력 벡터와 오른쪽 스틱 값을 전달 // 회전 값은 회전된 입력 벡터에 포함되지 않으므로 별도로 전달해야 함 drive.setWeightedDrivePower( new Pose2d( input.getX(), input.getY(), -gamepad1.right_stick_x ) );\r전체 샘플 코드는 여기에서 확인할 수 있습니다.\n특정 지점에 맞춰 정렬(Align To Point) 이 데모는 반드시 Road Runner의 핵심 기능(모션 프로파일링 등)에 의존하지는 않지만, Road Runner 유틸리티를 많이 활용합니다. 이를 자신의 코드에 Road Runner 종속 없이 포팅하는 것은 비교적 간단합니다.\n이 데모는 드라이버가 \u0026ldquo;특정 지점에 맞춰 정렬\u0026rdquo; 모드로 전환하면 필드 중심 모드로 전환하고, 지정된 지점에 로봇이 자동으로 헤딩을 조정하도록 OpMode가 헤딩 제어를 담당합니다.\nOpMode 코드는 여기에서 확인할 수 있습니다.\n비동기 경로 추적(Async Following) 기본적으로 Quickstart의 followTrajectory() 함수는 **동기적(synchronous)**으로 동작합니다. 이는 해당 함수가 완료될 때까지 다음 줄의 코드가 실행되지 않음을 의미합니다. 이러한 동기적 방식은 Linear Opmode에서 잘 동작합니다.\n하지만, 리프트의 높이를 일정하게 유지하기 위해 PID 컨트롤러를 백그라운드에서 실행하고 싶다면, 모든 코드를 단일 루프 함수에서 처리하는 반복형 OpMode를 사용해야 합니다. 이 경우 followTrajectory()의 차단(Blocking) 동작은 적합하지 않습니다.\npublic void init() { // 비동기 추적 메서드 호출 drive.followTrajectoryAsync(trajectory); } public void loop() { // drive.update()를 호출하면 모든 경로 추적 로직이 처리됩니다. drive.update(); // 리프트 PID 컨트롤러 업데이트 또는 기타 로직 lift.update(); }\r비동기 경로 연결하기(Chaining Async Trajectories) 경로를 비동기 방식으로 연결하려면 인라인 변위 마커를 사용하면 됩니다.\nTrajectory trajectory1; Trajectory trajectory2; Trajectory trajectory3; public void init() { trajectory1 = drive.trajectoryBuilder(new Pose2d()) .lineTo(new Vector2d()) .addDisplacementMarker(() -\u0026gt; drive.followTrajectoryAsync(trajectory2)) .build(); trajectory2 = drive.trajectoryBuilder(trajectory1.end()) .lineTo(new Vector2d()) .addDisplacementMarker(() -\u0026gt; drive.followTrajectoryAsync(trajectory3)) .build(); trajectory3 = drive.trajectoryBuilder(trajectory2.end()) .lineTo(new Vector2d()) .build(); // 초기화 시 첫 번째 경로를 설정 drive.followTrajectoryAsync(trajectory1); } public void loop() { drive.update(); lift.update(); // 백그라운드에서 리프트 PID 업데이트 또는 기타 작업 }\r이 방법에는 몇 가지 단점이 있습니다:\n모션 프로파일 완료 후 위치를 교정하는 PID 제어가 건너뛰어집니다. 이 방법으로는 지연(Delay) 또는 회전을 추가할 수 없습니다. 더 나은 구현 방법은 유한 상태 기계(Finite State Machine, FSM)를 사용하는 것입니다. 자세한 내용은 아래를 참고하세요.\n유한 상태 기계(Finite State Machine) 추적 유한 상태 기계(Finite State Machines, FSM)는 매우 간단하면서도 놀라울 정도로 강력한 패턴으로, 복잡한 동작을 쉽게 조율할 수 있게 해줍니다. gm0의 FSM 문서 및 관련 영상을 참고하세요.\n이 샘플 코드는 FSM을 사용해 여러 경로를 추적하며, 경로 간 대기 및 회전을 수행하는 방법을 보여줍니다.\nFSM의 비동기적인 특성 덕분에 복잡한 서브시스템을 위한 여러 FSM을 병렬로 실행하거나 사용자의 자체 로직을 백그라운드에서 실행할 수 있습니다. 또한 매 루프마다 PoseStorage에 현재 위치를 저장해, 이전에 OpMode간 포즈 전송에서 언급한 데이터를 지속적으로 업데이트하는 문제를 해결합니다. FSM을 사용하면 각 상태에서 수행할 작업과 상태 간 전환 조건을 명확하게 정의할 수 있어 로봇의 복잡한 동작을 구조적이고 확장 가능한 방식으로 관리할 수 있습니다.\n허용 오차 및 타임아웃(Admissible Error and Timeout) Road Runner의 경로는 기본적으로 시간 기반입니다. 따라서 경로 추적 완료 여부는 내부 타이머에 의해 결정됩니다. 그러나 추적이 완벽하지 않을 수 있기 때문에, 시간 기반 종료 조건만으로는 충분하지 않을 수 있습니다.\nRoad Runner의 기본 팔로워(Follower)는 기본적으로 허용 오차(Admissible Error) 및 타임아웃(Timeout) 조건을 추가합니다. 이는 운동 프로파일이 소진된 후 Road Runner가 추가적으로 x초를 제공하거나 허용 오차 조건이 충족될 때까지 대기하도록 하여 경로 추적을 완료하도록 합니다. 이 기간 동안에는 팔로워의 PID 제어기만이 로봇에 작용합니다.\n기본적으로 팔로워는 0.5초의 타임아웃과 x/y 방향에서 0.5인치, 헤딩 방향에서 5도의 허용 오차를 제공합니다. 즉, 경로 추적이 기본적으로 위치에서 0.5인치와 헤딩에서 5도의 오차를 허용하도록 설정되어 있습니다.\n정확도를 높이고 싶다면 타임아웃을 늘리고 허용 오차를 줄이는 방법을 고려할 수 있습니다. 이러한 설정은 SampleMecanumDrive 클래스에서 팔로워가 초기화되는 부분에서 찾을 수 있습니다. 두 번째에서 마지막 매개변수가 허용 오차이고, 마지막 매개변수가 타임아웃입니다.\n/* SampleMecanumDrive.java의 120-121행 */ follower = new HolonomicPIDVAFollower(TRANSLATIONAL_PID, TRANSLATIONAL_PID, HEADING_PID, new Pose2d(0.5, 0.5, Math.toRadians(5.0)), 0.5); // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ^^^ // 허용 오차 (Pose) 타임아웃 (초)\r허용 오차를 줄이고 타임아웃을 늘리면 정확도를 높일 수 있습니다.\nTrajectory Following Flow 180° 회전 방향 설정 (180° Turn Direction) drive.turn(angle) 함수로 180° 회전을 수행할 때, 어느 방향으로 회전할지 지정할 수 있습니다.\n다른 각도는 가장 짧은 경로로 회전하지만, 180°는 방향이 모호할 수 있습니다. 이를 해결하려면 180°에 극소 값을 더하거나 빼서 방향을 지정합니다.\n// 반시계 방향 회전 drive.turn(Math.toRadians(180) + 1e-6); // 시계 방향 회전 drive.turn(Math.toRadians(180) - 1e-6);\r경로 중단 (Interrupting a Live Trajectory) 경로를 임의로 중단해야 하는 상황이 발생할 수 있습니다. 이러한 동작은 아래 예제에서만 적용하는 것이 적절합니다. 이 동작을 구현하려면 SampleMecanumDrive 클래스를 수정하고 로봇의 **mode**를 강제로 IDLE 상태로 변경하는 함수를 구현해야 합니다.\nSampleMecanumDriveCancelable AutoBreakTrajectory 이 수정된 클래스들은 단순히 breakFollowing() 함수를 구현하여 주행 경로를 중단할 수 있도록 합니다. 이 클래스들을 여러분의 프로젝트에 복사하여 사용하세요.\n텔레오프에서 자동 주행 사용 경고: 이 샘플 코드는 Road Runner의 기능을 보여주는 데모일 뿐, 게임에서 권장되지 않습니다.\n이 샘플 코드는 TeleOp 중에 임의의 Road Runner 경로를 따라가는 방식으로 운전자 제어를 증강하는 방법을 시연합니다. 그러나 이는 경로(Road Runner Trajectories)가 본래 의도된 목적에 부합하지 않으며, 이와 같은 시나리오에서는 경로 추적(Path Follower)이 더 적합합니다.\n이 샘플은 Road Runner의 기능을 시연하기 위한 데모로 설계되었으며, 복잡한 행동을 생성하기 위해 \u0026ldquo;유한 상태 기계(Finite State Machine)\u0026ldquo;샘플과 \u0026ldquo;실시간 경로 중단(Interrupting a Live Trajectory)\u0026rdquo; 샘플을 결합하는 방법을 보여줍니다.\n해당 OpMode의 세부 설명은 주석에 작성되어 있습니다.\n옴니 휠 (Omni Wheels) 사각형 로봇의 각 변에 옴니 휠을 하나씩 배치하면, 이는 표준 GoBilda 방식으로 배열된 메카넘 휠과 동일한 방식으로 작동합니다. 개념적으로, 로봇의 전면은 두 옴니 휠 사이의 중간 지점에 위치하게 됩니다. 로봇의 모서리를 전면으로 정렬하면, 옴니 휠은 메카넘 휠과 동일한 기능을 수행하게 됩니다.\n","date":"2023-09-07","id":19,"permalink":"/docs/6-advanced-tips/%EC%B6%94%EA%B0%80%EC%A0%81%EC%9D%B8-%EC%A0%95%EB%B3%B4/","summary":"\u003cp\u003e고급 코드 샘플은 \u003ccode\u003eadvanced-examples\u003c/code\u003e 브랜치에서 확인할 수 있습니다.\u003cbr\u003e\n\u003ca href=\"https://github.com/NoahBres/road-runner-quickstart/tree/advanced-examples\"\u003ehttps://github.com/NoahBres/road-runner-quickstart/tree/advanced-examples\u003c/a\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"teleop에서-road-runner-사용하기\"\u003eTeleOp에서 Road Runner 사용하기\u003c/h2\u003e\n\u003cp\u003eTeleOp에서 Road Runner를 사용하는 데는 여러 이유가 있습니다.\u003cbr\u003e\n예를 들어, 복잡한 자동화를 구현하고 싶을 수도 있습니다.\u003cbr\u003e\n개인적으로는 \u003cstrong\u003e텔레오프 자동화보다는 드라이브 연습에 투자하는 것이 훨씬 더 효율적\u003c/strong\u003e이라고 생각합니다.\u003cbr\u003e\n하지만, 원한다면 자유롭게 사용해 보세요.\u003c/p\u003e","tags":[],"title":"추가적인 정보"},{"content":"개요 MeepMeep\r이 글을 작성하는 시점에서 MeepMeep은 Road Runner를 위한 가장 기능이 풍부한 경로 시각화 도구입니다. MeepMeep은 객관적으로 가장 많은 기능을 지원하며, TrajectorySequence API와 마커를 지원하는 유일한 시각화 도구입니다.\nLearnRoadRunner에서 사용된 모든 스크린샷과 gif는 MeepMeep으로 생성되었습니다.\nMeepMeep의 기능들: 마커 시각화 타임라인 스크러빙 TrajectorySequence 지원 커스터마이징 가능한 GUI 필드 이미지, 색상 테마 등을 변경 가능 개발 중인 드래그 앤 드롭 경로 생성기 다크 모드 색상 테마 Android Studio에서 실행 가능 기존 시즌 코드와 함께 사용 직관적인 필드 좌표 MeepMeep MeepMeep은 2021년 5월 6일부터 적용된 Road Runner 경로 시퀀스 API에 맞게 설계된 경로 시각화 도구입니다. 경로 시퀀스에 대한 자세한 내용은 여기에서 확인할 수 있습니다.\nLearnRoadRunner에 있는 모든 스크린샷과 GIF는 MeepMeep을 사용하여 생성되었습니다.\n설치 방법 설치 과정은 Android 앱 개발 및 Gradle 모듈에 대한 지식이 필요하여 직관적이지 않을 수 있습니다. 아래 설치 영상을 참고하세요.\n참고: MeepMeep 2.x.x 이후 API 변경으로 인해 영상 후반부에 설명된 코드는 유효하지 않습니다. 이 API 변경은 다중 봇 지원을 보다 잘 처리할 수 있게 하기 위함입니다.\n사용 방법 위 영상 후반부에서 기본적인 사용법을 다룹니다.\nMeepMeep을 사용하려면 경로 시퀀스의 작동 방식에 대한 이해가 필요합니다. 경로 시퀀스 페이지에서 API를 숙지하시기 바랍니다.\nMeepMeep은 별도의 모듈에서 실행되므로, 일반적인 TeamCode SDK 코드에서 실행할 수 없습니다. 이는 경로 자체에는 영향을 주지 않으나, 마커 내에서 실행되는 로봇 제어 코드에는 영향을 줄 수 있습니다. 아래와 같이 주석 처리를 권장합니다:\npublic class MeepMeepTesting { public static void main(String[] args) { // MeepMeep 인스턴스 선언 // 필드 크기를 800 픽셀로 설정 MeepMeep meepMeep = new MeepMeep(800); RoadRunnerBotEntity myBot = new DefaultBotBuilder(meepMeep) // 필수: 로봇의 제약 설정 (최대 속도, 최대 가속도, 최대 각속도 등) .setConstraints(60, 60, Math.toRadians(180), Math.toRadians(180), 15) // 선택 사항: 테마 설정. 기본값은 ColorSchemeRedDark() .setColorScheme(new ColorSchemeRedDark()) .followTrajectorySequence(drive -\u0026gt; drive.trajectorySequenceBuilder(new Pose2d(0, 0, 0)) .forward(30) .turn(Math.toRadians(90)) .forward(30) .addDisplacementMarker(() -\u0026gt; { /* 마커 콜백 안의 모든 내용은 주석 처리하세요 */ // bot.shooter.shoot() // bot.wobbleArm.lower() }) .turn(Math.toRadians(90)) .splineTo(new Vector2d(10, 15), 0) .turn(Math.toRadians(90)) .build() ); // 필드 이미지 설정 meepMeep.setBackground(MeepMeep.Background.FIELD_FREIGHTFRENZY_ADI_DARK) .setDarkMode(true) // 배경 불투명도 (0~1) .setBackgroundAlpha(0.95f) .addEntity(myBot) .start(); } }\r다중 봇 추가하기 MeepMeep 2.x 버전은 새로운 API와 엔티티 처리 방식을 도입하여 여러 경로를 동시에 실행하고 조율할 수 있습니다. 새로운 RoadRunnerBotEntity를 선언하고, MeepMeep#addEntity(Entity)를 통해 추가하세요.\npublic class MeepMeepTesting { public static void main(String[] args) { MeepMeep meepMeep = new MeepMeep(800); // 첫 번째 봇 선언 RoadRunnerBotEntity myFirstBot = new DefaultBotBuilder(meepMeep) // 봇 색상을 파란색으로 설정 .setColorScheme(new ColorSchemeBlueDark()) .setConstraints(60, 60, Math.toRadians(180), Math.toRadians(180), 15) .followTrajectorySequence(drive -\u0026gt; drive.trajectorySequenceBuilder(new Pose2d(0, 0, 0)) .forward(30) .turn(Math.toRadians(90)) .forward(30) .turn(Math.toRadians(90)) .forward(30) .turn(Math.toRadians(90)) .forward(30) .turn(Math.toRadians(90)) .build() ); // 두 번째 봇 선언 RoadRunnerBotEntity mySecondBot = new DefaultBotBuilder(meepMeep) // 봇 색상을 빨간색으로 설정 .setColorScheme(new ColorSchemeRedDark()) .setConstraints(60, 60, Math.toRadians(180), Math.toRadians(180), 15) .followTrajectorySequence(drive -\u0026gt; drive.trajectorySequenceBuilder(new Pose2d(30, 30, Math.toRadians(180))) .forward(30) .turn(Math.toRadians(90)) .forward(30) .turn(Math.toRadians(90)) .forward(30) .turn(Math.toRadians(90)) .forward(30) .turn(Math.toRadians(90)) .build() ); meepMeep.setBackground(MeepMeep.Background.FIELD_FREIGHTFRENZY_ADI_DARK) .setDarkMode(true) .setBackgroundAlpha(0.95f) // 선언한 두 봇 추가 .addEntity(myFirstBot) .addEntity(mySecondBot) .start(); } }\r사용 가능한 필드 이미지 🚧 작업 중 🚧\nGitHub 폴더에서 사용할 수 있는 이미지를 확인하고, Background 클래스에서 클래스 이름을 확인하세요.\n사용자 정의 색상 테마 만들기 🚧 작업 중 🚧\n제공된 색상 테마는 여기를 참고하세요.\n사용자 정의 엔티티 추가 🚧 작업 중: Heno에게 개선된 링 엔티티 샘플 요청 🚧\n또는 여기를 참조하세요.\n","date":"2023-09-07","id":20,"permalink":"/docs/7-tools/meepmeep/","summary":"\u003ch2 id=\"개요\"\u003e개요\u003c/h2\u003e\n\r\n\u003cfigure\u003e\r\n  \u003cimg\r\n    srcset=\"data:image/webp;base64,UklGRkQAAABXRUJQVlA4IDgAAAAQAgCdASoQAAgAAph8J5wC7AEVjbpE65QAAP7ZN72yk2JfjCeK3nAmmLV7uxI6hgAwjMpuOaCAAA==\"\r\n        data-srcset=\"/images/tools/meepmeep-half-compressed_hu5373179298104281157.webp 480w,/images/tools/meepmeep-half-compressed_hu18134599536546129.webp 576w,/images/tools/meepmeep-half-compressed_hu1753677762979794587.webp 768w,/images/tools/meepmeep-half-compressed_hu13307085915505785444.webp 1025w,/images/tools/meepmeep-half-compressed_hu2323883879628139220.webp 1200w,/images/tools/meepmeep-half-compressed_hu11817789698136829004.webp 1440w,/images/tools/meepmeep-half-compressed_hu11616499022062982380.webp 1692w\"\r\n        data-sizes=\"auto\"\r\n    src=\"/images/tools/meepmeep-half-compressed_hu14159671817007263713.jpg\"\r\n    width=\"1692\"\r\n    height=\"885\"\r\n    decoding=\"async\"\r\n    fetchpriority=\"auto\"\r\n    loading=\"lazy\"\r\n    alt=\"MeepMeep의 스크린샷\"\r\n    class=\"lazyload blur-up\"\r\n  \u003e\u003cfigcaption\u003eMeepMeep\u003c/figcaption\u003e\r\n\u003c/figure\u003e\n\u003cp\u003e이 글을 작성하는 시점에서 MeepMeep은 Road Runner를 위한 가장 기능이 풍부한 경로 시각화 도구입니다.\nMeepMeep은 객관적으로 가장 많은 기능을 지원하며,\n\u003ccode\u003eTrajectorySequence\u003c/code\u003e API와 마커를 지원하는 유일한 시각화 도구입니다.\u003c/p\u003e","tags":[],"title":"MeepMeep"},{"content":"개요 Road Runner 공식 GUI\rRoad Runner는 경로를 설계하기 위한 공식 GUI 플러그인을 제공합니다. 이 GUI는 경로를 yaml 파일로 내보낼 수 있으며, 해당 파일은 Road Runner 라이브러리가 읽을 수 있습니다.\n하지만, 이 GUI는 스플라인 경로만 생성할 수 있습니다. lineTo나 상대 이동(strafe(), forward() 등)은 지원하지 않습니다. 또한, 경로가 yaml 파일로 내보내지기 때문에 마커를 지원하지 않습니다.\n공식 GUI를 사용하기로 결정했다면, GUI에서 경로를 생성한 뒤 이를 Java 코드로 변환하여 사용하는 것을 권장합니다.\n설치 방법 Road Runner 최신 릴리즈 페이지로 이동합니다. Assets 드롭다운 메뉴를 펼치고 road-runner-gui-x.x.x.jar 파일을 찾습니다. 파일 이름을 클릭하여 .jar 파일을 다운로드합니다. 다운로드한 .jar 파일을 터미널에서 실행합니다: java -jar road-runner-gui-x.x.x.jar\r사용 방법 다운로드한 .jar 파일을 실행합니다. \u0026ldquo;Select the location for your project\u0026quot;라는 작은 창이 나타납니다. Browse 버튼을 클릭하고, FTC 코드가 있는 폴더를 선택합니다. 아래와 같은 창이 나타납니다: Road Runner GUI 메인 창\r왼쪽 상단의 Add 버튼을 클릭하여 경로에 이름을 지정합니다. 오른쪽 하단의 Add 버튼을 클릭하여 더 많은 웨이포인트를 추가합니다. 웨이포인트의 좌표를 수정하세요. 다양한 기능을 실험해 보세요: Interp 드롭다운 메뉴를 통해 각 웨이포인트의 헤딩 보간(interpolation) 유형을 변경할 수 있습니다. Config 탭에서는 로봇의 물리적 속성과 제약 조건을 변경할 수 있습니다. 필드 위로 커서를 올리면, 로봇이 경로를 따라 움직이는 애니메이션을 확인할 수 있습니다. Save 버튼을 클릭하면 경로가 YAML 파일로 내보내집니다. ","date":"2023-09-07","id":21,"permalink":"/docs/7-tools/roadrunner-gui/","summary":"\u003ch2 id=\"개요\"\u003e개요\u003c/h2\u003e\n\r\n\u003cfigure\u003e\r\n  \u003cimg\r\n    srcset=\"data:image/webp;base64,UklGRjYAAABXRUJQVlA4ICoAAADQAQCdASoQAA0AAph8J6QAAvkOl06dwAD\u0026#43;6EnjAQU1CXstY30w2krEFAA=\"\r\n        data-srcset=\"/images/tools/rr-gui-half-compressed_hu4418386867891617173.webp 480w,/images/tools/rr-gui-half-compressed_hu13701704809434719958.webp 576w,/images/tools/rr-gui-half-compressed_hu1781813075678529082.webp 768w,/images/tools/rr-gui-half-compressed_hu17560801330649918971.webp 1025w,/images/tools/rr-gui-half-compressed_hu17056912392404265612.webp 1044w\"\r\n        data-sizes=\"auto\"\r\n    src=\"/images/tools/rr-gui-half-compressed_hu2855696403400083119.jpg\"\r\n    width=\"1044\"\r\n    height=\"837\"\r\n    decoding=\"async\"\r\n    fetchpriority=\"auto\"\r\n    loading=\"lazy\"\r\n    alt=\"Road Runner 경로 생성 GUI를 보여주는 스크린샷\"\r\n    class=\"lazyload blur-up\"\r\n  \u003e\u003cfigcaption\u003eRoad Runner 공식 GUI\u003c/figcaption\u003e\r\n\u003c/figure\u003e\n\u003cp\u003eRoad Runner는 경로를 설계하기 위한 공식 GUI 플러그인을 제공합니다. 이 GUI는 경로를 yaml 파일로 내보낼 수 있으며, 해당 파일은 Road Runner 라이브러리가 읽을 수 있습니다.\u003cbr\u003e\n하지만, 이 GUI는 스플라인 경로만 생성할 수 있습니다. \u003ccode\u003elineTo\u003c/code\u003e나 상대 이동(\u003ccode\u003estrafe()\u003c/code\u003e, \u003ccode\u003eforward()\u003c/code\u003e 등)은 지원하지 않습니다. 또한, 경로가 yaml 파일로 내보내지기 때문에 마커를 지원하지 않습니다.\u003cbr\u003e\n공식 GUI를 사용하기로 결정했다면, GUI에서 경로를 생성한 뒤 이를 Java 코드로 변환하여 사용하는 것을 권장합니다.\u003c/p\u003e","tags":[],"title":"RoadRunner GUI"},{"content":"\rDavid의 RRPathVisualizer\rRRPathVisualizer는 Recharged Green 7236 팀의 리드 프로그래머인 David가 작성한 경로 \u0026ldquo;시각화 도구\u0026quot;입니다. 이 도구는 로봇용 경로를 작성하듯이 경로를 작성한 뒤, 이를 커스텀 Kotlin 프로젝트에 추가하는 방식으로 작동합니다. 프로그램을 실행하면 창이 열리며, 지정된 경로를 따라 로봇이 움직이는 애니메이션을 표시합니다.\n개인적으로는 이 워크플로우를 선호하는데, RRPathVisualizer에서 작성한 경로를 간단히 복사하여 자신의 FTC 프로젝트에 붙여넣을 수 있기 때문입니다.\n참고로, RRPathVisualizer는 Kotlin으로 작성되었습니다. Java를 알고 있다면 Kotlin을 이해하는 데 큰 어려움이 없을 것입니다.\n노트\nDavid의 RRPathVisualizer와 Road Runner 공식 GUI는 모두 회전된 필드 좌표계를 사용합니다. 두 프로그램의 필드는 관중의 관점을 기준으로 90도 회전되어 있으며, 이로 인해 Y축은 수평이고 X축은 수직입니다. Y축 값은 왼쪽으로 증가하고, X축 값은 위로 증가합니다. 두 애플리케이션을 사용할 때 혼란을 방지하기 위해 이 점을 유의하세요.\nMeepMeep은 회전된 필드를 사용하지 않습니다. 관중의 관점에서 필드가 표시되지는 않지만, X축과 Y축은 전형적인 데카르트 좌표계를 따릅니다. 더 자세한 내용은 좌표계 명세서를 참조하세요.\n설치 방법 Intellij 설치\n커뮤니티 에디션은 무료입니다. 학생 계정으로 Ultimate Edition을 무료로 사용할 수도 있습니다. RRPathVisualizer를 클론하거나 다운로드\nIntellij에서 프로젝트 열기\n사용 방법 Intellij에서 프로젝트 열기\nAndroid Studio와 유사한 인터페이스이므로 익숙할 것입니다. 상단의 재생 버튼을 눌러 실행\n정상적으로 실행되어야 합니다. Intellij에서 열린 RRPathVisualizer 스크린샷\r프로젝트 SDK 설정이 필요할 수 있음\nFile \u0026gt; Project Structure로 이동 \u0026ldquo;Project SDK\u0026rdquo; 설정에서 최신 JDK 버전을 선택 Intellij는 JDK 14를 기본적으로 포함 TrajectoryGen.kt 파일 열기\ndriveConstraints 값이 로봇의 Road Runner 설정에서 사용하는 DriveConstraints와 일치하는지 확인\ntrackWidth 값이 DriveConstants.java 파일의 TRACK_WIDTH와 일치하는지 확인\n이는 경로 길이 추정치를 보다 정확하게 만듭니다. builder1 찾기\nbuilder1 객체는 제공된 예제 TrajectoryBuilder입니다. 추가 경로를 생성하려면 더 많은 builder를 자유롭게 추가 가능 일반적으로 경로를 생성하듯이 builder 사용\nlist.add(trajectory)를 호출하여 더 많은 경로 추가 가능\n참고: RRPathVisualizer는 **포인트 턴(point turns)**을 시뮬레이션할 수 없습니다.\n주의 사항 실제 로봇에서는 각 경로 완료 후 0.5초의 타임아웃이 설정되어 있습니다.\n이는 경로를 이탈한 경우 PID를 통해 이동 및 헤딩 보정을 허용하기 위함입니다. 로봇이 경로를 벗어나지 않고 도달하면 이 타임아웃은 더 빨리 종료됩니다. 따라서 각 경로에 최대 0.5초가 추가될 수 있으며, 이 추가 시간은 RRPathVisualizer의 경로 시간 추정치에 반영되지 않습니다. 타임아웃 지속 시간을 변경하려면, SampleMecanumDrive.java의 HolonomicPIDVAFollower에 설정된 마지막 매개변수(기본값 0.5)를 수정하세요. 참고 자료 팀 Bots in Black(16633)의 RRPathVisualizer 설치, 기본 문제 해결 및 사용법 설명 영상:\n","date":"2023-09-07","id":22,"permalink":"/docs/7-tools/davids-rrpathvisualizer/","summary":"\u003cfigure\u003e\r\n  \u003cimg\r\n    srcset=\"data:image/webp;base64,UklGRkAAAABXRUJQVlA4IDQAAADwAQCdASoQAAgAAph8J7AAAxcI2xKi9AAA/sye4PeTfYOVQQi36lobLyrHFquQnvbrQiAA\"\r\n        data-srcset=\"/images/tools/rrpathviz-half-compressed_hu6515843336608434453.webp 480w,/images/tools/rrpathviz-half-compressed_hu9480986333801582894.webp 576w,/images/tools/rrpathviz-half-compressed_hu9530701176147064808.webp 768w,/images/tools/rrpathviz-half-compressed_hu10355881983310713327.webp 1025w,/images/tools/rrpathviz-half-compressed_hu5267104864369604885.webp 1200w,/images/tools/rrpathviz-half-compressed_hu9950882902710715972.webp 1433w\"\r\n        data-sizes=\"auto\"\r\n    src=\"/images/tools/rrpathviz-half-compressed_hu18243002095933182550.jpg\"\r\n    width=\"1433\"\r\n    height=\"719\"\r\n    decoding=\"async\"\r\n    fetchpriority=\"auto\"\r\n    loading=\"lazy\"\r\n    alt=\"David의 RRPathVisualizer를 보여주는 스크린샷\"\r\n    class=\"lazyload blur-up\"\r\n  \u003e\u003cfigcaption\u003eDavid의 RRPathVisualizer\u003c/figcaption\u003e\r\n\u003c/figure\u003e\n\u003cp\u003eRRPathVisualizer는 Recharged Green 7236 팀의 리드 프로그래머인 David가 작성한 경로 \u0026ldquo;시각화 도구\u0026quot;입니다.\n이 도구는 로봇용 경로를 작성하듯이 경로를 작성한 뒤, 이를 커스텀 Kotlin 프로젝트에 추가하는 방식으로 작동합니다.\n프로그램을 실행하면 창이 열리며, 지정된 경로를 따라 로봇이 움직이는 애니메이션을 표시합니다.\u003cbr\u003e\n개인적으로는 이 워크플로우를 선호하는데, RRPathVisualizer에서 작성한 경로를 간단히 복사하여\n자신의 FTC 프로젝트에 붙여넣을 수 있기 때문입니다.\u003c/p\u003e","tags":[],"title":"David's RRPathVisualizer"},{"content":"\rRRPathGen은 팀이 GUI를 통해 경로를 빠르게 생성할 수 있도록 돕는 프로그램입니다. 주요 기능은 다음과 같습니다:\n경로를 가져와 시각화 GUI 또는 텍스트 필드에서 값을 변경하여 경로 수정 Java 코드 형식으로 경로 내보내기 로봇의 길이와 너비 사용자 지정 다양한 화면 크기 및 해상도 지원 필드의 다른 위치에서 로봇이 시작하도록 경로를 뒤집는 기능 MeepMeep과 동일한 필드 좌표계 사용 곧 TrajectorySequence 지원 예정 설치 방법 (Jar 파일) 릴리즈 페이지에서 .jar 파일 다운로드\n최소 Java 8 이상이 설치되었는지 확인\njava --version\r.jar 파일을 실행\n더블 클릭으로 실행하거나, 명령줄에서 실행 java -jar RRPathGen-X.X.X.jar\r설치 방법 (IntelliJ) 저장소 클론 git clone https://github.com/Jarhead20/RRPathGen.git\r실행 구성 설정 : IntelliJ에서 Run Configuration 생성 앱 실행 사용 방법 아래 키 바인딩을 사용해 경로 생성 생성이 완료되면 내보내기(export) 버튼 클릭 내보낸 경로를 복사하여 자율 주행 프로그램에 붙여넣기 키 바인드 동작 Left Click 새 포인트 추가 Left Drag (Point) 선택한 포인트 드래그 Alt + Left Click 헤딩(heading) 변경 Left Arrow 다음 경로로 이동 Right Arrow 이전 경로로 이동 R 로봇 방향 반전 Delete 선택한 노드 삭제 Ctrl + Z 이전 작업 실행 취소 ⚠️ 설정 복구 설정 파일을 잘못 변경한 경우, 아래 경로에서 파일 삭제: Windows: %appdata%/RRPathGen MacOS: ~/Library/Application Support/RRPathGen/config.properties Linux: ~/.RRPathGen/config.properties 감사의 말 프로젝트 영감: Technic Bots의 Blitz 앱에서 영감을 받음 필드 이미지: MeepMeep에서 제공 스플라인 구현 지원: Ryan Brott ","date":"2023-09-07","id":23,"permalink":"/docs/7-tools/rrpathgen/","summary":"\u003cp\u003e\r\n\r\n\u003cimg\r\n  src=\"/images/tools/RRPathGen.gif\"\r\n  width=\"1280\"\r\n  height=\"700\"\r\n  decoding=\"async\"\r\n  fetchpriority=\"auto\"\r\n  loading=\"lazy\"\r\n  alt=\"21511이 개발한 RRPathGen\"id=\"h-rh-i-0\"\r\n/\u003e\u003c/p\u003e\n\u003cp\u003eRRPathGen은 팀이 GUI를 통해 경로를 빠르게 생성할 수 있도록 돕는 프로그램입니다. 주요 기능은 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e경로를 가져와 시각화\u003c/li\u003e\n\u003cli\u003eGUI 또는 텍스트 필드에서 값을 변경하여 경로 수정\u003c/li\u003e\n\u003cli\u003eJava 코드 형식으로 경로 내보내기\u003c/li\u003e\n\u003cli\u003e로봇의 길이와 너비 사용자 지정\u003c/li\u003e\n\u003cli\u003e다양한 화면 크기 및 해상도 지원\u003c/li\u003e\n\u003cli\u003e필드의 다른 위치에서 로봇이 시작하도록 경로를 뒤집는 기능\u003c/li\u003e\n\u003cli\u003eMeepMeep과 동일한 필드 좌표계 사용\u003c/li\u003e\n\u003cli\u003e곧 \u003ccode\u003eTrajectorySequence\u003c/code\u003e 지원 예정\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"설치-방법-jar-파일\"\u003e설치 방법 (Jar 파일)\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/Jarhead20/RRPathGen/releases\"\u003e릴리즈 페이지\u003c/a\u003e에서 \u003ccode\u003e.jar\u003c/code\u003e 파일 다운로드\u003c/p\u003e","tags":[],"title":"RRPathGen"},{"content":"","date":"2023-09-07","id":24,"permalink":"/docs/1-about-roadrunner/","summary":"","tags":[],"title":"Road Runner란?"},{"content":"","date":"2023-09-07","id":25,"permalink":"/docs/5-trajectory/","summary":"","tags":[],"title":"경로 설정"},{"content":"","date":"2023-09-07","id":26,"permalink":"/docs/7-tools/","summary":"","tags":[],"title":"도구"},{"content":"","date":"2023-09-07","id":27,"permalink":"/docs/2-before-you-start/","summary":"","tags":[],"title":"사전 준비"},{"content":"","date":"2023-09-07","id":28,"permalink":"/docs/3-installation/","summary":"","tags":[],"title":"설치"},{"content":"","date":"2023-09-07","id":29,"permalink":"/docs/4-tuning/","summary":"","tags":[],"title":"시스템 조율"},{"content":"","date":"2023-09-07","id":30,"permalink":"/docs/8-further-resources/","summary":"","tags":[],"title":"추가 리소스"},{"content":"","date":"2023-09-07","id":31,"permalink":"/docs/6-advanced-tips/","summary":"","tags":[],"title":"팁"},{"content":"추가 자료 Road Runner에 대한 더 많은 정보를 원한다면 공식 Road Runner 문서의 리소스 페이지를 확인하세요! 해당 페이지에는 Road Runner가 사용하는 논문들에 대한 링크가 포함되어 있습니다. 또한, Ryan Brott의 논문들도 그곳에서 확인할 수 있습니다.\n","date":"2023-09-07","id":32,"permalink":"/docs/8-further-resources/%EC%B6%94%EA%B0%80-%EB%A6%AC%EC%86%8C%EC%8A%A4/","summary":"\u003ch1 id=\"추가-자료\"\u003e추가 자료\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003eRoad Runner\u003c/strong\u003e에 대한 더 많은 정보를 원한다면\n\u003ca href=\"https://acme-robotics.gitbook.io/road-runner/advanced/resources\"\u003e공식 Road Runner 문서의 리소스 페이지\u003c/a\u003e를 확인하세요!\n해당 페이지에는 Road Runner가 사용하는 논문들에 대한 링크가 포함되어 있습니다.\n또한, Ryan Brott의 논문들도 그곳에서 확인할 수 있습니다.\u003c/p\u003e","tags":[],"title":"추가 리소스"},{"content":"Operation / 운영 Team TALOS \u0026amp; KSA Research Group KROS\n이 웹사이트는 한국 FTC 팀 TALOS 및 한국과학영재학교 로봇 연구회 KROS의 운영으로 관리됩니다. Developers / 제작자 FFLiK\n25309 TALOS / KSA 22 이 웹사이트는 웹사이트 제작 엔진 Thulite를 사용한 Docs 페이지 포맷 Doks를 기반으로 제작되었습니다.\rOriginal Source / 원본 제작자 이 웹사이트는 LearnRoadrunner의 내용을 번역한 내용이며, Road Runner 공식 문서를 참고하여 제작되었습니다. Learn Roadrunner를 제작한 NoahBres 및 기타 기여자들께 감사드립니다. This website is a translated version of LearnRoadrunner,\rand is created with reference to the Road Runner official documentation.\rSpecial thanks to NoahBres and other contributors of Learn Roadrunner.\rAcme Robotics (Road Runner) NoahBres (Learn Road Runner) And other contributors / 기타 기여자들 Sponsors / 지원 이 웹사이트는 한국과학영재학교와 과학기술정보통신부의 지원을 받아 운영됩니다. Korea Science Academy of KAIST / 한국과학영재학교 Korea Advanced Institute of Science and Technology / 한국과학기술원 Ministry of Science and ICT / 과학기술정보통신부 License / 라이센스 이 웹사이트는 MIT 라이선스를 따릅니다. 번역 오류 및 수정 사항, 혹은 건의 사항에 대한 모든 PR를 환영합니다.\nThis website is licensed under the MIT License. All PRs (Pull Requests) regarding translation errors, corrections, or suggestions are welcome.\n","date":"2025-01-04","id":33,"permalink":"/credit/","summary":"\u003ch3 id=\"operation--운영\"\u003eOperation / 운영\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ca href=\"https://github.com/TALOS-25309\"\u003eTeam TALOS \u0026amp; KSA Research Group KROS\u003c/a\u003e\u003c/strong\u003e\u003cbr\u003e\n\u003csmall\u003e 이 웹사이트는 한국 FTC 팀 TALOS 및 한국과학영재학교 로봇 연구회 KROS의 운영으로 관리됩니다. \u003c/small\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch5 id=\"developers--제작자\"\u003eDevelopers / 제작자\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ca href=\"https://github.com/FFLiK\"\u003eFFLiK\u003c/a\u003e\u003c/strong\u003e\u003cbr\u003e\n\u003csmall\u003e 25309 TALOS / KSA 22 \u003c/small\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003csmall\u003e\r\n이 웹사이트는 웹사이트 제작 엔진 \u003ca href=\"https://github.com/thuliteio/thulite\"\u003eThulite\u003c/a\u003e를 사용한 \r\nDocs 페이지 포맷 \u003ca href=\"https://getdoks.org/\"\u003eDoks\u003c/a\u003e를 기반으로 제작되었습니다.\r\n\u003c/small\u003e\r\n\u003chr\u003e\n\u003ch3 id=\"original-source--원본-제작자\"\u003eOriginal Source / 원본 제작자\u003c/h3\u003e\n\u003csmall\u003e\r\n이 웹사이트는 \u003ca href=\"https://learnroadrunner.com/\"\u003eLearnRoadrunner\u003c/a\u003e의 내용을 번역한 내용이며,   \r\n\u003ca href=\"https://acme-robotics.gitbook.io/road-runner/\"\u003eRoad Runner 공식 문서\u003c/a\u003e를 참고하여 제작되었습니다.   \r\nLearn Roadrunner를 제작한 NoahBres 및 기타 기여자들께 감사드립니다.   \r\n\u003c/small\u003e\r\n\u003cbr\u003e\u003cbr\u003e\r\n\u003csmall\u003e\r\nThis website is a translated version of \u003ca href=\"https://learnroadrunner.com/\"\u003eLearnRoadrunner\u003c/a\u003e,\r\nand is created with reference to the \u003ca href=\"https://acme-robotics.gitbook.io/road-runner/\"\u003eRoad Runner official documentation\u003c/a\u003e.\r\nSpecial thanks to NoahBres and other contributors of Learn Roadrunner.\r\n\u003c/small\u003e\r\n\u003cbr\u003e\u003cbr\u003e\r\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eAcme Robotics\u003c/strong\u003e (\u003ca href=\"https://acme-robotics.gitbook.io/road-runner/\"\u003eRoad Runner\u003c/a\u003e)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eNoahBres\u003c/strong\u003e (\u003ca href=\"https://github.com/NoahBres/LearnRoadRunner/\"\u003eLearn Road Runner\u003c/a\u003e)\u003c/li\u003e\n\u003cli\u003eAnd other \u003cstrong\u003econtributors\u003c/strong\u003e / 기타 기여자들\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"sponsors--지원\"\u003eSponsors / 지원\u003c/h3\u003e\n\u003cp\u003e\u003csmall\u003e 이 웹사이트는 한국과학영재학교와 과학기술정보통신부의 지원을 받아 운영됩니다. \u003c/small\u003e\u003c/p\u003e","tags":[],"title":"Credit"},{"content":"","date":"2023-09-07","id":34,"permalink":"/privacy/","summary":"","tags":[],"title":"Privacy Policy"},{"content":"","date":"2023-09-07","id":35,"permalink":"/","summary":"","tags":[],"title":"Roadrunner Tutorial"},{"content":"","date":"2023-09-07","id":36,"permalink":"/docs/","summary":"","tags":[],"title":"Docs"},{"content":"","date":"0001-01-01","id":37,"permalink":"/categories/","summary":"","tags":[],"title":"Categories"},{"content":"","date":"0001-01-01","id":38,"permalink":"/contributors/","summary":"","tags":[],"title":"Contributors"},{"content":"","date":"0001-01-01","id":39,"permalink":"/tags/","summary":"","tags":[],"title":"Tags"}]