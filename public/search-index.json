[{"content":"Road Runner는 FTC 로봇 대회를 위해 설계된 모션 플래닝 라이브러리입니다. 주로 자율 주행 로봇의 움직임을 위해 사용되며, 복잡한 경로 생성 및 추적을 가능하게 하고 속도와 가속도를 정밀하게 제어할 수 있습니다. 이를 통해 로봇이 더 정밀하고 고급 경로 추적 기능을 가질 수 있습니다.\n로드러너는 Acme Robotics에 의해 개발되었으며, 특히 최근에는 FTC Roadrunner에 FTC Dashboard, Meep Meep 등 다양한 부가 기능을 추가한 FTC Roadrunner Quickstart가 개발되었습니다. 이 문서에서는 Roadrunner Quickstart를 기반으로 로드러너 사용법을 다루고 있습니다.\n시작하기\n","date":"2023-09-07","id":0,"permalink":"/docs/1-about-roadrunner/%EB%A1%9C%EB%93%9C%EB%9F%AC%EB%84%88%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC/","summary":"\u003cp\u003eRoad Runner는 \u003ca href=\"https://www.firstinspires.org/robotics/ftc\"\u003eFTC 로봇 대회\u003c/a\u003e를 위해 설계된 모션 플래닝 라이브러리입니다. 주로 자율 주행 로봇의 움직임을 위해 사용되며, 복잡한 경로 생성 및 추적을 가능하게 하고 속도와 가속도를 정밀하게 제어할 수 있습니다. 이를 통해 로봇이 더 정밀하고 고급 경로 추적 기능을 가질 수 있습니다.\u003c/p\u003e","tags":[],"title":"로드러너에 대하여"},{"content":"1. Pure Pursuit와의 차이점 Road Runner와 Pure Pursuit는 자주 비교되지만, 본질적으로 매우 다른 도구입니다.\nPure Pursuit: 비홀로노믹(Non-Holonomic) 드라이브 트레인을 위한 경로 추적 알고리즘으로, \u0026ldquo;룩어헤드 포인트(Look-Ahead Point)\u0026ldquo;를 사용해 다차원 경로를 따릅니다. Road Runner: Ramsete, 가이드 벡터 필드 등 여러 경로 추적 알고리즘을 지원하며, 속도와 가속도를 제어하는 모션 프로파일링 기능을 포함합니다. 특히, Pure Pursuit는 가속도 제어가 없기 때문에 데드 휠 오도메트리 설치가 필수입니다. 또한, FTC 로봇 대부분이 홀로노믹(메카넘) 드라이브를 사용하기 때문에 Pure Pursuit는 잘 맞지 않는 경우가 많습니다.\n2. 데드 휠/오도메트리란 무엇인가요? 데드 휠과 오도메트리는 종종 같은 의미로 사용되지만, 사실 차이가 있습니다.\n오도메트리: 로봇의 위치를 계산하기 위해 센서를 사용하는 기술입니다. 데드 휠: 동력이 없는 옴니 휠로, 회전 인코더를 통해 이동 거리를 측정합니다. 이 데이터를 통해 로봇의 상대적 위치(x,y)와 방향을 계산할 수 있습니다. 데드 휠을 메카넘 휠에 비해 미끄러지는 정도가 작기에, 데드 휠을 사용할 경우 오차를 줄여 정확도를 크게 향상시킬 수 있습니다.\n데드 휠의 예시\r3. 두 바퀴와 세 바퀴 오도메트리의 차이점은 무엇인가요? 요약: 세 바퀴 구성은 루프 시간을 단축하여 드리프트를 줄이고 더 높은 정확도를 제공합니다.\n위에서 설명했듯이 표준 데드 휠(dead wheel) 구성은 여러 개의 무동력 옴니 휠(omni wheel)을 인코더와 연결하여 사용하는 방식입니다. 그러나 두 개 또는 세 개의 옴니 휠을 선택적으로 사용할 수 있습니다.\n두 바퀴 구성은 서로 수직으로 배치된 두 개의 데드 휠을 사용합니다.\n하나의 휠은 x 방향(앞쪽) 이동을 추적하고, 다른 하나는 y 방향(옆쪽) 이동을 추적합니다. 방향(heading)은 Rev Expansion/Control Hub IMU 또는 외부 센서를 통해 측정됩니다. 세 바퀴 구성은 두 개의 평행한 휠과 하나의 수직 휠을 사용합니다.\n두 평행 휠은 x 방향(앞쪽) 이동과 방향을 모두 추적합니다.\n헤딩은 두 평행 휠의 오프셋을 통해 계산됩니다. 수직 휠은 y 방향(옆쪽) 이동을 추적합니다. 왜 세 바퀴 구성을 선택해야 할까요? 추가 모듈 제작은 번거롭고, 비용이 약 30% 증가하기에 비효율적이라고 생각할 수 있지만, 현재로써는 세 바퀴 구성은 가장 정확한 옵션으로 평가받고 있습니다.\n이유:\nRev Expansion/Control Hub는 느린 I2C 구현을 사용하여 I2C 호출당 약 7ms의 지연 시간이 발생합니다.\nRev Expansion/Control Hub에 내장된 BNO055 IMU는 I2C를 통해 통신하므로, 헤딩을 계산할 때 이 7ms 지연이 추가됩니다. 데드 휠 데이터 읽기(대량 읽기 기준)에도 약 3ms가 소요되므로, 총 지연 시간은 약 10ms입니다.\n이 지연은 두 바퀴 구성에서 IMU를 통해 헤딩을 계산할 때 발생합니다. 반면, 세 바퀴 구성에서는 두 평행 휠을 통해 헤딩을 계산하므로 7ms I2C 호출이 필요하지 않습니다.\n세 개의 데드 휠 모두를 3ms 안에 읽을 수 있으므로(대량 읽기 기준, 모든 인코더가 동일한 Rev Hub에 연결된 경우), 루프 시간이 크게 단축됩니다. 이로 인해 정확도가 향상되고 드리프트가 현저히 줄어드는 결과를 얻을 수 있습니다. 향후 출시될 Control Hub는 Expansion Hub보다 3배 빠른 I/O 속도를 제공하므로, 두 구성 간의 차이가 줄어들 가능성이 있습니다.\n데드 휠을 어떻게 제작하나요? 데드 휠 모듈 제작에는 여러 세부 사항과 선택지가 존재합니다. 현재 기준으로 데드 휠 모듈 제작에 대한 자료는 많지 않습니다.\n모듈당 비용은 약 $30 이상이며, 세 바퀴 구성은 총 $100 이상의 비용이 들 수 있습니다.\n추가 정보를 원한다면 FTC Discord를 방문하세요.\n추천 오픈 소스 데드 휠 설계 자료:\nhttps://openodometry.weebly.com/\n4. 스플라인 경로란 무엇인가요? 스플라인 경로는 스플라인 곡선을 사용해 생성된 경로입니다.\n스플라인 곡선은 여러 점을 매끄럽게 연결하는 다항식 조각으로 이루어져 있습니다. 연속적인 경로를 따라 이동하면서 헤딩을 변경할 수 있어, 자율 주행 경로에 이상적입니다. Road Runner에서는 스플라인 경로를 자주 사용하며, 직선 경로를 단순히 연결하는 것보다 훨씬 부드러운 움직임을 제공합니다.\n5. 기본 단위를 변경할 수 있나요? Road Runner는 기본적으로 인치 단위를 사용합니다.\n공식 FAQ에 따르면, 기본 단위는 인치로 설정되어 있으며, 이를 변경하려면 Road Runner 인터페이스에 대한 래퍼를 직접 작성해야 합니다. 따라서 기본적으로 인치를 사용하는 것이 권장됩니다. 더 자세한 정보가 필요하다면 FTC Discord를 방문해 보세요! 😊 ","date":"2023-09-07","id":1,"permalink":"/docs/1-about-roadrunner/%EC%9E%90%EC%A3%BC-%EB%AC%BB%EB%8A%94-%EC%A7%88%EB%AC%B8-faq/","summary":"\u003ch2 id=\"1-pure-pursuit와의-차이점\"\u003e1. Pure Pursuit와의 차이점\u003c/h2\u003e\n\u003cp\u003eRoad Runner와 Pure Pursuit는 자주 비교되지만, 본질적으로 매우 다른 도구입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ePure Pursuit\u003c/strong\u003e: 비홀로노믹(Non-Holonomic) 드라이브 트레인을 위한 경로 추적 알고리즘으로, \u0026ldquo;룩어헤드 포인트(Look-Ahead Point)\u0026ldquo;를 사용해 다차원 경로를 따릅니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRoad Runner\u003c/strong\u003e: Ramsete, 가이드 벡터 필드 등 여러 경로 추적 알고리즘을 지원하며, 속도와 가속도를 제어하는 모션 프로파일링 기능을 포함합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e특히, Pure Pursuit는 가속도 제어가 없기 때문에 데드 휠 오도메트리 설치가 필수입니다. 또한, FTC 로봇 대부분이 홀로노믹(메카넘) 드라이브를 사용하기 때문에 Pure Pursuit는 잘 맞지 않는 경우가 많습니다.\u003c/p\u003e","tags":[],"title":"자주 묻는 질문 (FAQ)"},{"content":"\r주의\n계속하기 전에 아래 사항을 반드시 확인하세요!\n팁\n1. 이 튜토리얼은 Java 프로그래밍 언어와 FTC SDK에 익숙하다는 전제하에 작성되었습니다. 둘 다 시간이 지나고 실습을 통해 경험이 쌓이면 익숙해질 수 있습니다. 지금 당장은 자신이 부족하다고 느낄지 몰라도, 코드를 작성하면서 점점 더 나아질 거예요! 👊\n팁\n2. 이 개념들은 어렵고 복잡하게 느껴질 수 있습니다. 이 튜토리얼은 최대한 쉽게 설명하려고 노력했지만, 모든 사람에게 맞는 것은 아닐 수 있습니다. 도움이 필요하다면, FTC Discord에 많은 친절하고 똑똑한 사람들이 있으니 꼭 참여해보세요! Road Runner에 경험이 많은 사람들도 많습니다.\n팁\n3. 이 튜토리얼은 설치, 사용법, 팁과 트릭에 대해 다룹니다. 그러나 Road Runner의 내부 작동 방식에 대해 깊이 설명하지는 않습니다. PID 제어와 모션 프로파일링의 작동 방식을 깊이 이해하면 학습 과정이 훨씬 빨라질 것입니다. Road Runner의 공식 퀵스타트 문서를 확인해보는 것을 추천합니다. 여기에는 내부 작동 방식이 잘 설명되어 있습니다.\n주의\n튜닝 과정을 진행할 때 충분한 공간을 확보하는 것이 매우 중요합니다. 넉넉한 공간은 더 정확한 튜닝을 가능하게 합니다. 개인적으로 로봇이 주행할 수 있는 90인치 정도의 공간을 추천합니다. 최소한 필드 너비(72인치) 정도는 확보해야 합니다.\n이제 준비 완료! 다음 페이지로 이동해 시작해봅시다! 🚀 알아두어야 할 용어 많은 용어가 나오는데 잘 이해되지 않는다면 걱정하지 마세요. 이 페이지에서 주요 용어를 정리해 드립니다.\n혹시 이 페이지에 없는 반복적으로 등장하는 용어가 있다면, Discord (Noah#5396)로 연락하거나 GitHub Pull Request를 통해 추가 요청을 해주세요!\n로컬라이제이션 (Localization) 고급 FTC 팀들 사이에서 \u0026ldquo;로컬라이제이션\u0026quot;이라는 용어를 자주 듣게 될 것입니다. 로컬라이제이션이란 기본적으로 로봇이 현재 자신의 위치를 알고 있는 능력을 의미합니다. 자신의 위치를 모른 채 특정 지점으로 이동하는 것은 매우 어려운 일입니다(이는 폐쇄 루프 제어와 개방 루프 제어의 차이와 유사합니다). 로컬라이제이션은 일반적으로 오도메트리(odometry)를 통해 이루어지며, 때로는 VSLAM 같은 더 복잡한 방법(Intel Realsense T265 사용 등)을 사용할 수도 있습니다. 구동 엔코더나 외부 휠을 사용해 데이터를 수집하고, 이를 운동 방정식에 대입하여 로봇의 상대적 자세(x, y, 방향)를 계산합니다.\n모션 프로파일 (Motion Profile) 모션 프로파일은 특정 상태에 도달하기 위해 따라야 할 동작을 그래프로 나타낸 것입니다. Road Runner의 경우, 주로 로봇의 속도를 정의된 자세로 이동시키기 위한 그래프를 생성합니다(모션 프로파일은 엘리베이터와 같은 다른 구성 요소에도 생성될 수 있습니다). 간단히 말해, 모션 프로파일은 특정 지점으로 이동하기 위해 필요한 전체 움직임을 계획하는 것입니다. 최대 속도, 최대 가속도 등을 정의하여 이 그래프를 제어할 수 있습니다. 더 자세한 설명은 여기를 참조하세요. 또한, FRC 팀 254의 컨퍼런스 강연도 훌륭한 자료입니다.\n개방 루프 제어 vs 폐쇄 루프 제어 (Open vs Closed Loop Control) 이 둘의 차이는 피드백의 유무에 달려 있습니다. 피드백이 있으면 \u0026ldquo;루프를 닫을 수\u0026rdquo; 있습니다. 그렇다면 피드백이란 무엇일까요?\n예를 들어, 모터의 속도를 제어하려고 한다고 가정해봅시다. 개방 루프 제어는 원하는 값을 \u0026ldquo;추정\u0026quot;하는 방식입니다. 기존의 수학적 모델을 사용해 값을 계산한 뒤, 이를 적용해 원하는 결과를 기대합니다. 하지만 현실에서는 물리적 허용 오차, 전기적 노이즈 등의 이유로 정확한 결과를 얻기 어렵습니다.\n반면 폐쇄 루프 제어에서는 엔코더를 통해 실제 속도를 측정하고, 이를 기반으로 출력 전압을 조정합니다. 이 방식은 PID 컨트롤러를 통해 주로 구현됩니다.\nVector2d 2차원 벡터를 나타냅니다: X와 Y 좌표.\n// (x: 10, y: -5) 좌표에 벡터 생성 Vector2d myVector = new Vector2d(10, -5);\rPose2d 2차원 로봇 자세를 나타냅니다: X와 Y 좌표, 그리고 방향.\n로봇의 위치와 방향을 나타내며, 각도가 증가하면 반시계 방향으로 회전합니다(삼각함수에서 배운 단위 원과 동일). 각도는 반드시 라디안 단위로 표현해야 하므로 Math.toRadians() 함수를 사용해 도를 라디안으로 변환합니다.\n// (x: 10, y: -5) 좌표에서 90도 방향을 향하는 자세 생성 Pose2d myPose = new Pose2d(10, -5, Math.toRadians(90));\r","date":"2023-09-07","id":2,"permalink":"/docs/2-before-you-start/%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84%EC%97%90/","summary":"\u003cdiv class=\"callout callout-caution d-flex flex-row mt-4 mb-4 pt-4 pe-4 pb-2 ps-3\"\u003e\r\n  \u003csvg\n  xmlns=\"http://www.w3.org/2000/svg\"\n  width=\"24\"\n  height=\"24\"\n  viewBox=\"0 0 24 24\"\n  fill=\"none\"\n  stroke=\"currentColor\"\n  stroke-width=\"2\"\n  stroke-linecap=\"round\"\n  stroke-linejoin=\"round\"\n \n class=\"outline/alert-triangle svg-inline callout-icon me-2 mb-3\" id=\"svg-alert-triangle\" role=\"img\"\u003e\n  \u003cpath stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"/\u003e\n  \u003cpath d=\"M12 9v4\" /\u003e\n  \u003cpath d=\"M10.363 3.591l-8.106 13.534a1.914 1.914 0 0 0 1.636 2.871h16.214a1.914 1.914 0 0 0 1.636 -2.87l-8.106 -13.536a1.914 1.914 0 0 0 -3.274 0z\" /\u003e\n  \u003cpath d=\"M12 16h.01\" /\u003e\n\u003c/svg\u003e\r\n  \u003cdiv class=\"callout-content\"\u003e\r\n    \u003cdiv class=\"callout-title\"\u003e\r\n        \u003cp\u003e주의\u003c/p\u003e","tags":[],"title":"시작하기 전에"},{"content":"Road Runner 라이브러리를 설치하는 방법에는 두 가지가 있습니다.\n주의\nRoad Runner는 점차 레거시 소프트웨어로 전환되고 있어, 2023-24 시즌 이후에는 Quickstart가 최신 SDK 요구 사항과 호환되지 않을 수 있습니다. Driver Station에서 \u0026ldquo;로봇 컨트롤러가 오래되었습니다\u0026quot;라는 오류가 발생하면, FIRST 공식 SDK를 다운로드하고 방법 #2를 사용하세요.\n방법 #1은 더 간단한 옵션으로, Quickstart 저장소를 다운로드하는 것입니다. 이 저장소는 빈 FTC 시즌 프로젝트와 함께 Road Runner를 바로 실행할 수 있도록 필요한 종속성과 튜닝 관련 OpMode가 미리 설치되어 있습니다. 하지만 이미 기존 코드베이스가 있는 경우에는 이 방법이 적합하지 않을 수 있습니다.\n방법 #2는 Gradle을 사용해 Road Runner를 설치하고 Quickstart 저장소에서 필요한 파일을 복사해 기존 팀 프로젝트에 추가하는 방법입니다.\n설치 후, Rev Expansion Hub 또는 Control Hub 펌웨어를 업그레이드하는 것을 강력히 권장합니다. 자세한 방법은 아래에서 확인할 수 있습니다.\n방법 1: Quickstart 다운로드 Quickstart 저장소에 접속하세요. (이 저장소는 Iris_TheRainbow가 관리하며, 공식 Quickstart보다 최신 상태를 유지할 가능성이 높습니다.) 녹색 \u0026ldquo;Code\u0026rdquo; 버튼을 클릭한 뒤 \u0026ldquo;Download ZIP\u0026quot;을 선택하세요. 다운로드한 ZIP 파일을 원하는 디렉토리에 압축 해제하세요. Android Studio에서 해당 폴더를 열어주세요. 이제 Road Runner를 실행할 준비가 완료되었습니다! 방법 2: 기존 프로젝트에 RR 설치하기 ::: warning 이 설치 가이드는 SDK 9.1 기준으로 작성되었습니다. 이후 SDK 버전에서는 정확하지 않을 수 있습니다. :::\n프로젝트가 최신 FTC 표준 프로젝트 파일 구조(작성 시점 기준 SDK 9.1)와 동일하다고 가정합니다. 해당 프로젝트는 여기에서 확인할 수 있습니다.\n프로젝트 루트 디렉토리에서 build.dependencies.gradle 파일을 찾으세요.\nFtcRobotController ├── .github ├── FtcRobotController ├── TeamCode ├── doc ├── gradle/wrapper ├── libs ├── .gitignore ├── README.md ├── build.common.gradle ├── `build.dependencies.gradle` _(**이 파일**_) ├── build.gradle ├── gradle.properties ├── gradlew ├── gradlew.bat └── settings.gradle\rrepositories 블록 끝에 다음 코드를 추가하세요:\nmaven { url = \u0026#39;https://maven.brott.dev/\u0026#39; }\r그런 다음, dependencies 블록 끝에 아래 코드를 추가하세요:\nimplementation \u0026#39;com.acmerobotics.dashboard:dashboard:0.4.15\u0026#39;\r::: warning 이 가이드는 작성 시점(2024년 2월 17일) 기준 최신 상태입니다. 특히 2024-2025 FTC 시즌이 시작되면 이 웹사이트를 방문해 최신 버전을 확인하고 업데이트된 필드 다이어그램을 사용하세요. :::\nOpenRC를 사용하는 경우, 여기에서 대시보드 관련 별도 지침을 확인하세요.\nTeamCode/build.gradle 파일을 찾아 열어주세요. FtcRobotController ├── .github ├── FtcRobotController ├── TeamCode │ ├── src/main │ └── `build.gradle` _(**이 파일**_) ├── doc ├── gradle/wrapper ├── libs ├── .gitignore ├── README.md ├── build.common.gradle ├── build.dependencies.gradle ├── build.gradle ├── gradle.properties ├── gradlew ├── gradlew.bat └── settings.gradle\rTeamCode/build.gradle 파일에 아래 종속성을 추가하세요:\nimplementation \u0026#39;org.apache.commons:commons-math3:3.6.1\u0026#39; implementation \u0026#39;com.fasterxml.jackson.core:jackson-databind:2.12.7\u0026#39; implementation \u0026#39;com.acmerobotics.roadrunner:core:0.5.6\u0026#39;\rQuickstart 저장소를 다운로드하세요. Git을 사용하는 경우 아래 명령어를 실행하세요:\ngit clone --single-branch -b quickstart1 https://github.com/acmerobotics/road-runner-quickstart.git\rTeamCode 폴더에 있는 drive, util, trajectorysequence 폴더를 프로젝트의 적절한 위치(보통 TeamCode 폴더)로 이동하세요.\n펌웨어 업그레이드 Control Hub 또는 Expansion Hub 펌웨어를 최신 버전으로 업그레이드하는 것을 강력히 추천합니다. 펌웨어 버전 1.8.2는 다음과 같은 성능 개선 사항을 제공합니다:\nDC 모터 출력 선형성 향상 클로즈 루프 제어 개선 I2C 속도 향상 ESD 오류 복구를 위한 USB 복구 기능 Road Runner의 성능은 이러한 개선 사항의 직접적인 영향을 받습니다.\n펌웨어 업그레이드 방법은 REV 공식 문서에서 확인할 수 있습니다.\n이제 준비 완료! 설치가 끝났습니다. 이제 튜닝을 시작하세요! 🚀\n","date":"2023-09-07","id":3,"permalink":"/docs/3-installation/%EC%84%A4%EC%B9%98-%EB%B0%8F-%EC%A4%80%EB%B9%84/","summary":"\u003cp\u003eRoad Runner 라이브러리를 설치하는 방법에는 두 가지가 있습니다.\u003c/p\u003e\n\u003cdiv class=\"callout callout-caution d-flex flex-row mt-4 mb-4 pt-4 pe-4 pb-2 ps-3\"\u003e\r\n  \u003csvg\n  xmlns=\"http://www.w3.org/2000/svg\"\n  width=\"24\"\n  height=\"24\"\n  viewBox=\"0 0 24 24\"\n  fill=\"none\"\n  stroke=\"currentColor\"\n  stroke-width=\"2\"\n  stroke-linecap=\"round\"\n  stroke-linejoin=\"round\"\n \n class=\"outline/alert-triangle svg-inline callout-icon me-2 mb-3\" id=\"svg-alert-triangle\" role=\"img\"\u003e\n  \u003cpath stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"/\u003e\n  \u003cpath d=\"M12 9v4\" /\u003e\n  \u003cpath d=\"M10.363 3.591l-8.106 13.534a1.914 1.914 0 0 0 1.636 2.871h16.214a1.914 1.914 0 0 0 1.636 -2.87l-8.106 -13.536a1.914 1.914 0 0 0 -3.274 0z\" /\u003e\n  \u003cpath d=\"M12 16h.01\" /\u003e\n\u003c/svg\u003e\r\n  \u003cdiv class=\"callout-content\"\u003e\r\n    \u003cdiv class=\"callout-title\"\u003e\r\n        \u003cp\u003e주의\u003c/p\u003e","tags":[],"title":"설치 및 준비"},{"content":"시작하기 전에, 각 단계에서 무엇을 하는지 이해하는 것이 중요합니다.\n팁\n이 페이지는 Road Runner 공식 퀵스타트의 조율 가이드를 바탕으로 작성되었으며, 개인 경험을 바탕으로 한 추가적인 팁을 포함하고 있습니다. 보다 자세한 내용은 공식 가이드를 참고하세요.\nRoad Runner는 복잡한 수학적 계산을 통해 로봇의 동작을 제어하지만, 로봇이 매끄럽게 작동하려면 반드시 조율(Tuning) 과정이 필요합니다. 모터, 무게 등 로봇마다 다른 특성이 구동 방식에 영향을 미치기 때문에, 조율 가이드를 따라 각 로봇에 맞게 구동 체계를 조정해야 합니다.\n주의\n로봇에 무거운 부품을 추가하는 등 큰 변화가 있을 경우, 반드시 재튜닝이 필요합니다. 조율 과정은 이전보다 빠르게 진행될 수 있지만, 일관된 성능을 위해 권장됩니다.\n각 단계를 완료한 후에 다음 단계로 진행하세요.\n피드포워드(Feedforward)란 무엇인가? 피드 포워드 속도 제어는 전압을 속도로 변환하는 함수를 생성하는 개방 루프 시스템입니다. 이 과정에서 구동 중 실시간 피드백이 부족하다는 문제가 있지만, 병진 이동 PID가 이를 보완하여 에러를 수정합니다.\n주행 속도 PID (Drive Velocity PID)는 어디에 있나요? 주행 속도 PID는 더 이상 사용되지 않습니다. 그 이유는 여기에서 확인할 수 있습니다.\n드라이브 인코더 또는 오도메트리 사용 여부와 관계없이 피드포워드 방식을 사용하세요.\n드라이브 상수 설정 드라이브 상수(Drive Constants) 파일에는 로봇의 물리적 특성과 관련된 모든 정보가 포함됩니다. 예를 들어, 모터의 최대 RPM, 바퀴 반지름 등이 포함됩니다. 이 단계에서 발생하는 가장 심각한 오류는 보통 드라이브 상수에서 시작됩니다.\n예를 들어, 로봇이 지정된 거리의 절반만 이동한다면, 이는 드라이브 상수의 문제일 가능성이 높습니다.\n드라이브 상수 사용에 대한 자세한 내용은 드라이브 상수 설정 페이지에서 확인할 수 있습니다.\n데드 휠 설정 로봇에 데드 휠이 있다면, 드라이브 상수를 편집한 후 데드 휠을 설정해야 합니다. 데드 휠이 없다면 이 단계를 무시하세요.\n데드 휠에 대해 잘 모르겠다면 FAQ의 예제를 참고하세요.\n데드 휠 조율은 로컬라이제이션 테스트에서 수행됩니다. 데드 휠의 정확한 조율은 로봇의 정확한 로컬라이제이션 및 경로 추적을 위해 매우 중요합니다.\n로봇이 2개의 데드 휠을 사용하는지, 3개의 데드 휠을 사용하는지에 따라 설정이 달라집니다. 차이를 모르겠다면 FAQ를 참고하세요.\n자세한 내용은 데드 휠 설정 페이지에서 확인할 수 있습니다.\n로컬라이제이션 테스트 1 주의\n이 첫 번째 로컬라이제이션 테스트는 데드 휠 로컬라이제이션을 테스트 및 조율하기 위한 것입니다. 데드 휠를 사용하지 않기로 결정했다면 이 단계를 건너뛰세요.\n로컬라이제이션 테스트를 실행하고 로봇을 필드에서 이동시켜 로컬라이제이션과 관련된 문제를 찾으세요. 데드 휠 로컬라이제이션은 데드 휠을 설정한 후 조율해야 합니다.\n로컬라이제이션의 정확성은 경로 추적의 정확성에 큰 영향을 미칩니다.\n데드 휠을 사용하지 않는 경우, 이후 단계에서 로컬라이제이션 테스트를 수행합니다.\n자세한 내용은 데드 휠 조절 페이지에서 확인할 수 있습니다.\n주행 피드포워드 조율 피드포워드 방식을 선택했다면 피드포워드 상수를 조율해야 합니다.\n공식 Quickstart는 자동 튜너와 수동 튜너를 제공합니다. 하지만 일부 사용자는 자동 튜너가 최적의 결과를 제공하지 않는다고 느낄 수 있습니다.\n자동 조율 과정은 다음과 같습니다(공식 문서에서 발췌):\nkV와 kStatic을 찾기 위해 로봇은 전압을 천천히 증가시키는 정적 램프 테스트를 실행합니다. 이 과정에서 속도와 전압이 기록됩니다. 속도 대 전압 그래프에서 kV는 기울기, kStatic은 Y절편입니다.\n다음으로 kA를 찾기 위해 로봇은 정지 상태에서 급가속을 시도합니다. 이 과정에서 가속도, 속도, 전압이 기록됩니다. 가속도 대 전압 그래프에서 기울기는 kA입니다.\n자동 튜너는 kA 값을 매우 낮게 산출하는 경향이 있습니다. 따라서 수동 조율 방식을 추천합니다.\n자세한 내용은 주행 피드포워드 페이지에서 확인할 수 있습니다.\n주행 속도 PID 조율 [사용하지 않음!] 경고\n이 조율 방법을 따르지 마십시오. 피드 포워드 조율을 대신 사용하세요.\nDriveVelocityPIDTuner는 Rev Hub의 내장 모터 속도 제어기(RUN_USING_ENCODER 모드)를 조율하는 데 사용됩니다. PIDF 계수를 최적화하여 일관된 동작을 보장하는 것이 중요합니다.\nPIDF 계수는 로봇의 무게에 영향을 미치는 주요 변경 사항 이후에 반드시 조정해야 합니다.\n주행 속도 PID 조율 과정은 주행 속도 PID Tuning 페이지에 자세히 설명되어 있습니다. PIDF 값을 조정하여 원하는 동작을 얻을 수 있습니다.\n공식 Roadrunner 문서에서는 \u0026ldquo;약간의 진동이 발생하더라도 위상 지연을 제거하는 것을 우선시하라\u0026quot;고 권장하지만, 개인적으로는 특히 정지 상태에서 진동을 최소화하는 것이 더 낫다고 생각합니다.\n위상 지연을 제거하면 고속에서 매우 불안정한 동작을 유발할 수 있습니다. 이는 Rev Hub의 모터 제어 방식 때문일 가능성이 높습니다.\n더 자세한 기술적 내용을 알고 싶다면 FTC Discord를 통해 문의하세요.\n제 개인적인 조언은 진동을 최소화하고 병진 이동 PID를 통해 위상 지연 문제를 해결하는 것입니다.\n직진 테스트 직진 테스트는 피드포워드/속도 PID 조율의 효과를 확인하는 데 사용됩니다. StraightTest OpMode를 여러 번 실행하여 로봇이 일정한 거리 내에서 안정적으로 이동하는지 확인하세요.\n로봇이 매번 정확히 같은 위치에 도달하지 않아도 됩니다. 이후 로컬라이제이션을 통해 폐쇄 루프 피드백이 활성화될 것입니다.\n데드 휠 없이 엔코더만 사용하는 경우, 이 단계에서 엔코더 로컬라이제이션을 튜닝하게 됩니다.\n자세한 내용은 직진 테스트 페이지에서 확인할 수 있습니다.\n경로 폭 조율 경로 폭(Track Width)는 한 바퀴에서 평행한 다른 바퀴까지의 거리입니다. 이는 물리적으로 측정할 수 있지만, 실제 경로 폭는 여러 요인으로 인해 물리적 측정값과 다를 수 있습니다.\n이를 보정하기 위해 TrackWidthTuner OpMode를 실행하여 경험적 경로 폭를 계산합니다.\nTrackWidthTuner는 원하는 경험적 경로 폭에 1인치 정도의 오차 범위 내에서 도달합니다. TurnTest OpMode를 실행하고 드라이브 상수에서 경로 폭를 수정하여 수동으로 조정해야 할 수도 있습니다.\n자세한 내용은 Track Width Tuning 페이지에서 확인할 수 있습니다.\n회전 테스트 회전 테스트를 실행하여 경로 폭가 올바른지 확인하세요.\n자세한 내용은 회전 테스트 조율 페이지에서 확인할 수 있습니다.\n로컬라이제이션 테스트 2 주의\n두 번째 로컬라이제이션 테스트는 엔코더를 사용하는 로컬라이제이션을 테스트하기 위한 것입니다. 엔코더를 사용하지 않기로 결정했다면 이 단계를 건너뛰세요.\n로컬라이제이션 테스트를 실행하고 로봇을 필드에서 이동시켜 엔코더를 사용하는 로컬라이제이션과 관련된 문제를 찾으세요.\n엔코더를 사용하는 로컬라이제이션은 이전 단계에서 조율되어야 합니다. 로컬라이제이션의 정확성은 경로 추적의 정확성에 큰 영향을 미칩니다.\n두 번째 로컬라이제이션 테스트는 엔코더를 사용하는 구동의 정확성을 테스트하는 데 사용됩니다.\n데드 휠을 사용하여 로컬라이제이션을 조율했다면 이 단계를 건너뛰세요.\n자세한 내용은 로컬라이제이션 테스트 페이지에서 확인할 수 있습니다.\n팔로워 PID 조율 이 단계에서는 회전 PID와 병진 이동 (x/y) PID 두 가지를 조율합니다.\n이 PID는 폐쇄 루프 피드백 제어를 활성화하여 정확한 경로 추적을 보장합니다.\nBackAndForth OpMode를 실행하여 회전 및 병진 이동 PID를 대략적으로 조율한 후, FollowerPIDTuner OpMode를 사용해 세부적으로 조정합니다.\n자세한 내용은 팔로워 PID 조율 페이지에서 확인할 수 있습니다.\n스플라인 테스트 모든 조율이 완료된 후, 로봇은 스플라인 경로를 정확하게 따라야 합니다.\n스플라인 테스트가 실패하면 문제를 식별하고 해당 단계로 돌아가 다시 조율하세요.\n어려움을 겪고 있다면 FTC Discord에서 도움을 요청하세요!\n자세한 내용은 스플라인 테스트 페이지에서 확인할 수 있습니다.\n","date":"2023-09-07","id":4,"permalink":"/docs/4-tuning/%EA%B0%9C%EC%9A%94/","summary":"\u003cp\u003e시작하기 전에, 각 단계에서 무엇을 하는지 이해하는 것이 중요합니다.\u003c/p\u003e\n\u003cdiv class=\"callout callout-tip d-flex flex-row mt-4 mb-4 pt-4 pe-4 pb-2 ps-3\"\u003e\r\n  \u003csvg\n  xmlns=\"http://www.w3.org/2000/svg\"\n  width=\"24\"\n  height=\"24\"\n  viewBox=\"0 0 24 24\"\n  fill=\"none\"\n  stroke=\"currentColor\"\n  stroke-width=\"2\"\n  stroke-linecap=\"round\"\n  stroke-linejoin=\"round\"\n \n class=\"outline/rocket svg-inline callout-icon me-2 mb-3\" id=\"svg-rocket\" role=\"img\"\u003e\n  \u003cpath stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"/\u003e\n  \u003cpath d=\"M4 13a8 8 0 0 1 7 7a6 6 0 0 0 3 -5a9 9 0 0 0 6 -8a3 3 0 0 0 -3 -3a9 9 0 0 0 -8 6a6 6 0 0 0 -5 3\" /\u003e\n  \u003cpath d=\"M7 14a6 6 0 0 0 -3 6a6 6 0 0 0 6 -3\" /\u003e\n  \u003cpath d=\"M15 9m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0\" /\u003e\n\u003c/svg\u003e\r\n  \u003cdiv class=\"callout-content\"\u003e\r\n    \u003cdiv class=\"callout-title\"\u003e\r\n        \u003cp\u003e팁\u003c/p\u003e","tags":[],"title":"개요"},{"content":"\r팁\n여기에서 편집할 드라이브 상수 파일입니다.\nDriveConstants.java\n아직 이 파일을 프로젝트에 복사하지 않았다면, 복사해서 사용하세요!\n구성기(Configurator)를 사용하면 상수를 빠르게 생성할 수 있습니다. (단 현재 문서에서는 아직 기능을 지원하지 않습니다.)\n기능을 이용하기 위해서는 아래 버튼을 클릭한 후 Configure Me! 버튼을 눌러주세요.\n구성기 사용하러 가기\n아래에서는 각 상수가 무엇을 의미하는지 하나씩 살펴보겠습니다.\n경고\n자동 구성을 사용하는 경우, IMU 정보를 직접 파일에 추가해야 합니다. IMU 정보는 이곳에서 확인하세요.\n현재 단계는 드라이브 상수 설정 단계입니다.\n회전당 틱 수 (TPR) \u0026amp; 최대 RPM /* DriveConstants.java 파일의 약 24~25번째 줄 */ public static final double TICKS_PER_REV = 1; public static final double MAX_RPM = 1;\rTICKS_PER_REV 이 값은 모터 엔코더가 한 바퀴 회전할 때 카운트하는 \u0026ldquo;틱\u0026quot;의 수를 나타냅니다. 모터의 사양은 제조업체의 사이트에서 확인할 수 있습니다.\n예를 들어, goBILDA의 5202/5203/5204 모터의 경우 여기에 있는 각 모터의 사양 페이지에서 \u0026ldquo;Specs\u0026rdquo; 섹션에 표시된 Encoder Resolution 값을 사용해야 합니다.\n다음은 goBILDA가 아닌 몇몇 모터의 사양 리스트입니다. 일부 제조업체는 이 정보를 명확하게 제공하지 않으므로 참고하시기 바랍니다. (goBILDA에 감사드립니다!)\n모터 회전당 틱 수 최대 RPM REV HD Hex 40:1 Spur 1120 150 REV HD Hex 20:1 Spur 560 300 REV HD Hex 20:1 Planetary* 537.6 312.5 NeveRest Classic 60 1680 105 NeveRest Classic 40 1120 160 NeveRest Orbital 20* 537.6 349 NeveRest Orbital 3.7 103.6 1780 TETRIX TorqueNADO 60:1 1440 100 TETRIX TorqueNADO 40:1 960 150 TETRIX TorqueNADO 20:1 480 480 MAX_RPM 이 값은 권장 전압(12V)에서 모터가 도달할 수 있는 최대 RPM(분당 회전 수)을 나타냅니다.\n* 이러한 모터는 20:1 비율로 표시되지만, 실제로는 19.2:1의 비율을 가지고 있습니다. 이는 플래니터리 기어 구조로 인해 20:1 스퍼 모터와 속도/틱 값이 다릅니다.\n엔코더 사용 및 모터 속도 PID 설정 /* DriveConstants.java 파일의 약 35~37번째 줄 */ public static final boolean RUN_USING_ENCODER = true; public static PIDFCoefficients MOTOR_VELO_PID = new PIDFCoefficients(0, 0, 0, getMotorVelocityF(MAX_RPM / 60 * TICKS_PER_REV));\rRUN_USING_ENCODER 이 값은 FTC SDK에 내장된 RunMode 중 하나인 RUN_USING_ENCODER를 사용할지 여부를 결정합니다. 이를 통해 모터를 \u0026ldquo;전력\u0026rdquo; (전압)이 아니라 속도로 제어할 수 있는 온보드 속도 PID를 활용할 수 있습니다. 이 값을 true로 설정하면 모든 모터가 속도 제어 모드로 자동 설정됩니다.\nRUN_USING_ENCODER는 구동 엔코더를 사용할 때만 사용할 수 있습니다. 구동 엔코더를 사용하지 않는 경우 이 값을 false로 설정하세요.\n주의\n피드포워드(Fedforward) 튜닝을 사용하는 것이 권장되므로, 구동 엔코더를 사용하더라도 이 값을 false로 설정해 두는 것이 좋습니다.\nMOTOR_VELO_PID 이 값은 사용할 PID 값을 저장합니다. SDK의 기본 PIDF 값은 부하 없이 자유롭게 회전하는 모터를 기준으로 조정되었으며, 이는 구동 트레인에는 적합하지 않습니다.\n따라서 Quickstart는 이 값을 기본값인 0으로 설정하며, 나중에 튜닝을 진행합니다.\n주의\n피드포워드 제어 방식이 권장되므로 이 값을 변경하지 마세요.\n바퀴 반지름 / 기어비 / 트랙 폭 /* DriveConstants.java 파일의 약 47~49번째 줄 */ public static double WHEEL_RADIUS = 2; // 인치 단위 public static double GEAR_RATIO = 1; // 출력(바퀴) 속도 / 입력(모터) 속도 public static double TRACK_WIDTH = 1; // 인치 단위\rWHEEL_RADIUS 구동 트레인의 바퀴 반지름을 나타냅니다. 이 값은 직경이 아니라 반지름이어야 합니다.\nGEAR_RATIO 출력(바퀴) 속도를 입력(모터) 속도로 나눈 값입니다.\n기어나 벨트 없이 직구동(direct drive)을 사용하는 경우, GEAR_RATIO는 1로 설정해야 합니다.\n기어비가 1보다 크면 바퀴가 모터보다 더 빠르게 회전함을 나타내고, 1보다 작으면 바퀴가 모터보다 더 느리게 회전함을 나타냅니다.\n예를 들어, 2019년 v1 goBILDA Strafer Kit에는 1:2 기어가 포함되어 있어 출력 속도가 절반으로 줄어듭니다. 이 경우 기어비는 1/2 또는 0.5입니다.\n주의\n기어비를 분수로 설정할 경우, 반드시 소수값을 사용하세요.\n// 이렇게 하면 안 됩니다 public static double GEAR_RATIO = 2 / 3; // 이렇게 하세요 public static double GEAR_RATIO = 2.0 / 3.0;\r첫 번째 경우는 정수 나누기(integer division)로 처리되어 값이 0이 된 다음 double 타입으로 변환됩니다.\nTRACK_WIDTH 한쪽 바퀴의 중심에서 평행한 다른 쪽 바퀴의 중심까지의 거리입니다.\n이 값은 대략적인 추정치만으로도 충분하며, 나중에 경험적으로 튜닝할 것입니다.\n2019/20 Skystone 시즌의 3658 Bosons 로봇\rkV/kA/kStatic /* DriveConstants.java 파일의 약 57~59번째 줄 */ public static double kV = 1.0 / rpmToVelocity(MAX_RPM); public static double kA = 0; public static double kStatic = 0;\r이 값들은 구동 모터의 피드포워드 게인을 나타냅니다.\n피드포워드 방식을 선택한 경우, 나중에 값을 튜닝할 수 있습니다. 현재는 기본값으로 두세요.\nkV 단위: 볼트 * 초 / 미터 이론적으로, kV는 12볼트를 모터의 이론적 자유 속도로 나눈 값입니다. kA 단위: 볼트 * 초² / 미터 kStatic 단위: 볼트 모터 모델에 대한 추가 정보는 Controls Engineering in FRC by Tyler Veness에서 확인할 수 있습니다.\n이 상수들의 효과는 나중에 시연을 통해 설명할 예정입니다.\n기본 제한값 설정(Base Constraints) /* DriveConstants.java 파일의 약 68~71번째 줄 */ public static double MAX_VEL = 30; public static double MAX_ACCEL = 30; public static double MAX_ANG_VEL = Math.toRadians(180); public static double MAX_ANG_ACCEL = Math.toRadians(180);\rMAX_VEL 로봇이 달성할 수 있는 최대 속도를 정의합니다.\n이 값은 로봇이 가속하여 도달할 수 있는 가장 빠른 속도를 나타냅니다. 기본값은 30인치/초입니다. 이론적인 최대 속도는 아래의 공식을 통해 계산할 수 있습니다:\n로봇의 최대 속도 제약은 모터 최대 속도의 80%를 초과하지 않도록 설정하는 것이 좋습니다. 배터리 전압 감소, 무게 등 여러 요인으로 인해 이론적인 최대 속도에 도달하기 어려울 수 있습니다.\n최대 속도를 더 높게 설정할 수도 있지만, 로봇이 해당 속도에 도달하지 못하면 경로 추적 성능이 저하될 수 있습니다.\nMaxVelocityTuner 오프모드를 사용하여 최대 속도를 실험적으로 정의할 수 있습니다. 그러나, MAX_VEL은 MaxVelocityTuner 출력값의 **90~95%**로 설정하는 것이 권장됩니다.\nMAX_ACCEL 로봇이 가속할 수 있는 최대 가속도를 정의합니다.\n이 값은 속도가 얼마나 빠르게 증가하는지를 나타냅니다. 기본값은 30인치/초²입니다.\n처음에는 이 값을 최대 속도(MAX_VEL)와 동일하게 설정하는 것이 권장되며, 이는 대략적인 기준입니다.\n실험적으로 값을 결정하려면 가속도를 점진적으로 높이면서 경로 추적 성능이 저하되는 시점을 찾으면 됩니다.\n이 작업은 PID 튜닝 후에 수행하는 것이 더 쉽습니다.\nMAX_ANG_VEL 로봇이 회전할 수 있는 최대 각속도를 정의합니다.\n이 값은 로봇이 가장 빠르게 회전할 수 있는 속도를 나타내며 기본값은 180°/초입니다.\n최대 각속도는 최대 접선 속도(MAX_VEL)를 트랙 폭(TRACK_WIDTH)으로 나누어 계산할 수 있습니다.\n그러나 실험적으로 값을 결정하거나 기본값을 사용하는 것이 좋습니다.\n이론적인 최대 각속도와 측정값은 잘 일치하지 않을 수 있습니다.\nMAX_ANG_ACCEL 로봇이 회전할 수 있는 최대 각가속도를 정의합니다.\n이 값은 로봇의 각속도가 얼마나 빠르게 증가할 수 있는지를 나타내며 기본값은 180°/초²입니다.\n실험적으로 값을 찾을 수 있지만, 이를 정확히 측정하는 것은 어려울 수 있으므로 기본값을 사용하는 것이 좋습니다.\nSampleMecanumDrive - 하드웨어 ID SampleMecanumDrive.java 파일을 엽니다.\n/* SampleMecanumDrive.java 파일의 약 102~105번째 줄 */ leftFront = hardwareMap.get(DcMotorEx.class, \u0026#34;leftFront\u0026#34;); leftRear = hardwareMap.get(DcMotorEx.class, \u0026#34;leftRear\u0026#34;); rightRear = hardwareMap.get(DcMotorEx.class, \u0026#34;rightRear\u0026#34;); rightFront = hardwareMap.get(DcMotorEx.class, \u0026#34;rightFront\u0026#34;);\r모터 ID가 Rev Hub 설정에서의 ID와 일치하는지 확인하세요.\nIMU 방향 설정 드라이브 엔코더 로컬라이제이션을 사용 중이라면, DriveConstants.java 파일에서 RevHubOrientationOnRobot을 찾아 설정하거나, 존재하지 않는다면 아래 코드와 같이 추가하세요.\n자세한 설정 방법은 FTC 문서를 참조하세요.\nControl Hub 방향 예제\r/* DriveConstants.java 파일의 약 76번째 줄 */ public static RevHubOrientationOnRobot.LogoFacingDirection LOGO_FACING_DIR = RevHubOrientationOnRobot.LogoFacingDirection.UP; public static RevHubOrientationOnRobot.UsbFacingDirection USB_FACING_DIR = RevHubOrientationOnRobot.UsbFacingDirection.FORWARD;\rIMU 속도 설정 드라이브 엔코더 로컬라이제이션이나 두 개의 데드 휠을 사용하는 경우, SampleMecanumDrive.java 파일의 맨 아래에서 getExternalHeadingVelocity 함수를 찾으세요.\n이 함수가 IMU가 로봇의 축을 따라 회전하는 축(예: z 축)에 대해 올바른 값을 반환하는지 확인하세요.\nREV Hub가 평평하게 장착된 경우 로봇은 z축을 따라 회전하며, 다른 방향으로 장착된 경우 x 또는 y 축을 따라 회전할 수 있습니다.\n/* SampleMecanumDrive.java 파일의 약 296~299번째 줄 */ @Override public Double getExternalHeadingVelocity() { return (double) imu.getRobotAngularVelocity(AngleUnit.RADIANS).zRotationRate; }\rControl Hub 축 다이어그램\r모터 방향 설정 SampleMecanumDrive.java 파일의 약 125~127번째 줄로 이동합니다. \u0026ldquo;// TODO: reverse any motors using DcMotor.setDirection()\u0026ldquo;라는 주석을 찾으세요.\n그 아래에 로봇의 한쪽 모터 방향을 반대로 설정하세요.\n테스트 중 로봇이 원을 그리며 움직이거나, 방향이 반대이거나, 경로를 제대로 따르지 않는다면 여기로 돌아와 문제를 수정하세요.\n/* SampleMecanumDrive.java 파일의 약 125~127번째 줄 */ // TODO: reverse any motors using DcMotor.setDirection() rightFront.setDirection(DcMotorSimple.Direction.REVERSE); // 필요 시 추가 rightRear.setDirection(DcMotorSimple.Direction.REVERSE); // 필요 시 추가\r모터 설정 문제를 해결하려면 Motor Direction Debugger opmode를 참조하세요.\n@Disabled 주석을 제거하고, opmode의 지침을 따르세요.\n또한, 아래의 goBILDA 메카넘 휠 방향 차트를 참고하여 문제를 진단하고 적절히 수정하세요.\ngoBILDA 메카넘 휠 방향 차트\r","date":"2023-09-07","id":5,"permalink":"/docs/4-tuning/%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B8%8C-%EC%83%81%EC%88%98-%EC%84%A4%EC%A0%95-drive-constant/","summary":"\u003cdiv class=\"callout callout-tip d-flex flex-row mt-4 mb-4 pt-4 pe-4 pb-2 ps-3\"\u003e\r\n  \u003csvg\n  xmlns=\"http://www.w3.org/2000/svg\"\n  width=\"24\"\n  height=\"24\"\n  viewBox=\"0 0 24 24\"\n  fill=\"none\"\n  stroke=\"currentColor\"\n  stroke-width=\"2\"\n  stroke-linecap=\"round\"\n  stroke-linejoin=\"round\"\n \n class=\"outline/rocket svg-inline callout-icon me-2 mb-3\" id=\"svg-rocket\" role=\"img\"\u003e\n  \u003cpath stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"/\u003e\n  \u003cpath d=\"M4 13a8 8 0 0 1 7 7a6 6 0 0 0 3 -5a9 9 0 0 0 6 -8a3 3 0 0 0 -3 -3a9 9 0 0 0 -8 6a6 6 0 0 0 -5 3\" /\u003e\n  \u003cpath d=\"M7 14a6 6 0 0 0 -3 6a6 6 0 0 0 6 -3\" /\u003e\n  \u003cpath d=\"M15 9m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0\" /\u003e\n\u003c/svg\u003e\r\n  \u003cdiv class=\"callout-content\"\u003e\r\n    \u003cdiv class=\"callout-title\"\u003e\r\n        \u003cp\u003e팁\u003c/p\u003e","tags":[],"title":"드라이브 상수 설정 (Drive Constant)"},{"content":"\r경고\n데드 휠을 사용하지 않는 경우, 이 섹션은 건너뛰세요.\n현재 단계는 드라이브 상수 설정 단계입니다.\n구성은 데드 휠이 2개인지 3개인지에 따라 달라집니다. 차이를 모르겠다면 FAQ를 참고하세요.\n두 개의 데드 휠을 사용하는 경우, Two-Wheel Odometry 섹션만 읽으세요. 세 개의 데드 휠을 사용하는 경우, Three-Wheel Odometry 섹션만 읽으세요. 오도메트리를 2개 사용하는 경우 (Two-Wheel Odometry) 두 휠 구성을 사용하는 경우, 방향(heading) 소스로 자이로스코프를 사용합니다. 기본적으로 REV Hub의 내장 BNO055 자이로스코프가 사용됩니다.\n다른 자이로스코프를 사용하려면, SampleMecanumDrive.java 파일에서 선언하고 getRawExternalHeading() 함수를 오버라이드하세요.\n이 파일을 다운로드한 후, TeamCode 폴더에 저장하세요. 파일 정리를 위해 StandardTrackingWheelLocalizer.java 파일 근처에 저장하는 것을 추천합니다.\n다운로드한 TwoWheelTrackingLocalizer.java 파일을 열어 수정하세요.\n회전당 틱 수 (TPR) / 바퀴 반지름 / 기어비 설정 /* TwoWheelTrackingLocalizer.java 파일의 37-39번째 줄 */ public static double TICKS_PER_REV = 0; public static double WHEEL_RADIUS = 2; // 인치 단위 public static double GEAR_RATIO = 1; // 출력(바퀴 속도) / 입력(엔코더 속도)\rTICKS_PER_REV: 엔코더가 한 바퀴 회전할 때 계산하는 \u0026ldquo;틱\u0026rdquo; 수입니다. 엔코더 사양은 제조사 웹사이트에서 확인하세요. Counts Per Revolution 또는 CPR 항목을 참고하세요. REV Through Bore Encoder의 경우 TICKS_PER_REV 값은 8192입니다. WHEEL_RADIUS: 데드 바퀴의 반지름입니다. 지름이 아닌 반지름 값을 입력하세요. GEAR_RATIO: 출력(바퀴 속도)과 입력(엔코더 속도)의 비율입니다. 엔코더에 기어비를 설정하지 않았다면 1로 설정하세요. 수직/수평 X/Y 설정 /* TwoWheelTrackingLocalizer.java 파일의 41-45번째 줄 */ public static double PARALLEL_X = 0; // 수평 X, X는 전후 방향 public static double PARALLEL_Y = 0; // 수평 Y, Y는 좌우 방향 public static double PERPENDICULAR_X = 0; // 수직 X, X는 전후 방향 public static double PERPENDICULAR_Y = 0; // 수직 Y, Y는 좌우 방향\r수직 및 수평 바퀴의 X/Y 좌표를 입력하세요. X축은 전후 방향, Y축은 좌우 방향입니다. 이는 로봇 공학 및 항공 분야에서 일반적인 표준입니다.\n17508 Rising Tau의 2019/20 Skystone 로봇\r엔코더 방향 설정 경우에 따라 Encoder.setDirection(Encoder.Direction.REVERSE)를 사용해 엔코더의 방향을 반전시켜야 합니다.\n예시:\n/* TwoWheelTrackingLocalizer.java 파일의 60-63줄 */ parallelEncoder = new Encoder(hardwareMap.get(DcMotorEx.class, \u0026#34;parallelEncoder\u0026#34;)); perpendicularEncoder = new Encoder(hardwareMap.get(DcMotorEx.class, \u0026#34;perpendicularEncoder\u0026#34;)); // TODO: Encoder.setDirection(Encoder.Direction.REVERSE)로 엔코더를 반대로 설정하세요. // 예시) 수직 엔코더의 방향을 반대로 설정해야 하는 경우: perpendicularEncoder.setDirection(Encoder.Direction.REVERSE);\r경고\nRev Through Bore 엔코더를 사용하는 경우 아래 내용을 반드시 참조하세요.\nRev Through Bore 엔코더 주의사항\nREV Through Bore 엔코더를 사용하는 경우, 속도가 32767 cps (counts per second)를 초과하면 정수 오버플로우가 발생할 수 있습니다. 이는 REV Hub 펌웨어가 속도 데이터를 16비트 정수로 전송하기 때문입니다. 이를 해결하려면 getRawVelocity() 대신 getCorrectedVelocity()를 사용하세요.\n/* TwoWheelTrackingLocalizer.java 파일의 86-95줄 */ public List\u0026lt;Double\u0026gt; getWheelVelocities() { //TODO : 인코더 속도가 초당 32767 카운트를 초과할 경우, Encoder.getRawVelocity()를 Encoder.getCorrectedVelocity()로 변경하여 보정 메서드를 활성화하세요. return Arrays.asList( encoderTicksToInches(parallelEncoder.getCorrectedVelocity()), encoderTicksToInches(perpendicularEncoder.getCorrectedVelocity()) ); }\r하드웨어 ID 확인 /* TwoWheelTrackingLocalizer.java 파일의 60-61줄 */ parallelEncoder = new Encoder(hardwareMap.get(DcMotorEx.class, \u0026#34;parallelEncoder\u0026#34;)); perpendicularEncoder = new Encoder(hardwareMap.get(DcMotorEx.class, \u0026#34;perpendicularEncoder\u0026#34;));\r여기서 사용한 ID가 REV Hub 설정의 ID와 일치하는지 확인하세요.\nIMU 설정 /* SampleMecanumDrive.java 파일의 134-137줄 */ imu = hardwareMap.get(BNO055IMU.class, \u0026#34;imu\u0026#34;); BNO055IMU.Parameters parameters = new BNO055IMU.Parameters(); parameters.angleUnit = BNO055IMU.AngleUnit.RADIANS; imu.initialize(parameters);\rIMU가 SampleMecanumDrive.java 클래스에서 초기화되어 있는지 확인하세요. Quickstart를 다운로드했으며 REV Hub IMU를 사용 중이라면 변경할 필요가 없습니다. 외부 자이로를 사용하는 경우, 이 섹션을 수정하세요.\nIMU 속도 축 설정 SampleMecanumDrive.java 파일 하단의 getExternalHeadingVelocity 함수에서 함수가 IMU가 회전하는 축을 구성에 맞게 반환하는지 확인하세요. 파일에 제공된 ASCII 다이어그램을 참조하여 어떤 축을 선택해야 하는지 확인할 수 있습니다. REV Hub가 평평하게 장착되어 있으면 로봇은 Z축을 중심으로 회전합니다. 모터 포트가 위 또는 아래를 향하고 있는 쪽에 있으면 로봇은 Y축을 중심으로 회전합니다. 서보 포트가 위 또는 아래를 향하고 있으면 로봇이 X축을 중심으로 회전합니다.\n/* SampleMecanumDrive.java 파일의 399-419줄 */ @Override public Double getExternalHeadingVelocity() { // TODO: 설정에 맞게 이 값을 변경해야 합니다 // | Z 축 // | // (모터 포트 측면) | / X 축 // ____|__/____ // Y 축 / * | / /| (IO 측면) // _________ /______|/ // I2C // /___________ // 디지털 // |____________|/ 아날로그 // // (서보 포트 측면) // // 양의 X 축은 USB 포트가 있는 방향을 가리킵니다. // // 축 회전 속도를 필요에 따라 조정하세요. // REV Hub/Control Hub가 평평한 표면에 놓여 있다고 가정하면 // 기본 설정은 Z 축을 기준으로 회전합니다. return (double) imu.getAngularVelocity().zRotationRate; }\rSampleMecanumDrive에서 로컬라이저(Localizer) 설정하기 로컬라이저 구성을 완료한 후, 다시 SampleMecanumDrive.java 파일로 돌아갑니다.\n약 168번째 줄을 확인하세요. \u0026ldquo;// TODO: if desired, use setLocalizer() to change the localization method\u0026ldquo;라는 주석을 찾을 수 있을 것입니다.\n이 주석 아래에 다음 줄을 추가하세요:\n/* 약 168번째 줄 - SampleMecanumDrive.java */ // TODO: if desired, use setLocalizer() to change the localization method // for instance, setLocalizer(new ThreeTrackingWheelLocalizer(...)); setLocalizer(new TwoWheelTrackingLocalizer(hardwareMap, this));\r이렇게 로컬라이저을 완료할 수 있습니다.\n오도메트리를 3개 사용하는 경우 (Three-Wheel Odometry) 세 바퀴 오도메트리 설정을 선택한 경우, 헤딩(heading)의 소스로 두 개의 평행 바퀴를 사용하게 됩니다.\nStandardTrackingWheelLocalizer.java 파일을 엽니다.\n회전당 틱 수 (TPR) / 바퀴 반지름 / 기어비 설정 /* StandardTrackingWheelLocalizer.java - 30~32번째 줄 */ public static double TICKS_PER_REV = 0; public static double WHEEL_RADIUS = 2; // 인치 단위 public static double GEAR_RATIO = 1; // 출력(바퀴) 속도 / 입력(엔코더) 속도\rTICKS_PER_REV: 인코더가 한 바퀴 회전 시 카운트하는 \u0026ldquo;틱(tick)\u0026ldquo;의 개수입니다. 인코더 사양은 제조사의 사이트에서 확인할 수 있습니다. Counts Per Revolution(CPR) 값을 찾으세요. 예를 들어, REV Through Bore Encoder의 경우 TICKS_PER_REV는 8192입니다. WHEEL_RADIUS: 데드 휠의 반지름입니다. 반드시 반지름(radius)을 사용하고 직경(diameter)을 사용하지 않도록 주의하세요. GEAR_RATIO: 출력(바퀴) 속도와 입력(엔코더) 속도의 비율입니다. 엔코더에 기어를 사용하지 않는 경우 1로 유지하세요. 측면 거리 (Lateral Distance)와 전방 오프셋 (Forward Offset) 설정 /* StandardTrackingWheelLocalizer.java - 34~35번째 줄 */ public static double LATERAL_DISTANCE = 10; // 인치 단위, 좌우 바퀴 간 거리 public static double FORWARD_OFFSET = 4; // 인치 단위, 중심 축에서 전면 바퀴까지의 오프셋 거리\rLATERAL_DISTANCE: 좌우 바퀴 간의 거리입니다. FORWARD_OFFSET: 회전 중심에서 중앙 휠까지의 거리입니다. 중앙 휠이 바퀴보다 앞에 있다면 양수, 뒤에 있다면 음수 값을 사용합니다. 17508 Rising Tau의 2019/20 Skystone 로봇\r엔코더 방향 설정 경우에 따라 Encoder.setDirection(Encoder.Direction.REVERSE)를 사용해 엔코더의 방향을 반전시켜야 합니다.\n예시:\n/* StandardTrackingWheelLocalizer.java - 46~63번째 줄 */ leftEncoder = new Encoder(hardwareMap.get(DcMotorEx.class, \u0026#34;leftEncoder\u0026#34;)); rightEncoder = new Encoder(hardwareMap.get(DcMotorEx.class, \u0026#34;rightEncoder\u0026#34;)); frontEncoder = new Encoder(hardwareMap.get(DcMotorEx.class, \u0026#34;frontEncoder\u0026#34;)); // TODO: 인코더 방향을 바꿀 때는 \u0026#34;Encoder.setDirection(Encoder.Direction.REVERSE)\u0026#34;를 사용. // 예시) 중앙 인코더를 반전시켜야 할 경우: frontEncoder.setDirection(Encoder.Direction.REVERSE);\r이 코드를 통해 엔코더의 방향을 올바르게 설정할 수 있습니다.\n경고\nRev Through Bore 엔코더를 사용하는 경우 아래 내용을 반드시 참조하세요.\nRev Through Bore 엔코더 주의사항\nREV Through Bore 엔코더를 사용하는 경우, 속도가 32767 cps (counts per second)를 초과하면 정수 오버플로우가 발생할 수 있습니다. 이는 REV Hub 펌웨어가 속도 데이터를 16비트 정수로 전송하기 때문입니다. 이를 해결하려면 getRawVelocity() 대신 getCorrectedVelocity()를 사용하세요.\n/* TwoWheelTrackingLocalizer.java 파일의 86-95줄 */ public List\u0026lt;Double\u0026gt; getWheelVelocities() { //TODO : 인코더 속도가 초당 32767 카운트를 초과할 경우, Encoder.getRawVelocity()를 Encoder.getCorrectedVelocity()로 변경하여 보정 메서드를 활성화하세요. return Arrays.asList( encoderTicksToInches(parallelEncoder.getCorrectedVelocity()), encoderTicksToInches(perpendicularEncoder.getCorrectedVelocity()) ); }\rSampleMecanumDrive에서 로컬라이저(Localizer) 설정하기 로컬라이저 구성을 완료했다면, SampleMecanumDrive.java 파일로 돌아갑니다.\n대략 131번째 줄에서 \u0026ldquo;// TODO: if desired, use setLocalizer() to change the localization method\u0026ldquo;라는 주석을 찾을 수 있을 겁니다.\n이 주석 아래에 다음 줄을 추가하세요:\n/* 약 131번째 줄 - SampleMecanumDrive.java */ // TODO: if desired, use setLocalizer() to change the localization method // for instance, setLocalizer(new ThreeTrackingWheelLocalizer(...)); setLocalizer(new StandardTrackingWheelLocalizer(hardwareMap));\r이렇게 로컬라이저 설정을 완료할 수 있습니다.\nIMU 제거 세 바퀴 오도메트리(Three-Wheel Odometry) 방식에서는 IMU가 필요하지 않습니다. 따라서 SampleMecanumDrive에서 IMU 초기화를 제거하는 것이 좋습니다. IMU 초기화는 운영 모드(opmode) 초기화 시간을 2~3초 늘릴 수 있으며, 불필요한 시간이 소요될 수 있습니다.\nSampleMecanumDrive.java 파일에서 다음 코드를 찾아 삭제하세요:\n/* 약 134~137번째 줄 - SampleMecanumDrive.java */ // TODO: adjust the names of the following hardware devices to match your configuration imu = hardwareMap.get(BNO055IMU.class, \u0026#34;imu\u0026#34;); BNO055IMU.Parameters parameters = new BNO055IMU.Parameters(); parameters.angleUnit = BNO055IMU.AngleUnit.RADIANS; imu.initialize(parameters);\r그리고 안전을 위해, 아래 메서드들의 반환값을 0으로 변경하세요:\n/* 약 393~396번째 줄 - SampleMecanumDrive.java */ @Override public double getRawExternalHeading() { return 0; } @Override public Double getExternalHeadingVelocity() { return 0.0; }\r조율 (Tuning) - 오도메트리 두 개를 사용하는 경우 (Two-Wheel Odometry) 데드 휠(Dead Wheel)을 사용한 오도메트리의 튜닝은 매우 중요한 과정입니다. 이 과정은 Road Runner뿐만 아니라 FTCLib 또는 직접 개발한 경로 추적 시스템에서도 중요한 역할을 합니다. 이것의 목표는 로컬라이제이션(Localization)의 정확도를 최대화하는 것입니다.\n바퀴 반지름 조정 팁\n이 과정이 모든 사용자에게 필수는 아니지만, 적용하면 약 1% 더 정확한 위치 추적이 가능합니다. 예를 들어, 100인치 이동 시 1% 오차는 1인치 차이를 줄이는 데 도움이 됩니다. FTC Skystone 시즌(2019-2020) 동안, 4~5개의 돌을 옮기는 자율 주행 루틴은 100인치 이상을 이동하며, 이런 차이가 큰 영향을 미칠 수 있었습니다.\n노트\n아래의 과정이 적용된 전체 코드는 예제 코드를 참고하세요.\nTwoWheelTrackingLocalizer.java 파일을 엽니다. 클래스 내부에 두 개의 변수를 추가하세요: /* 약 46~47번째 줄 - TwoWheelTrackingLocalizer.java */ public static double X_MULTIPLIER = 1; // X 방향 보정 계수 public static double Y_MULTIPLIER = 1; // Y 방향 보정 계수\r다음과 같이 getWheelPositions()와 getWheelVelocities() 함수에 보정 계수를 추가합니다: /* 약 77~97번째 줄 - TwoWheelTrackingLocalizer.java */ @NonNull @Override public List\u0026lt;Double\u0026gt; getWheelPositions() { return Arrays.asList( encoderTicksToInches(parallelEncoder.getCurrentPosition()) * X_MULTIPLIER, encoderTicksToInches(perpendicularEncoder.getCurrentPosition()) * Y_MULTIPLIER ); } @NonNull @Override public List\u0026lt;Double\u0026gt; getWheelVelocities() { // TODO: 인코더 속도가 초당 32767 카운트를 초과할 경우, Encoder.getRawVelocity()를 // Encoder.getCorrectedVelocity()로 변경하여 보정 메서드를 활성화하세요. return Arrays.asList( encoderTicksToInches(parallelEncoder.getRawVelocity()) * X_MULTIPLIER, encoderTicksToInches(perpendicularEncoder.getRawVelocity()) * Y_MULTIPLIER ); }\r참고: X_MULTIPLIER는 수평 엔코더에 작용하는 값입니다. 왜냐하면 x는 로컬 좌표계를 향해 있기 때문입니다 (로봇 공학/항공/등 상황에서 흔히 사용됩니다).\n물리적인 튜닝 과정을 진행합니다: 로봇이 이동할 수 있는 직선 구간을 준비합니다. 경기장 타일을 직선 형태로 배치하면 좋습니다. 로봇을 시작 지점에 두고 앞으로 직진하게 설정합니다. LocalizationTest opmode를 실행합니다. 단, 컨트롤러는 사용하면 안 됩니다. 손으로 로봇을 직선 구간을 따라 천천히 이동시킵니다. 가능한 똑바로 이동하도록 노력하세요. (로봇 옆에 테이프를 붙이고, 테이프와의 간격을 유지하면서 이동시키면 좋습니다.) 이동이 끝나면 멈춘 후, 실제 이동한 거리와 텔레메트리(Telemetry)에 기록된 이동 거리를 확인하세요. X 방향 보정 계수 계산: X_MULTIPLIER = 실제 이동 거리 / 텔레메트리 이동 거리\n예: 텔레메트리가 89인치를 표시하고 실제로 90인치를 이동했다면, X_MULTIPLIER는 1.01123596입니다. 동일한 과정을 통해 Y 방향(스트레이프) 보정 계수도 계산하고 설정합니다. 재확인 LocalizationTest opmode를 실행합니다. 로봇의 RC에서 192.168.49.1:8080/dash 또는 Control Hub에서 192.168.43.1:8080/dash로 접속합니다. 컨트롤러로 로봇을 이동시키면서 대시보드 상에서 로봇의 움직임이 실제 움직임과 일치하는지 확인합니다. X 좌표는 앞으로 이동 시 증가해야 하며, Y 좌표는 왼쪽으로 이동 시 증가해야 합니다. 문제가 발생하면 문제 해결(Troubleshooting) 섹션을 참고하세요.\n조율 (Tuning) - 오도메트리 세 개를 사용하는 경우 (Three-Wheel Odometry) 데드 휠의 튜닝은 매우 중요합니다. 이는 Road Runner뿐만 아니라 FTCLib 또는 직접 제작한 경로 추적 시스템에도 적용됩니다. 정확한 튜닝은 위치 및 거리 측정에서 발생하는 오류를 최소화하여 자율 주행 시 성능을 크게 향상시킬 수 있습니다.\n바퀴 반지름 조정 팁\n이 단계는 선택 사항이지만 로컬라이제이션 정확도를 약 1% 정도 향상시킬 수 있습니다. 1%가 별것 아닌 것처럼 보일 수 있지만, 100인치 이상의 주행 시 약 1인치 차이를 만들 수 있습니다. 예를 들어 FTC Skystone(2019-2020) 시즌에서 4~5개의 스톤을 운반하는 자율 주행은 100인치 이상 이동해야 했으며, 1인치의 추가 정확도가 큰 차이를 만들었을 수 있습니다.\n노트\n아래의 과정이 적용된 전체 코드는 예제 코드를 참고하세요.\nStandardTrackingWheelLocalizer.java 파일 열기\n해당 파일에서 아래 두 변수를 클래스에 선언합니다:\n/* StandardTrackingWheelLocalizer.java 파일의 약 37~38줄 */ public static double X_MULTIPLIER = 1; // X 방향 보정 계수 public static double Y_MULTIPLIER = 1; // Y 방향 보정 계수\r보정 계수를 getWheelPositions() 및 getWheelVelocities() 함수에 추가\n아래와 같이 코드를 수정합니다:\n/* StandardTrackingWheelLocalizer.java 파일 약 67~103줄 */ @NonNull @Override public List\u0026lt;Double\u0026gt; getWheelPositions() { return Arrays.asList( encoderTicksToInches(leftEncoder.getCurrentPosition()) * X_MULTIPLIER, encoderTicksToInches(rightEncoder.getCurrentPosition()) * X_MULTIPLIER, encoderTicksToInches(frontEncoder.getCurrentPosition()) * Y_MULTIPLIER ); } @NonNull @Override public List\u0026lt;Double\u0026gt; getWheelVelocities() { return Arrays.asList( encoderTicksToInches(leftEncoder.getCorrectedVelocity()) * X_MULTIPLIER, encoderTicksToInches(rightEncoder.getCorrectedVelocity()) * X_MULTIPLIER, encoderTicksToInches(frontEncoder.getCorrectedVelocity()) * Y_MULTIPLIER ); }\r참고: X 방향 보정 계수는 X 좌표가 로컬 좌표계에서 앞쪽으로 향하기 때문에 leftEncoder와rightEncoder에 적용됩니다.\n물리적인 튜닝 과정을 진행합니다:\n로봇이 이동할 수 있는 직선 구간을 준비합니다. 경기장 타일을 직선 형태로 배치하면 좋습니다. 로봇을 시작 지점에 두고 앞으로 직진하게 설정합니다. LocalizationTest opmode를 실행합니다. 단, 컨트롤러는 사용하면 안 됩니다. 손으로 로봇을 직선 구간을 따라 천천히 이동시킵니다. 가능한 똑바로 이동하도록 노력하세요. (로봇 옆에 테이프를 붙이고, 테이프와의 간격을 유지하면서 이동시키면 좋습니다.) 이동이 끝나면 멈춘 후, 실제 이동한 거리와 텔레메트리(Telemetry)에 기록된 이동 거리를 확인하세요. 보정 계수를 계산합니다. 보정 계수는 실제 이동 거리 / 텔레메트리 이동 거리로 계산됩니다.\n예를 들어 텔레메트리가 89인치를 표시하고 실제 측정값이 90인치라면, 보정 계수는 1.01123596이 됩니다.\n이 과정을 X방향(앞으로 이동)으로 3번 반복해 평균값을 구한 후 X_MULTIPLIER에 설정합니다.\nY방향(옆으로 이동)에서도 동일한 과정을 반복한 후, 계산된 Y 방향 계수를 Y_MULTIPLIER에 설정합니다.\n측면 거리 (Lateral Distance) 조율 측면 거리는 로컬라이제이션에서 방향 계산에 중요한 요소입니다. 이 값을 잘못 설정하면 방향 오차가 누적되어 로컬라이제이션 성능이 크게 저하됩니다.\nStandardTrackingWheelLocalizer.java 파일의 LATERAL_DISTANCE 값 확인을 확인합니다.\n해당 값을 실제 측정한 거리로 설정합니다. 이후 튜닝 과정에서 조율될 예정이니 정확하지 않더라도 괜찮습니다.\n로봇의 특정 지점(테이프 표시 등)을 기준으로 360° 회전 전후의 위치를 확인할 수 있도록 준비합니다.\nTrackingWheelLateralDistanceTuner OpMode를 실행합니다.\n대시보드를 사용하면 로봇의 상태를 시각적으로 확인할 수 있습니다. RC의 WiFi에 연결한 뒤, 브라우저에서 192.168.49.1:8080/dash (RC 전화 사용 시) 또는 192.168.43.1:8080/dash (Control Hub 사용 시)로 접속하세요.\nOpMode를 실행한 후 게임패드의 오른쪽 조이스틱을 사용해 로봇을 반시계 방향으로 회전시킵니다.\n로봇을 10회 반시계 방향으로 회전시키고 완료되면 게임패드의 Y 버튼을 눌러 튜닝을 종료합니다. 이후 시작 지점과 동일하게 정렬되었는지 확인합니다.\n출력된 LATERAL_DISTANCE 값을 StandardTrackingWheelLocalizer.java에 입력합니다.\n만약 값이 부정확하다면 직접 조정하면서 반복 테스트합니다.\n문제 해결 (Troubleshooting) 대시보드와 로봇 움직임 불일치 문제 해결: 대시보드에서 로봇이 실제와 반대로 옆으로 이동할 경우 수직 인코더의 방향을 반대로 설정하세요. 대시보드에서 로봇이 제자리에서 올바르게 회전하지 않을 경우 수직 휠의 위치가 잘못되어 회전 중심에 오프셋이 생긴 것입니다.\n수직 휠의 위치 조정은 복잡할 수 있으니, 약간의 오프셋은 그대로 두어도 괜찮습니다.\n이로 인해 로컬라이제이션 정확도는 영향을 받지 않으며, 단지 위치가 약간 이동하는 것뿐입니다. 대시보드에서 로봇이 직진하는 동안 회전할 경우 수평 엔코더 중 하나가 반대로 설정되어 있는 것입니다. 대시보드에서 로봇이 직진 및 스트레이프는 제대로 하지만, 회전 방향이 실제와 반대일 경우 좌측 및 우측 인코더가 서로 바뀌어 연결되어 있는 것입니다. 시간이 지남에 따라 로컬라이제이션 정확도가 떨어질 경우 로봇을 천천히 움직이며 테스트하세요. 가속을 최소화하려고 노력합니다. 느린 속도에서도 로컬라이제이션이 부정확하다면, 설정 값을 다시 확인하세요.\n헤딩(방향)이 정확한지 확인하고, 스트레이프 및 전진 움직임에서 측정된 거리와 실제 이동 거리가 일치하는지 확인하세요. 만약 느린 속도에서는 정확하지만, 빠른 속도에서 정확도가 떨어진다면 이는 하드웨어 문제일 가능성이 높습니다. 가장 흔한 원인은 데드 휠의 마찰력이 부족한 경우입니다. 데드 휠의 스프링 압력을 증가시켜 마찰력을 높이세요. ","date":"2023-09-07","id":6,"permalink":"/docs/4-tuning/%EB%8D%B0%EB%93%9C-%ED%9C%A0-%EC%84%A4%EC%A0%95-dead-wheels/","summary":"\u003cdiv class=\"callout callout-danger d-flex flex-row mt-4 mb-4 pt-4 pe-4 pb-2 ps-3\"\u003e\r\n  \u003csvg\n  xmlns=\"http://www.w3.org/2000/svg\"\n  width=\"24\"\n  height=\"24\"\n  viewBox=\"0 0 24 24\"\n  fill=\"none\"\n  stroke=\"currentColor\"\n  stroke-width=\"2\"\n  stroke-linecap=\"round\"\n  stroke-linejoin=\"round\"\n \n class=\"outline/alert-octagon svg-inline callout-icon me-2 mb-3\" id=\"svg-alert-octagon\" role=\"img\"\u003e\n  \u003cpath stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"/\u003e\n  \u003cpath d=\"M12.802 2.165l5.575 2.389c.48 .206 .863 .589 1.07 1.07l2.388 5.574c.22 .512 .22 1.092 0 1.604l-2.389 5.575c-.206 .48 -.589 .863 -1.07 1.07l-5.574 2.388c-.512 .22 -1.092 .22 -1.604 0l-5.575 -2.389a2.036 2.036 0 0 1 -1.07 -1.07l-2.388 -5.574a2.036 2.036 0 0 1 0 -1.604l2.389 -5.575c.206 -.48 .589 -.863 1.07 -1.07l5.574 -2.388a2.036 2.036 0 0 1 1.604 0z\" /\u003e\n  \u003cpath d=\"M12 8v4\" /\u003e\n  \u003cpath d=\"M12 16h.01\" /\u003e\n\u003c/svg\u003e\r\n  \u003cdiv class=\"callout-content\"\u003e\r\n    \u003cdiv class=\"callout-title\"\u003e\r\n        \u003cp\u003e경고\u003c/p\u003e","tags":[],"title":"데드 휠 설정 (Dead Wheels)"},{"content":"\r현재 단계는 주행 피드포워드 조율 단계입니다.\n피드포워드 컨트롤러를 정확히 튜닝하는 것은 경로를 따라 정확히 이동하기 위해 필수적입니다. 피드포워드 컨트롤러의 튜닝이 부정확하면 이후 과정에서 오류가 발생할 수 있습니다. Roadrunner Quickstart에는 자동 튜너와 수동 튜너가 포함되어 있지만, 많은 사용자가 자동 튜너가 최적의 결과를 제공하지 않는다고 느낍니다. 특히 자동 튜너는 kA 값을 제대로 계산하지 못할 가능성이 큽니다. 하지만 자동 튜너를 실행해 보고 얻은 수치를 사용하는 것은 개인의 자유이며, 수동으로 값을 얻고자 할지라도, 자동 튜너로 수치를 얻고, 이후 수동으로 값을 조정하는 것을 추천합니다.\n팁\nXbox 및 Logitech 게임패드에서 X 버튼을, PS4 듀얼쇼크에서 □ 버튼을 눌러 튜닝 프로세스를 일시 중지하고 운전자 제어 모드로 전환할 수 있습니다. Xbox 및 Logitech 게임패드에서 A 버튼을, PS4 듀얼쇼크에서 X 버튼을 눌러 다시 튜너에 제어권을 넘길 수 있습니다. 로봇이 경로를 벗어나면 운전자 제어 모드로 전환하여 로봇을 초기 위치로 되돌리십시오.\n조율 과정 (Tuning) 주의\n튜닝 과정에서 로봇이 천천히 경로에서 벗어나는 것은 정상입니다. 이 문제는 이후에 헤딩 및 병진 PID 튜닝 과정에서 해결될 것입니다.\nRC(Robot Controller)를 통해 ManualFeedforwardTuner OpMode를 실행합니다.\nRC의 Wi-Fi 네트워크에 연결합니다. 네트워크 비밀번호는 Program and Manage 메뉴에서 확인할 수 있습니다.\nRC로 핸드폰을 사용하는 경우 192.168.49.1:8080/dash, Control Hub의 경우 192.168.43.1:8080/dash로 이동합니다.\n페이지는 아래와 비슷하게 표시될 것입니다:\n예시 대시보드 화면\u0026lt;br\u0026gt;(그래프 내용은 무시하세요. 페이지 레이아웃 예시입니다)\rOpMode를 실행합니다. 프로그램을 시작하기 전에는 그래프가 나타나지 않습니다.\n프로그램 실행 후 그래프 버튼을 클릭하십시오. 그래프 대신 여러 체크박스가 나타날 경우, targetVelocity와 poseVelocity 체크박스를 선택하면 됩니다. 대시보드에서 오른쪽에 있는 DriveConstants 드롭다운을 찾습니다. 드롭다운을 열고, kA, kV, kStatic 변수를 찾으십시오. 곧 이 변수를 조정하게 될 것입니다.\n주의\n이 단계는 중요합니다. 속도 그래프에 안정기가 없는 경우 kV가 잘못된 것입니다. 이는 이후 정확도 문제로 이어질 수 있습니다. 안정기가 그래프에 나타나도록 거리를 늘리십시오.\nManualFeedforwardTuner 드롭다운에서 DISTANCE 변수가 충분히 커서 targetVelocity 라인이 안정기를 가질 수 있도록 설정하십시오. 그래프가 삼각형 모양처럼 보일 경우, DISTANCE 값을 늘리십시오. 팁\n거리가 충분하지 않은 경우, Drive Constants에서 `MAX_ACCEL` 값을 늘리거나 `MAX_VEL` 값을 줄일 수 있습니다. 단, 이는 궤적의 속도/가속도에 영향을 미칠 수 있으므로 주의하십시오.\rOpMode를 실행하면 로봇이 지정된 거리만큼 앞뒤로 이동할 것입니다. 목표는 poseVelocity 라인이 targetVelocity 라인과 일치하도록 하는 것입니다.\n추천 튜닝 과정:\nkV를 초기 값으로 1 / 최대 속도로 설정하십시오. poseVelocity 라인이 targetVelocity 안정기 그래프의 상단에 닿아야 합니다. 그렇지 않으면 kV를 늘리십시오.\nkA를 증가시켜 poseVelocity 라인의 기울기가 targetVelocity와 일치하도록 조정하십시오.\n아래의 참고 자료를 확인하여 각 게인의 역할을 시각적으로 이해하십시오.\n튜닝 팁\r참고 자료는 FRC 팀 1712의 Adaptive Pure Pursuit 논문에서 발췌되었습니다.\n이제 끝입니다! 적절히 튜닝된 피드포워드 컨트롤러의 예시는 아래를 참조하십시오.\n대시보드에서 조정한 값은 반드시 DriveConstants.java 파일의 해당 변수에 복사해야 합니다. 대시보드에서의 조정은 임시적이며, OpMode를 다시 시작하면 초기화됩니다.\n튜닝 시뮬레이터를 사용하여 각 수치가 동작에 미치는 영향을 확인하십시오.\n주의: 그래프가 완벽할 필요는 없습니다. \u0026ldquo;충분히 괜찮은\u0026rdquo; 상태로 두십시오. 그래프를 완벽하게 만드는 데 무한한 시간을 소비할 수 있습니다. 또한, Rev Hub의 내부 모터 컨트롤러 특성상 감속 시 약간의 범프가 발생하며, 이를 제거하는 것은 불가능합니다.\n튜닝된 피드포워드 컨트롤러의 예시 (팀 14320의 Deetz 제공):\n튜닝된 피드포워드 컨트롤러\r감속 시의 비대칭성이 보일 수 있습니다. 기본 모터 컨트롤 모델로는 완벽한 속도 제어를 달성할 수 없습니다. 감속 시 속도가 잘 추적되지 않는 것은 Rev Hub 모터 컨트롤러의 특성 때문일 가능성이 높습니다. 자세한 내용이나 이 문제에 대한 해결책이 있는 경우 FTC Discord에서 공유해 주세요.\n팁\nREV Hub의 출력 전압은 배터리 레벨이 떨어지면서 감소합니다. 따라서 피드포워드가 여러 경기에서 일관성을 보장하지 못할 수 있습니다. Road Runner에는 명시적인 포즈 속도 폐쇄 루프 제어가 없습니다. 이를 보완하려면 병진 PID 컨트롤러의 kD 항을 추가하세요. 자세한 내용은 팔로워 PID 페이지에서 확인할 수 있습니다.\n주의\nREV Hub의 모터 컨트롤러는 감속을 제대로 처리하지 못합니다. 이로 인해 감속 단계에서 피드포워드를 정확히 튜닝하는 것이 불가능합니다. 이는 매번 10% 정도의 오버슈트를 초래할 수 있으며, 이는 충분히 예상된 결과입니다. 따라서 이 문제를 무시하고 다음 단계로 진행하십시오. 이 문제는 팔로워 PID 조율 과정에서 해결될 것입니다.\n문제 해결 (Troubleshooting) MaxVelocityTuner가 역방향으로 움직이는 경우:\n바퀴 방향이 올바른지 확인하십시오. goBILDA 메카넘 차트를 참고하세요. poseVelocity가 반대로 움직이거나 targetVelocity를 따르지 않는 경우:\n로컬라이제이션에 문제가 있을 수 있습니다. LocalizationTest를 실행해 실제 위치와 일치하는지 확인하십시오. StraightTest 또는 ManualFeedforwardTuning OpMode가 계속 과도하게 움직이고 DriveConstants.java 값을 조정해도 변하지 않는 경우:\nDriveConstants.java에서 MAX_VEL 값을 낮춰 보십시오. 기타 모터 방향 문제:\n모터 방향 반전을 참고하십시오. 모터 구성을 디버깅하는 데 어려움을 겪고 있다면 모터 방향 디버거를 참조하세요. 모터 방향 디버거를 사용하면 모터를 하나씩 돌릴 수 있습니다. 41번 줄에서 @Disabled lin을 제거하고 opmode 주석의 지침을 따르십시오. 이를 사용하여 모터 구성 문제를 진단하고 적절하게 수정하세요. 피드포워드 조율 시뮬레이터 아래 링크로 들어가면 피드포워드 조율(Feedforward Tuning)을 시뮬레이션을 통해 연습해 볼 수 있습니다. 빠른 시일 내에 이 기능을 웹사이트의 기본 기능으로 추가하고자 합니다.\n시뮬레이션 바로가기\n","date":"2023-09-07","id":7,"permalink":"/docs/4-tuning/%EC%A3%BC%ED%96%89-%ED%94%BC%EB%93%9C%ED%8F%AC%EC%9B%8C%EB%93%9C-%EC%A1%B0%EC%9C%A8-driving-feedforward-tuner/","summary":"\u003cimg alt=\"diagram\" class=\"diagram diagram-kroki diagram-kroki-plantuml\" id=\"h-rh-cb-kroki-0\" src=\"/_10235469678620711340.svg\"\u003e\u003cp\u003e현재 단계는 \u003cstrong\u003e주행 피드포워드 조율\u003c/strong\u003e 단계입니다.\u003c/p\u003e\n\u003cp\u003e피드포워드 컨트롤러를 정확히 튜닝하는 것은 경로를 따라 정확히 이동하기 위해 필수적입니다.\n피드포워드 컨트롤러의 튜닝이 부정확하면 이후 과정에서 오류가 발생할 수 있습니다.\nRoadrunner Quickstart에는 자동 튜너와 수동 튜너가 포함되어 있지만,\n많은 사용자가 자동 튜너가 최적의 결과를 제공하지 않는다고 느낍니다.\n특히 자동 튜너는 \u003ccode\u003ekA\u003c/code\u003e 값을 제대로 계산하지 못할 가능성이 큽니다.\n하지만 자동 튜너를 실행해 보고 얻은 수치를 사용하는 것은 개인의 자유이며,\n수동으로 값을 얻고자 할지라도, 자동 튜너로 수치를 얻고, 이후 수동으로 값을 조정하는 것을 추천합니다.\u003c/p\u003e","tags":[],"title":"주행 피드포워드 조율 (Driving Feedforward Tuner)"},{"content":"\r현재 단계는 주행 피드포워드 조율 단계입니다.\n이 내용은 추후에 추가합니다.\n","date":"2023-09-07","id":8,"permalink":"/docs/4-tuning/%EC%A3%BC%ED%96%89-%EC%86%8D%EB%8F%84-pid-%EC%A1%B0%EC%9C%A8-driving-velocity-pid-tuner/","summary":"\u003cimg alt=\"diagram\" class=\"diagram diagram-kroki diagram-kroki-plantuml\" id=\"h-rh-cb-kroki-0\" src=\"/_8381636580440980473.svg\"\u003e\u003cp\u003e현재 단계는 \u003cstrong\u003e주행 피드포워드 조율\u003c/strong\u003e 단계입니다.\u003c/p\u003e\n\u003cp\u003e이 내용은 추후에 추가합니다.\u003c/p\u003e","tags":[],"title":"주행 속도 PID 조율 (Driving Velocity PID Tuner)"},{"content":"\r현재 단계는 직진 테스트 단계입니다.\n주의\n구동 인코더 로컬라이제이션(데드 휠 미사용)을 사용하는 경우, 아래 구동 인코더 로컬라이제이션 단계를 따라야 합니다. 이 섹션은 구동 인코더 로컬라이제이션 조정에 필수적입니다.\n속도 컨트롤러를 조정한 후, 모든 것이 제대로 작동하는지 확인하기 위해 간단한 직진 테스트를 실행해야 합니다.\n기본 직진 테스트 RC를 사용해 StraightTest OpMode를 실행합니다. 로봇이 이동한 거리를 측정합니다. 기본 설정에서 로봇은 60인치를 이동해야 합니다. 이 거리는 Dashboard 또는 OpMode 코드에서 변경할 수 있습니다. Dashboard에서 변경하려면, 오른쪽 변수 설정 사이드바에서 StraightTest 드롭다운을 찾고 DISTANCE 값을 수정합니다. OpMode에서 직접 변경하려면, StraightTest.java 파일에서 17번째 줄의 DISTANCE 값을 수정합니다. StraightTest 작업 모드를 23회 실행하여, 로봇이 지정된 거리 내에서 13% 정도의 일관성을 유지하는지 확인합니다. 로봇이 완전히 균일하게 움직이지 않을 수 있습니다. 이는 나중에 방향 및 폐쇄 루프 피드백이 활성화되면서 수정됩니다. 오차가 큰 경우 앞선 단계에서의 속도 조절기가 좀 더 정확하게 조율되어야 합니다. 로봇이 약간 치우쳐질 수 있습니다. 이는 후에 PID 조정 단계에서 수정될 것이기에 무시해도 됩니다. 경고\n피드포워드 조율을 수행한 경우 주의사항:\n로봇이 지정된 거리를 약 10~15% 초과할 가능성이 높습니다. 이 문제는 특히 조율이 빠르게 진행 되었을수록 더 심할 수 있습니다. 이는 REV Hub 모터 컨트롤러의 감속 제어 문제로 인해 발생합니다. 이 단계에서는 이 문제를 무시할 수 있습니다. 이후 추종 PID 조정 단계에서 kD와 kP 값을 조정하여 이 문제를 해결할 수 있습니다. (하지만 PID가 이를 완전히 수정하지 못한다면 kV값을 다시 조정해야할 수 있습니다.)\n모든 것이 정상적으로 작동하면 다음 단계로 진행하십시오. 가로 이동 계수 조정 - 데드 휠을 사용하는 경우 주의\n구동 인코더 로컬라이제이션(데드 휠 미사용)을 사용하는 경우 이 섹션을 건너뛰십시오.\n팁\n이는 필수적인 단계는 아닙니다 (데드 휠을 사용하는 경우). 하지만 메카넘 구동의 운동학적 특성상, 메카넘 구동은 가로 이동(strafing) 시 낮은 토크를 나타냅니다. 따라서 피드포워드 값에 약간의 보정이 필요할 수 있습니다. 이 단계를 건너뛴 경우라도, 변환 PID가 이러한 불일치를 대부분 보완하므로 문제를 알아차리지 못할 가능성이 높습니다. 하지만 가로 이동 중 목표 거리보다 짧게 이동(undershooting)하는 현상이 발생하면 **가로 이동 계수(Lateral Multiplier)**를 적용하는 것이 좋습니다.\n가로 이동의 비효율성은 이 문서를 참고하세요.\nRC를 사용해 StrafeTest OpMode를 실행합니다. OpMode를 실행하면 로봇이 오른쪽으로 지정된 거리만큼 이동합니다. (코드를 수정하여 왼쪽 이동으로 변경 가능) 기본 설정에서 로봇은 60인치를 이동해야 합니다. 그러나 실제 이동 거리는 이보다 짧을 수 있기에, 실제 이동 거리도 측정합니다. 목표 거리(기본값 60인치)를 실제 이동 거리로 나눕니다. 이 값을 SampleMecanumDrive.java 파일(57번째 줄)의 LATERAL_MULTIPLIER 변수에 설정합니다. StrafeTest 작업 모드를 다시 실행하여 수정된 값이 적용되었는지 확인합니다. 구동 인코더 로컬라이제이션 구동 인코더 로컬라이제이션(데드 휠 미사용)을 사용하는 경우, StraightTest와 StrafeTest 단계에서 로컬라이제이션을 조정해야 합니다.\n직진 테스트 StraightTest OpMode를 실행합니다. 실행이 완료되면 x와 y 이동 거리가 출력됩니다. 로봇이 한쪽으로 치우칠 수 있습니다. 이는 나중에 PID 조정이 활성화되면서 수정됩니다. 실제 이동 거리를 측정하고, 텔레메트리(Telemetry)에 표시된 finalX 값과 비교합니다. 두 값이 일치하지 않으면, DriveConstants.java 파일의 GEAR_RATIO를 실제 거리 / 출력된 x 값으로 곱하여 수정합니다. 이 과정을 여러 번 반복하여 정밀도를 높일 수 있습니다. 가능한 세밀하게 조절하는 것이 좋습니다. 가로 이동 테스트 StrafeTest 작업 모드를 실행합니다. 실행이 완료되면 x와 y 이동 거리가 출력됩니다. 로봇이 전후로 치우칠 수 있습니다. 이는 나중에 PID 조정이 활성화되면서 수정됩니다. 실제 이동 거리를 측정하고, 텔레메트리(Telemetry)에 표시된 finalY 값과 비교합니다. 두 값이 일치하지 않으면, SampleMecanumDrive.java 파일의 LATERAL_MULTIPLIER를 출력된 y 값 / 실제 거리로 설정합니다. 이 과정을 여러 번 반복하여 정밀도를 높일 수 있습니다. 가능한 세밀하게 조절하는 것이 좋습니다. 문제 해결 (Troubleshooting) 로봇이 직진 테스트에서 후진하거나 회전하는 경우: 모터 방향을 반대로 설정하십시오. 지침을 참조하세요.\n직진 테스트가 일관적이지만 지정된 거리에 도달하지 못하는 경우: DriveConstants.java 파일의 설정을 확인하세요.\nTICKS_PER_REV: 인코더의 사양을 확인 MAX_RPM: 모터의 최대 RPM 확인 WHEEL_RADIUS: 바퀴 반지름이 정확한지 확인 GEAR_RATIO: 출력:입력 비율 확인 로봇이 잘못된 방향으로 이동하는 경우: goBILDA 메카넘 차트 위와 동일하게 모터 방향을 확인하고 수정하세요. 이 외에도 아래 내용을 참고할 수 있습니다.\n모터 방향 반전을 참고하십시오. 모터 구성을 디버깅하는 데 어려움을 겪고 있다면 모터 방향 디버거를 참조하세요. 모터 방향 디버거를 사용하면 모터를 하나씩 돌릴 수 있습니다. 41번 줄에서 @Disabled lin을 제거하고 opmode 주석의 지침을 따르십시오. 이를 사용하여 모터 구성 문제를 진단하고 적절하게 수정하세요. 10% 초과 문제: REV Hub의 모터 컨트롤러는 감속을 제대로 처리하지 못합니다. 이로 인해 감속 단계에서 피드포워드를 정확히 튜닝하는 것이 불가능합니다. 이는 매번 10% 정도의 오버슈트를 초래할 수 있으며, 이는 충분히 예상된 결과입니다. 따라서 이 문제를 무시하고 다음 단계로 진행하십시오. 이 문제는 팔로워 PID 조율 과정에서 해결될 것입니다.\n팁\nkV 값을 줄여 오버슈트를 감소시키는 경우: 이는 로봇이 지정된 모션 프로파일을 정확히 따르는 능력에 부정적인 영향을 미칠 수 있습니다. 그러나 경로 전체를 따르는 정확성보다 최종 지점의 정확도가 더 중요하다는 점에서 이러한 부정확성을 어느 정도 용인할 수 있습니다. 우리는 폐루프 피드백(closed-loop feedback)이 경로를 따르는 과정에서 발생할 수 있는 문제를 해결할 것으로 기대하고 있습니다. kV 값을 줄여 오버슈트를 보완하면 특히 코스팅(coasting) 단계에서 모션 프로파일 정확도가 저하될 수 있습니다. 그러나 이 문제가 주로 빠른 기어비를 사용하는 시스템에서 나타나며, 이러한 경우 실제로 코스팅 단계에 많은 시간을 소비하지 않는 경우가 많습니다. 따라서 가속 및 감속 단계가 더 중요하게 여겨지므로, kV 값을 줄이는 것이 적절한 선택이 될 수 있습니다.\n","date":"2023-09-07","id":9,"permalink":"/docs/4-tuning/%EC%A7%81%EC%A7%84-%ED%85%8C%EC%8A%A4%ED%8A%B8-straight-test/","summary":"\u003cimg alt=\"diagram\" class=\"diagram diagram-kroki diagram-kroki-plantuml\" id=\"h-rh-cb-kroki-0\" src=\"/_4379547960681791084.svg\"\u003e\u003cp\u003e현재 단계는 \u003cstrong\u003e직진 테스트\u003c/strong\u003e 단계입니다.\u003c/p\u003e\n\u003cdiv class=\"callout callout-caution d-flex flex-row mt-4 mb-4 pt-4 pe-4 pb-2 ps-3\"\u003e\r\n  \u003csvg\n  xmlns=\"http://www.w3.org/2000/svg\"\n  width=\"24\"\n  height=\"24\"\n  viewBox=\"0 0 24 24\"\n  fill=\"none\"\n  stroke=\"currentColor\"\n  stroke-width=\"2\"\n  stroke-linecap=\"round\"\n  stroke-linejoin=\"round\"\n \n class=\"outline/alert-triangle svg-inline callout-icon me-2 mb-3\" id=\"svg-alert-triangle\" role=\"img\"\u003e\n  \u003cpath stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"/\u003e\n  \u003cpath d=\"M12 9v4\" /\u003e\n  \u003cpath d=\"M10.363 3.591l-8.106 13.534a1.914 1.914 0 0 0 1.636 2.871h16.214a1.914 1.914 0 0 0 1.636 -2.87l-8.106 -13.536a1.914 1.914 0 0 0 -3.274 0z\" /\u003e\n  \u003cpath d=\"M12 16h.01\" /\u003e\n\u003c/svg\u003e\r\n  \u003cdiv class=\"callout-content\"\u003e\r\n    \u003cdiv class=\"callout-title\"\u003e\r\n        \u003cp\u003e주의\u003c/p\u003e","tags":[],"title":"직진 테스트 (Straight Test)"},{"content":"\r현재 단계는 경로 폭 조율 단계입니다.\n주의\n트랙 너비를 조정하기 전에 로컬라이저의 방향 측정이 정확해야 합니다. 3-오도메트리 로컬라이저를 사용하는 경우, 측면 거리(lateral distance)를 먼저 조정하세요. 다른 경우에는 IMU를 통해 헤딩을 직접 얻어야 합니다.\n노트\n\u0026ldquo;경로 폭\u0026quot;라는 용어는 문맥에 따라 혼란을 줄 수 있으므로, 이를 명확히 설명합니다.\n경로 폭이란 두 개의 평행한 바퀴의 중심 간 거리입니다. 하지만, 이 용어는 상황에 따라 두 가지로 사용됩니다.\nDriveConstants.java에서의 경로 폭는 드라이브 트레인의 경로 폭를 의미합니다. 3-휠 로컬라이저에서의 트랙 너비는 두 평행한 바퀴의 중심 간 거리로, 이는 LATERAL_DISTANCE와 동일합니다. 현재는 로컬라이저를 다루지 않으므로, 이 페이지에서 언급되는 모든 \u0026ldquo;트랙 너비\u0026quot;는 드라이브 트레인의 트랙 너비를 의미합니다.\n2019/20 Skystone Bot (3658 Bosons)\r조율 과정 (Tuning Process) 최대 각속도 측정\n경로 폭 튜너를 실행하기 전에 로봇이 유지할 수 있는 최대 각속도를 측정해야 합니다. 각속도가 너무 높으면 튜너가 제대로 작동하지 않습니다.\nMaxAngularVelocityTuner OpMode를 실행합니다. 이 튜너는 로봇을 최대 속도로 몇 초 동안 회전시킵니다. 완료 후 \u0026ldquo;Max Angular Velocity\u0026rdquo; 값이 출력됩니다. 이 값을 DriveConstants.java의 MAX_ANG_VEL 필드에 설정하세요. 경로 폭 튜너 실행\nTrackWidthTuner OpMode를 실행합니다. OpMode를 실행하면 로봇이 180도를 5회 회전할 것입니다. 조정 중 로봇을 건드리면 안 됩니다. 실행 후, RC의 텔레메트리(Telemetry)에 \u0026ldquo;effective track width\u0026quot;가 출력됩니다. 트랙 너비 값 설정\n출력된 값이 실제 물리적 트랙 너비와 유사하다면(약간의 차이는 괜찮음), 이 값을 DriveConstants.java의 TRACK_WIDTH에 설정합니다. FTC 대시보드가 열려 있다면, 오른쪽 변수 구성 사이드바에서 트랙 너비를 직접 변경하며 테스트할 수 있습니다. (초기 추정치를 설정한 후 테스트하세요.) 로봇은 한 번 튜닝 할 때 마다 180도에 가까운 회전을 수행해야 합니다. 문제가 발생한다면 수동 조율을 해야합니다. (180도를 돌지 않거나, 경로 폭이 합리적이지 않은 경우) 수동 튜닝\n튜닝 결과가 만족스럽지 않거나 효과적인 트랙 너비 값이 합리적이지 않은 경우, 수동으로 트랙 너비를 조정합니다. 180도로 회전하도록 경로 폭를 조절하면 됩니다. 로봇이 180도보다 적게 회전하면 경로 폭를 늘리고, 180도보다 많이 회전하면 줄입니다. 노트\n튜닝 결과는 완벽할 필요가 없습니다. 약 ±2~3도 이내의 정확도면 충분합니다. 현재 단계는 폐루프 피드백이 없는 피드포워드 모션 프로파일을 사용합니다. 이후 팔로워 PID 튜닝 단계에서 헤딩 PID를 활성화하면 원하는 각도로 정확히 회전할 수 있습니다. 문제 해결 (Troubleshooting) 튜너 작동 불량 DriveConstants.java의 MAX_ANG_VEL 값을 줄여보세요. ","date":"2023-09-07","id":10,"permalink":"/docs/4-tuning/%EA%B2%BD%EB%A1%9C-%ED%8F%AD-%EC%A1%B0%EC%9C%A8-track-width-tuner/","summary":"\u003cimg alt=\"diagram\" class=\"diagram diagram-kroki diagram-kroki-plantuml\" id=\"h-rh-cb-kroki-0\" src=\"/_13807940720874502112.svg\"\u003e\u003cp\u003e현재 단계는 \u003cstrong\u003e경로 폭 조율\u003c/strong\u003e 단계입니다.\u003c/p\u003e\n\u003cdiv class=\"callout callout-caution d-flex flex-row mt-4 mb-4 pt-4 pe-4 pb-2 ps-3\"\u003e\r\n  \u003csvg\n  xmlns=\"http://www.w3.org/2000/svg\"\n  width=\"24\"\n  height=\"24\"\n  viewBox=\"0 0 24 24\"\n  fill=\"none\"\n  stroke=\"currentColor\"\n  stroke-width=\"2\"\n  stroke-linecap=\"round\"\n  stroke-linejoin=\"round\"\n \n class=\"outline/alert-triangle svg-inline callout-icon me-2 mb-3\" id=\"svg-alert-triangle\" role=\"img\"\u003e\n  \u003cpath stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"/\u003e\n  \u003cpath d=\"M12 9v4\" /\u003e\n  \u003cpath d=\"M10.363 3.591l-8.106 13.534a1.914 1.914 0 0 0 1.636 2.871h16.214a1.914 1.914 0 0 0 1.636 -2.87l-8.106 -13.536a1.914 1.914 0 0 0 -3.274 0z\" /\u003e\n  \u003cpath d=\"M12 16h.01\" /\u003e\n\u003c/svg\u003e\r\n  \u003cdiv class=\"callout-content\"\u003e\r\n    \u003cdiv class=\"callout-title\"\u003e\r\n        \u003cp\u003e주의\u003c/p\u003e","tags":[],"title":"경로 폭 조율 (Track Width Tuner)"},{"content":"\r현재 단계는 회전 테스트 단계입니다.\n회전 테스트 튜닝 회전 테스트는 경로 폭(Track Width)이 크게 잘못되지 않았는지 확인하는 단계입니다.\nRC를 통해 TurnTest OpMode를 실행합니다. 기본 설정에서 TurnTest는 로봇을 90도 회전시키도록 되어 있습니다. 로봇이 정확히 90도 회전하지 않을 수도 있습니다. 이는 약간의 피드포워드(Feedforward) 차이로 인한 것일 수 있습니다. 만약 정확히 회전하지 않는다면 Android Studio에서 TurnTest.java OpMode 파일로 이동하여 ANGLE 변수를 180도로 변경합니다. OpMode를 다시 실행합니다. 경로 폭을 올바르게 튜닝했다면 로봇이 정확히 180도 회전해야 합니다. 그렇지 않다면 경로 폭을 다시 튜닝하세요. 90도 회전 시 발생하는 오류는 걱정하지 마세요. 이 문제는 나중에 헤딩 PID(Heading PID)를 튜닝할 때 수정됩니다. 주의: TurnTest는 기본적으로 반시계 방향으로 90도 회전해야 합니다. 만약 기본 설정에서 로봇이 시계 방향으로 회전한다면, SampleMecanumDrive.java 파일에서 왼쪽과 오른쪽 구동 모터의 방향 설정이 뒤바뀌었는지 확인하세요. ","date":"2023-09-07","id":11,"permalink":"/docs/4-tuning/%ED%9A%8C%EC%A0%84-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%A1%B0%EC%9C%A8-turn-test-tuning/","summary":"\u003cimg alt=\"diagram\" class=\"diagram diagram-kroki diagram-kroki-plantuml\" id=\"h-rh-cb-kroki-0\" src=\"/_6321135533114844868.svg\"\u003e\u003cp\u003e현재 단계는 \u003cstrong\u003e회전 테스트\u003c/strong\u003e 단계입니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"회전-테스트-튜닝\"\u003e회전 테스트 튜닝\u003c/h3\u003e\n\u003cp\u003e회전 테스트는 경로 폭(Track Width)이 크게 잘못되지 않았는지 확인하는 단계입니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eRC를 통해 \u003ccode\u003eTurnTest\u003c/code\u003e OpMode를 실행합니다.\u003c/li\u003e\n\u003cli\u003e기본 설정에서 \u003ccode\u003eTurnTest\u003c/code\u003e는 로봇을 \u003cstrong\u003e90도 회전\u003c/strong\u003e시키도록 되어 있습니다.\u003c/li\u003e\n\u003cli\u003e로봇이 정확히 90도 회전하지 않을 수도 있습니다. 이는 약간의 피드포워드(Feedforward) 차이로 인한 것일 수 있습니다.\u003c/li\u003e\n\u003cli\u003e만약 정확히 회전하지 않는다면 Android Studio에서 \u003ccode\u003eTurnTest.java\u003c/code\u003e OpMode 파일로 이동하여 \u003ccode\u003eANGLE\u003c/code\u003e 변수를 \u003cstrong\u003e180도\u003c/strong\u003e로 변경합니다.\u003c/li\u003e\n\u003cli\u003eOpMode를 다시 실행합니다. 경로 폭을 올바르게 튜닝했다면 로봇이 정확히 \u003cstrong\u003e180도 회전\u003c/strong\u003e해야 합니다.\u003c/li\u003e\n\u003cli\u003e그렇지 않다면 경로 폭을 다시 튜닝하세요. 90도 회전 시 발생하는 오류는 걱정하지 마세요. 이 문제는 나중에 헤딩 PID(Heading PID)를 튜닝할 때 수정됩니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e주의:\u003c/strong\u003e \u003ccode\u003eTurnTest\u003c/code\u003e는 기본적으로 \u003cstrong\u003e반시계 방향으로 90도 회전\u003c/strong\u003e해야 합니다. 만약 기본 설정에서 로봇이 시계 방향으로 회전한다면, \u003ccode\u003eSampleMecanumDrive.java\u003c/code\u003e 파일에서 \u003cstrong\u003e왼쪽과 오른쪽 구동 모터의 방향 설정이 뒤바뀌었는지\u003c/strong\u003e 확인하세요.\u003c/li\u003e\n\u003c/ol\u003e","tags":[],"title":"회전 테스트 조율 (Turn Test Tuning)"},{"content":"\r현재 단계는 로컬라이제이션 (2번째) 테스트 단계입니다.\n경고\n데드 휠을 사용하는 경우 이 페이지를 무시하세요.\n로컬라이제이션 테스트 이 단계에서는 드라이브 인코더를 사용한 로컬라이제이션이 정확한지 확인합니다. 이 과정에서 발생하는 오류는 DriveConstants 파일의 문제 때문일 가능성이 높습니다.\nRC를 통해 LocalizationTest 오프모드를 실행합니다. RC에 연결된 스마트폰의 경우 192.168.49.1:8080/dash로, 컨트롤 허브(Control Hub)를 사용하는 경우 192.168.43.1:8080/dash로 접속합니다. 대시보드 오른쪽 상단에서 Field 보기를 선택했는지 확인합니다. 로봇을 이리저리 움직여 봅니다. 대시보드 맵에 로봇의 움직임이 그려져야 합니다. 대시보드 상에서 표시된 로봇의 방향이 실제 로봇의 방향과 일치하는지 확인합니다. 방향이 정확히 일치한다면 다음 단계로 진행합니다.\n그렇지 않다면 이전 단계로 돌아가 오류를 수정해야 합니다. ","date":"2023-09-07","id":12,"permalink":"/docs/4-tuning/%EB%A1%9C%EC%BB%AC%EB%9D%BC%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98-%ED%85%8C%EC%8A%A4%ED%8A%B8-localization-test/","summary":"\u003cimg alt=\"diagram\" class=\"diagram diagram-kroki diagram-kroki-plantuml\" id=\"h-rh-cb-kroki-0\" src=\"/_5519686397613862283.svg\"\u003e\u003cp\u003e현재 단계는 \u003cstrong\u003e로컬라이제이션 (2번째) 테스트\u003c/strong\u003e 단계입니다.\u003c/p\u003e\n\u003cdiv class=\"callout callout-danger d-flex flex-row mt-4 mb-4 pt-4 pe-4 pb-2 ps-3\"\u003e\r\n  \u003csvg\n  xmlns=\"http://www.w3.org/2000/svg\"\n  width=\"24\"\n  height=\"24\"\n  viewBox=\"0 0 24 24\"\n  fill=\"none\"\n  stroke=\"currentColor\"\n  stroke-width=\"2\"\n  stroke-linecap=\"round\"\n  stroke-linejoin=\"round\"\n \n class=\"outline/alert-octagon svg-inline callout-icon me-2 mb-3\" id=\"svg-alert-octagon\" role=\"img\"\u003e\n  \u003cpath stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"/\u003e\n  \u003cpath d=\"M12.802 2.165l5.575 2.389c.48 .206 .863 .589 1.07 1.07l2.388 5.574c.22 .512 .22 1.092 0 1.604l-2.389 5.575c-.206 .48 -.589 .863 -1.07 1.07l-5.574 2.388c-.512 .22 -1.092 .22 -1.604 0l-5.575 -2.389a2.036 2.036 0 0 1 -1.07 -1.07l-2.388 -5.574a2.036 2.036 0 0 1 0 -1.604l2.389 -5.575c.206 -.48 .589 -.863 1.07 -1.07l5.574 -2.388a2.036 2.036 0 0 1 1.604 0z\" /\u003e\n  \u003cpath d=\"M12 8v4\" /\u003e\n  \u003cpath d=\"M12 16h.01\" /\u003e\n\u003c/svg\u003e\r\n  \u003cdiv class=\"callout-content\"\u003e\r\n    \u003cdiv class=\"callout-title\"\u003e\r\n        \u003cp\u003e경고\u003c/p\u003e","tags":[],"title":"로컬라이제이션 테스트 (Localization Test)"},{"content":"\r현재 단계는 팔로워 PID 조율 단계입니다.\n이 단계는 마지막 튜닝 단계로, 폐쇄 루프 피드백 컨트롤러를 조정하는 과정입니다. 이를 통해 경로 추적 성능이 크게 향상될 것입니다.\n이 과정을 위해 사용할 수 있는 두 가지 OpMode가 있습니다:\nBackAndForth FollowerPIDTuner 먼저 BackAndForth 모드를 실행하여 대략적인 PID 게인을 설정한 뒤, FollowerPIDTuner를 사용해 세부적인 튜닝을 진행하는 것을 추천합니다.\nBackAndForth 모드는 로봇이 직선으로 앞뒤로 이동하며, 여기에서 병진 이동(Translation) 및 회전(Heading) PID의 주요 오류를 쉽게 확인할 수 있습니다.\nFollowerPIDTuner는 로봇이 큰 사각형 경로를 따라 이동하도록 설정합니다. 이때 각 코너에서 반시계 방향으로 회전합니다. 방향 조정이 부정확하면 전체 경로가 어긋나며, 로봇을 계속 초기화해야 하므로 과정이 다소 번거로울 수 있습니다. 따라서 초기 튜닝은 BackAndForth 모드에서 진행하고, 이후 세부 조정은 FollowerPIDTuner를 활용하는 것이 좋습니다.\n조율 과정 (Tuning Process) BackAndForth OpMode를 RC(Remote Control)에서 실행한다.\nRC의 Wi-Fi 네트워크에 연결합니다. 네트워크 비밀번호는 Program and Manage 메뉴에서 확인할 수 있습니다.\n브라우저에서 다음 주소로 이동합니다.\nRC 핸드폰 사용 시: 192.168.49.1:8080/dash Control Hub 사용 시: 192.168.43.1:8080/dash 화면 우측 상단에서 Field 뷰를 선택했는지 확인합니다.\n두 개의 선과 원이 화면에 그려지는 것을 확인합니다.\n초록색 : 목표 위치 파란색 : 로봇의 실제 위치 우측 사이드바에서 SampleMecanumDrive를 찾고 드롭다운을 여십시오. HEADING_PID와 TRANSLATION_PID 두 가지 옵션이 표시됩니다. 두 옵션 모두 SampleMecanumDrive 파일에 위치합니다.\n먼저 HEADING_PID를 먼저 엽니다.\nkP 값을 점진적으로 증가시키며 로봇이 정확한 헤딩을 유지하도록 조정하세요. 경험적으로 kP 값은 약 8 정도였지만, 환경에 따라 달라질 수 있습니다. 일반적으로 kD와 kI는 조정할 필요가 없습니다. TRANSLATION_PID를 엽니다.\n마찬가지로 kP 값을 점진적으로 증가시키며 로봇이 경로를 잘 따라가도록 조정하세요. 이 값도 약 8 정도였지만, 환경에 따라 달라질 수 있습니다. kD와 kI는 일반적으로 조정할 필요가 없습니다. 튜닝이 완료되면, 값을 SampleMecanumDrive.java 파일의 PID 객체에 복사하십시오. 대시보드에서 변경한 값이 코드에도 반영되도록 해야 합니다.\nFollowerPIDTuner를 사용해 동일한 과정을 반복하며 추가적인 정밀 튜닝을 진행하세요. 이는 더욱 정확한 결과를 얻기 위해 권장됩니다.\n튜닝이 완료되었으면 SplineTest를 실행해 경로 추적 정확도를 확인하세요.\n노트\n일반적으로 kI와 kD는 필요하지 않다고 했지만, 이는 기본 가이드라인일 뿐입니다. kD는 피드포워드(Feedforward)를 사용하는 경우 배터리 전압 변화에도 포즈 속도를 일정하게 유지하는 데 도움을 줄 수 있습니다. 이 경우 kD 값을 1 정도로 설정해보세요. 단, 주행 속도 PID를 사용하는 경우 kD를 설정하면 두 PID가 서로 충돌할 수 있으므로 사용하지 마세요. 비공식 영상 이 영상은 임시 영상입니다. 추후 업데이트될 예정입니다.\n","date":"2023-09-07","id":13,"permalink":"/docs/4-tuning/%ED%8C%94%EB%A1%9C%EC%9B%8C-pid-%EC%A1%B0%EC%9C%A8-follower-pid-tuner/","summary":"\u003cimg alt=\"diagram\" class=\"diagram diagram-kroki diagram-kroki-plantuml\" id=\"h-rh-cb-kroki-0\" src=\"/_10924514805406677008.svg\"\u003e\u003cp\u003e현재 단계는 \u003cstrong\u003e팔로워 PID 조율\u003c/strong\u003e 단계입니다.\u003c/p\u003e\n\u003cp\u003e이 단계는 마지막 튜닝 단계로, 폐쇄 루프 피드백 컨트롤러를 조정하는 과정입니다.\n이를 통해 경로 추적 성능이 크게 향상될 것입니다.\u003c/p\u003e","tags":[],"title":"팔로워 PID 조율 (Follower PID Tuner)"},{"content":"\r현재 단계는 스플라인 테스트 단계입니다.\n스플라인 테스트 병진 이동과 회전 PID가 조정되었으면, Spline Test를 실행하여 모든 것이 제대로 작동하는지 확인하세요. 대시보드를 열어 로봇이 올바르게 경로를 따라가는지 확인하세요. 로봇은 S자 형태의 경로를 따라가야 하며, 대시보드에서도 해당 경로가 올바르게 표시되어야 합니다. 만약 경로를 따르는 동안 약간의 **진동(oscillation)**이 발생한다면, 속도 PID(velocity PID) 또는 **병진 이동/회전 PID(translational/heading PID)**의 P 값이 너무 높을 가능성이 있습니다. 이 문제를 해결하려면 해당 PID 값을 다시 낮춰보며 조정하세요. 문제가 발생하면 원인을 진단하기 위해 다시 돌아가 문제를 분석하세요. **FTC Discord**에서 도움을 받을 수도 있습니다. 축하합니다! 모든 과정이 끝났습니다. 🎉 문제 진단 팁 대시보드를 열어 경로를 따라가는 동안 확인하세요.\nX, Y, Heading 에러를 관찰하며, 에러가 로컬라이저(Localizer) 때문인지 아니면 기본 경로 추적기(Base Path Follower) 때문인지 확인하세요. 병진 이동 / 회전 (Translational/Heading) PID를 끄기\n병진 이동 / 회전 PID의 계수를 0으로 설정하세요. 병진 이동 / 회전 PID를 껐을 때 경로 추적이 정상적으로 이루어진다면, 문제는 로컬라이저에 있습니다. LocalizationTest를 실행하고 로컬라이저(대부분 StandardTrackingWheelLocalizer)를 수정하세요. 병진 이동 / 회전 PID를 껐는데도 문제가 계속된다면, 문제는 구동 모터 방향이나 구동 상수(drive constants)에 있을 가능성이 높습니다. 모든 것을 차례로 끄면서 문제를 역추적하세요.\n처음부터 하나씩 각 구성 요소를 확인하며 점진적으로 문제를 해결하면 더 빠르게 원인을 파악할 수 있습니다. 포즈 히스토리 제한 해제\n대시보드의 필드에서 파란 선(포즈 히스토리, Pose History)이 사라지는 것을 방지하려면, SampleMecanumDrive에서 POSE_HISTORY_LIMIT 값을 -1로 설정하세요. 이는 디버깅에 유용할 수 있습니다. 속도와 가속도 제한 낮추기\nDriveConstants.java에서 속도(Velocity)와 가속도(Acceleration) 제한을 낮추세요. 실제 로봇이 달성할 수 있는 속도/가속도보다 높은 값을 설정하면, 로봇이 따라갈 수 없는 모션 프로파일이 생성되어 경로 추적이 실패할 수 있습니다. 심각한 문제가 있다면 최대 속도와 가속도를 절반으로 줄이고, 각속도/각가속도 값을 약 60도/초 정도로 낮춰보세요. 튜닝 OpMode 숨기기 Road Runner Quickstart에는 여러 튜닝 OpMode가 포함되어 있습니다.\n사용자 정의 OpMode를 추가하면 RC의 OpMode 목록이 혼잡해질 수 있습니다.\n튜닝 과정이 끝났다면, OpMode 클래스 선언 위에 @Disabled 주석을 추가해 숨길 수 있습니다.\n@Config @Disabled @Autonomous(group = \u0026#34;drive\u0026#34;) public class DriveVelocityPIDTuner extends LinearOpMode { public static double DISTANCE = 72; // in\r위와 같은 방식으로 간단히 비활성화하세요.\n","date":"2023-09-07","id":14,"permalink":"/docs/4-tuning/%EC%8A%A4%ED%94%8C%EB%9D%BC%EC%9D%B8-%ED%85%8C%EC%8A%A4%ED%8A%B8-spline-test/","summary":"\u003cimg alt=\"diagram\" class=\"diagram diagram-kroki diagram-kroki-plantuml\" id=\"h-rh-cb-kroki-0\" src=\"/_5143612574631989375.svg\"\u003e\u003cp\u003e현재 단계는 \u003cstrong\u003e스플라인 테스트\u003c/strong\u003e 단계입니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"스플라인-테스트\"\u003e스플라인 테스트\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e병진 이동과 회전 PID가 조정되었으면, Spline Test를 실행하여 모든 것이 제대로 작동하는지 확인하세요.\u003c/li\u003e\n\u003cli\u003e대시보드를 열어 로봇이 올바르게 경로를 따라가는지 확인하세요. 로봇은 S자 형태의 경로를 따라가야 하며, 대시보드에서도 해당 경로가 올바르게 표시되어야 합니다.\u003c/li\u003e\n\u003cli\u003e만약 경로를 따르는 동안 약간의 **진동(oscillation)**이 발생한다면, \u003cstrong\u003e속도 PID(velocity PID)\u003c/strong\u003e 또는 **병진 이동/회전 PID(translational/heading PID)**의 P 값이 너무 높을 가능성이 있습니다. 이 문제를 해결하려면 해당 PID 값을 다시 낮춰보며 조정하세요.\u003c/li\u003e\n\u003cli\u003e문제가 발생하면 원인을 진단하기 위해 다시 돌아가 문제를 분석하세요. **\u003ca href=\"https://discord.gg/first-tech-challenge\"\u003eFTC Discord\u003c/a\u003e**에서 도움을 받을 수도 있습니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003csmall\u003e 축하합니다! 모든 과정이 끝났습니다. 🎉 \u003c/small\u003e\u003c/p\u003e","tags":[],"title":"스플라인 테스트 (Spline Test)"},{"content":"","date":"2023-09-07","id":15,"permalink":"/docs/5-trajectory/%EA%B0%9C%EC%9A%94/","summary":"","tags":[],"title":"개요"},{"content":"","date":"2023-09-07","id":16,"permalink":"/docs/5-trajectory/trajectorybuilder-%ED%95%A8%EC%88%98-%EB%AA%A9%EB%A1%9D/","summary":"","tags":[],"title":"TrajectoryBuilder 함수 목록"},{"content":"","date":"2023-09-07","id":17,"permalink":"/docs/5-trajectory/%EB%A9%94%EC%9D%B4%ED%84%B0-maker-%EA%B0%80%EC%9D%B4%EB%93%9C/","summary":"","tags":[],"title":"메이터 (Maker) 가이드"},{"content":"","date":"2023-09-07","id":18,"permalink":"/docs/5-trajectory/%EA%B2%BD%EB%A1%9C-%EC%84%9C%EC%97%B4-%EC%A0%95%ED%95%98%EA%B8%B0-trajectory-sequence/","summary":"","tags":[],"title":"경로 서열 정하기 (Trajectory Sequence)"},{"content":"","date":"2023-09-07","id":19,"permalink":"/docs/6-advanced-tips/%EC%B6%94%EA%B0%80%EC%A0%81%EC%9D%B8-%EC%A0%95%EB%B3%B4/","summary":"","tags":[],"title":"추가적인 정보"},{"content":"","date":"2023-09-07","id":20,"permalink":"/docs/7-tools/meepmeep/","summary":"","tags":[],"title":"MeepMeep"},{"content":"","date":"2023-09-07","id":21,"permalink":"/docs/7-tools/roadrunner-gui/","summary":"","tags":[],"title":"RoadRunner GUI"},{"content":"","date":"2023-09-07","id":22,"permalink":"/docs/7-tools/davids-rrpathvisualizer/","summary":"","tags":[],"title":"David's RRPathVisualizer"},{"content":"","date":"2023-09-07","id":23,"permalink":"/docs/7-tools/rrpathgen/","summary":"","tags":[],"title":"RRPathGen"},{"content":"","date":"2023-09-07","id":24,"permalink":"/docs/5-trajectory/","summary":"","tags":[],"title":"경로 설정"},{"content":"","date":"2023-09-07","id":25,"permalink":"/docs/7-tools/","summary":"","tags":[],"title":"도구"},{"content":"","date":"2023-09-07","id":26,"permalink":"/docs/1-about-roadrunner/","summary":"","tags":[],"title":"로드러너란?"},{"content":"","date":"2023-09-07","id":27,"permalink":"/docs/2-before-you-start/","summary":"","tags":[],"title":"사전 준비"},{"content":"","date":"2023-09-07","id":28,"permalink":"/docs/3-installation/","summary":"","tags":[],"title":"설치"},{"content":"","date":"2023-09-07","id":29,"permalink":"/docs/4-tuning/","summary":"","tags":[],"title":"시스템 조율"},{"content":"","date":"2023-09-07","id":30,"permalink":"/docs/8-further-resources/","summary":"","tags":[],"title":"추가 리소스"},{"content":"","date":"2023-09-07","id":31,"permalink":"/docs/6-advanced-tips/","summary":"","tags":[],"title":"팁"},{"content":"","date":"2023-09-07","id":32,"permalink":"/docs/8-further-resources/%EC%B6%94%EA%B0%80-%EB%A6%AC%EC%86%8C%EC%8A%A4/","summary":"","tags":[],"title":"추가 리소스"},{"content":"Link to valuable, relevant resources.\n","date":"2024-02-27","id":33,"permalink":"/docs/resources/","summary":"\u003cp\u003eLink to valuable, relevant resources.\u003c/p\u003e","tags":[],"title":"Resources"},{"content":"","date":"2023-09-07","id":34,"permalink":"/docs/","summary":"","tags":[],"title":"Docs"},{"content":"","date":"2023-09-07","id":35,"permalink":"/privacy/","summary":"","tags":[],"title":"Privacy Policy"},{"content":"","date":"2023-09-07","id":36,"permalink":"/","summary":"","tags":[],"title":"Roadrunner Tutorial"},{"content":"","date":"0001-01-01","id":37,"permalink":"/categories/","summary":"","tags":[],"title":"Categories"},{"content":"","date":"0001-01-01","id":38,"permalink":"/contributors/","summary":"","tags":[],"title":"Contributors"},{"content":"","date":"0001-01-01","id":39,"permalink":"/tags/","summary":"","tags":[],"title":"Tags"}]